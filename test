SCRIPT  /usr/share/nvim/runtime/scripts.vim
Sourced 1 time
Total time:   0.000622
 Self time:   0.000622

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2020 Jun 07
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            "
                            " Note that the pattern matches are done with =~# to avoid the value of the
                            " 'ignorecase' option making a difference.  Where case is to be ignored use
                            " =~? instead.  Do not use =~ anywhere.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    1              0.000006 if did_filetype()
                              finish
    1              0.000001 endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    1              0.000005 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
    1              0.000001 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000012 let s:cpo_save = &cpo
    1              0.000013 set cpo&vim
                            
    1              0.000005 let s:line1 = getline(1)
                            
    1              0.000006 if s:line1 =~# "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env {options} bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              " Recognize only a few {options} that are commonly used.
                              if s:line1 =~# '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\(-[iS]\|--ignore-environment\|--split-string\)', '', '')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~# '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~# '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~# '^csh\>'
                                if exists("g:filetype_csh")
                                  call dist#ft#SetFileTypeShell(g:filetype_csh)
                                else
                                  call dist#ft#SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~# '^tcsh\>'
                                call dist#ft#SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~# '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~# '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~# '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~# 'make\>'
                                set ft=make
                            
                                " Pike
                              elseif s:name =~# '^pike\%(\>\|[0-9]\)'
                                set ft=pike
                            
                                " Lua
                              elseif s:name =~# 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~# 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~# 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~# 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~# 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~# '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~# 'ruby'
                                set ft=ruby
                            
                                " JavaScript
                              elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
                                set ft=javascript
                            
                                " BC calculator
                              elseif s:name =~# '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~# 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~# 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~# 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~# 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~# 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~# 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~# 'escript'
                                set ft=erlang
                            
                                " Haskell
                              elseif s:name =~# 'haskell'
                                set ft=haskell
                            
                                " Scala
                              elseif s:name =~# 'scala\>'
                                set ft=scala
                            
                                " Clojure
                              elseif s:name =~# 'clojure'
                                set ft=clojure
                            
                                " Free Pascal
                              elseif s:name =~# 'instantfpc\>'
                                set ft=pascal
                            
                                " Fennel
                              elseif s:name =~# 'fennel\>'
                                set ft=fennel
                            
                              endif
                              unlet s:name
                            
    1              0.000001 else
                              " File does not start with "#!".
                            
    1              0.000002   let s:line2 = getline(2)
    1              0.000002   let s:line3 = getline(3)
    1              0.000002   let s:line4 = getline(4)
    1              0.000002   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    1              0.000003   if s:line1 =~# '^:$'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                              " Z shell scripts
    1              0.000026   elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
    1              0.000010   elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                              " Mason
    1              0.000003   elseif s:line1 =~# '^<[%&].*>'
                                set ft=mason
                            
                              " Vim scripts (must have '" vim' as the first line to trigger this)
    1              0.000003   elseif s:line1 =~# '^" *[vV]im$'
                                set ft=vim
                            
                              " libcxx and libstdc++ standard library headers like "iostream" do not have
                              " an extension, recognize the Emacs file mode.
    1              0.000003   elseif s:line1 =~? '-\*-.*C++.*-\*-'
                                set ft=cpp
                            
                              " MOO
    1              0.000009   elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
    1              0.000040   elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ')
                            	\ || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ')
                            	\ || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ')
                            	\ || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ ')))
                            	\ || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
    1              0.000003   elseif s:line1 =~# '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
    1              0.000012   elseif s:line1 =~# '^\s*dnl\>'
                            	\ || s:line2 =~# '^\s*dnl\>'
                            	\ || s:line3 =~# '^\s*dnl\>'
                            	\ || s:line4 =~# '^\s*dnl\>'
                            	\ || s:line5 =~# '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
    1              0.000004   elseif $TERM == "amiga"
                            	\ && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
    1              0.000004   elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
    1              0.000003   elseif s:line1 =~# '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
    1              0.000003   elseif s:line1 =~# '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
    1              0.000003   elseif s:line1 =~# '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                " Avoid "doctype html", used by slim.
    1              0.000004   elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
    1              0.000002   elseif s:line1 =~# '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
    1              0.000007   elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
    1              0.000005   elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
    1              0.000005   elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
    1              0.000002   elseif s:line1 =~# '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
    1              0.000002   elseif s:line1 =~# '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
    1              0.000004   elseif s:line1 =~# '^SNNS network definition file'
                                set ft=snnsnet
    1              0.000004   elseif s:line1 =~# '^SNNS pattern definition file'
                                set ft=snnspat
    1              0.000003   elseif s:line1 =~# '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
    1              0.000013   elseif s:line1 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~# '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
    1              0.000007   elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
    1              0.000005   elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
    1              0.000006   elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
                                set ft=takout
    1              0.000005   elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
    1              0.000003   elseif getline(6) =~# 'Run Date: '
                                set ft=takcmp
    1              0.000003   elseif getline(9) =~# 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
    1              0.000012   elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
    1              0.000018   elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC '
                            	\ || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
                                set ft=baan
                            
                              " Valgrind
    1              0.000007   elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
    1              0.000004   elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
    1              0.000003   elseif s:line1 =~# '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
    1              0.000005   elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
    1              0.000015   elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
    1              0.000003    elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~# '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
    1              0.000003   elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " YAML
    1              0.000002   elseif s:line1 =~# '^%YAML'
                                set ft=yaml
                            
                              " CVS diff
    1              0.000001   else
    1              0.000003     let s:lnum = 1
    1              0.000005     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
                                  let s:lnum += 1
    1              0.000001     endwhile
    1              0.000004     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
    1              0.000027     elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
    1              0.000001     endif
    1              0.000002     unlet s:lnum
                            
    1              0.000001   endif
                            
    1              0.000002   unlet s:line2 s:line3 s:line4 s:line5
                            
    1              0.000001 endif
                            
                            " Restore 'cpoptions'
    1              0.000010 let &cpo = s:cpo_save
                            
    1              0.000003 unlet s:cpo_save s:line1

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/everforest/after/ftplugin/nerdtree/everforest.vim
Sourced 3 times
Total time:   0.000684
 Self time:   0.000684

count  total (s)   self (s)
    3              0.000057 if !exists('g:colors_name') || g:colors_name !=# 'everforest'
                                finish
    3              0.000004 endif
    3              0.000016 if index(g:everforest_loaded_file_types, 'nerdtree') ==# -1
    1              0.000009     call add(g:everforest_loaded_file_types, 'nerdtree')
    2              0.000002 else
    2              0.000002     finish
    1              0.000001 endif
                            " ft_begin: nerdtree {{{
                            " https://github.com/preservim/nerdtree
    1              0.000088 highlight! link NERDTreeDir Green
    1              0.000060 highlight! link NERDTreeDirSlash Aqua
    1              0.000034 highlight! link NERDTreeOpenable Orange
    1              0.000033 highlight! link NERDTreeClosable Orange
    1              0.000033 highlight! link NERDTreeFile Fg
    1              0.000033 highlight! link NERDTreeExecFile Yellow
    1              0.000033 highlight! link NERDTreeUp Grey
    1              0.000036 highlight! link NERDTreeCWD Aqua
    1              0.000029 highlight! link NERDTreeHelp LightGrey
    1              0.000032 highlight! link NERDTreeToggleOn Green
    1              0.000033 highlight! link NERDTreeToggleOff Red
    1              0.000033 highlight! link NERDTreeFlags Orange
    1              0.000033 highlight! link NERDTreeLinkFile Grey
    1              0.000032 highlight! link NERDTreeLinkTarget Green
                            " ft_end

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/nerdtree/syntax/nerdtree.vim
Sourced 3 times
Total time:   0.004819
 Self time:   0.004819

count  total (s)   self (s)
    3              0.000014 let s:tree_up_dir_line = '.. (up a dir)'
    3              0.000041 syn match NERDTreeIgnore #\~#
    3              0.000024 exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'
                            
                            "highlighting for the .. (up dir) line at the top of the tree
    3              0.000106 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line .'#'
                            
                            "quickhelp syntax elements
    3              0.000046 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
    3              0.000013 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
    3              0.000034 syn match NERDTreeHelpTitle #" .*\~$#ms=s+2,me=e-1
    3              0.000060 syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
    3              0.000049 syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
    3              0.000038 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
    3              0.000218 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
                            
                            "highlighting for sym links
    3              0.000182 syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
    3              0.000115 syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
    3              0.000103 syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
                            
                            "highlighting to conceal the delimiter around the file/dir name
    3              0.000015 if has('conceal')
    3              0.000059     exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# conceal containedin=ALL'
    3              0.000039     setlocal conceallevel=2 concealcursor=nvic
                            else
                                exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# containedin=ALL'
                                hi! link NERDTreeNodeDelimiters Ignore
    3              0.000003 endif
                            
                            "highlighing for directory nodes and file nodes
    3              0.000114 syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
                            
    3              0.000009 if g:NERDTreeDirArrowExpandable !=# ''
    3              0.000230     exec 'syn match NERDTreeClosable #' . escape(g:NERDTreeDirArrowCollapsible, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
    3              0.000203     exec 'syn match NERDTreeOpenable #' . escape(g:NERDTreeDirArrowExpandable, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
    3              0.000025     let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
    3              0.000060     exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
    3              0.000115     exec 'syn match NERDTreeExecFile #^.*'.g:NERDTreeNodeDelimiter.'\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark'
    3              0.000169     exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
                            else
                                exec 'syn match NERDTreeDir #[^'.g:NERDTreeNodeDelimiter.']\{-}/\ze\($\|'.g:NERDTreeNodeDelimiter.'\)#'
                                exec 'syn match NERDTreeExecFile #[^'.g:NERDTreeNodeDelimiter.']\{-}'.g:NERDTreeNodeDelimiter.'\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark'
                                exec 'syn match NERDTreeFile     #^.*'.g:NERDTreeNodeDelimiter.'.*[^\/]\($\|'.g:NERDTreeNodeDelimiter.'.*\)# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
    3              0.000002 endif
                            
                            "highlighting for readonly files
    3              0.000114 exec 'syn match NERDTreeRO #.*'.g:NERDTreeNodeDelimiter.'\zs.*\ze'.g:NERDTreeNodeDelimiter.'.*\['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile'
                            
    3              0.000332 exec 'syn match NERDTreeFlags #\[[^\]]*\]\ze'.g:NERDTreeNodeDelimiter.'# containedin=NERDTreeFile,NERDTreeExecFile,NERDTreeLinkFile,NERDTreeRO,NERDTreeDir'
                            
    3              0.000051 syn match NERDTreeCWD #^[</].*$#
                            
                            "highlighting for bookmarks
    3              0.000013 syn match NERDTreeBookmark # {.*}#hs=s+1
                            
                            "highlighting for the bookmarks table
    3              0.000035 syn match NERDTreeBookmarksLeader #^>#
    3              0.000043 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
    3              0.000038 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
    3              0.000019 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
                            
    3              0.000095 hi def link NERDTreePart Special
    3              0.000082 hi def link NERDTreePartFile Type
    3              0.000092 hi def link NERDTreeExecFile Title
    3              0.000084 hi def link NERDTreeDirSlash Identifier
                            
    3              0.000049 hi def link NERDTreeBookmarksHeader statement
    3              0.000050 hi def link NERDTreeBookmarksLeader ignore
    3              0.000053 hi def link NERDTreeBookmarkName Identifier
    3              0.000053 hi def link NERDTreeBookmark normal
                            
    3              0.000091 hi def link NERDTreeHelp String
    3              0.000051 hi def link NERDTreeHelpKey Identifier
    3              0.000051 hi def link NERDTreeHelpCommand Identifier
    3              0.000056 hi def link NERDTreeHelpTitle Macro
    3              0.000085 hi def link NERDTreeToggleOn Question
    3              0.000084 hi def link NERDTreeToggleOff WarningMsg
                            
    3              0.000095 hi def link NERDTreeLinkTarget Type
    3              0.000095 hi def link NERDTreeLinkFile Macro
    3              0.000046 hi def link NERDTreeLinkDir Macro
                            
    3              0.000071 hi def link NERDTreeDir Directory
    3              0.000070 hi def link NERDTreeUp Directory
    3              0.000069 hi def link NERDTreeFile Normal
    3              0.000066 hi def link NERDTreeCWD Statement
    3              0.000090 hi def link NERDTreeOpenable Directory
    3              0.000080 hi def link NERDTreeClosable Directory
    3              0.000040 hi def link NERDTreeIgnore ignore
    3              0.000044 hi def link NERDTreeRO WarningMsg
    3              0.000040 hi def link NERDTreeBookmark Statement
    3              0.000067 hi def link NERDTreeFlags Number
                            
    3              0.000062 hi def link NERDTreeCurrentNode Search
                            
    3              0.000044 hi NERDTreeFile ctermbg=NONE guibg=NONE

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vsnip.vim
Sourced 1 time
Total time:   0.005741
 Self time:   0.000415

count  total (s)   self (s)
    1   0.005462   0.000252 let s:Session = vsnip#session#import()
    1   0.000008   0.000007 let s:Snippet = vsnip#snippet#import()
    1   0.000068   0.000007 let s:TextEdit = vital#vsnip#import('VS.LSP.TextEdit')
    1   0.000060   0.000007 let s:Position = vital#vsnip#import('VS.LSP.Position')
                            
    1              0.000002 let s:session = v:null
    1              0.000002 let s:selected_text = ''
                            
                            "
                            " vsnip#selected_text.
                            "
    1              0.000002 function! vsnip#selected_text(...) abort
                              if len(a:000) == 1
                                let s:selected_text = a:000[0]
                              else
                                return s:selected_text
                              endif
                            endfunction
                            
                            "
                            " vsnip#available.
                            "
    1              0.000001 function! vsnip#available(...) abort
                              let l:direction = get(a:000, 0, 1)
                              return vsnip#expandable() || vsnip#jumpable(l:direction)
                            endfunction
                            
                            "
                            " vsnip#expandable.
                            "
    1              0.000001 function! vsnip#expandable() abort
                              return !empty(vsnip#get_context())
                            endfunction
                            
                            "
                            " vsnip#jumpable.
                            "
    1              0.000001 function! vsnip#jumpable(...) abort
                              let l:direction = get(a:000, 0, 1)
                              return !empty(s:session) && s:session.jumpable(l:direction)
                            endfunction
                            
                            "
                            " vsnip#expand
                            "
    1              0.000001 function! vsnip#expand() abort
                              let l:context = vsnip#get_context()
                              if !empty(l:context)
                                call s:TextEdit.apply(bufnr('%'), [{
                                \   'range': l:context.range,
                                \   'newText': ''
                                \ }])
                                call vsnip#anonymous(join(l:context.snippet.body, "\n"), {
                                \   'position': l:context.range.start
                                \ })
                              endif
                            endfunction
                            
                            "
                            " vsnip#anonymous.
                            "
    1              0.000001 function! vsnip#anonymous(text, ...) abort
                              let l:option = get(a:000, 0, {})
                              let l:prefix = get(l:option, 'prefix', v:null)
                              let l:position = get(l:option, 'position', s:Position.cursor())
                            
                              if l:prefix isnot# v:null
                                let l:position.character -= strchars(l:prefix)
                                call s:TextEdit.apply(bufnr('%'), [{
                                \   'range': {
                                \     'start': l:position,
                                \     'end': {
                                \       'line': l:position.line,
                                \       'character': l:position.character + strchars(l:prefix),
                                \     },
                                \   },
                                \   'newText': ''
                                \ }])
                              endif
                            
                              let l:session = s:Session.new(bufnr('%'), l:position, a:text)
                            
                              call vsnip#selected_text('')
                            
                              if !empty(s:session)
                                call s:session.flush_changes() " try to sync buffer content because vsnip#expand maybe remove prefix
                              endif
                            
                              if empty(s:session)
                                let s:session = l:session
                                call s:session.expand()
                              else
                                call s:session.merge(l:session)
                              endif
                            
                              doautocmd <nomodeline> User vsnip#expand
                            
                              call s:session.refresh()
                              call s:session.jump(1)
                            endfunction
                            
                            "
                            " vsnip#get_session
                            "
    1              0.000001 function! vsnip#get_session() abort
                              return s:session
                            endfunction
                            
                            "
                            " vsnip#deactivate
                            "
    1              0.000001 function! vsnip#deactivate() abort
                              let s:session = {}
                            endfunction
                            
                            "
                            " get_context.
                            "
    1              0.000001 function! vsnip#get_context() abort
                              let l:offset = mode()[0] ==# 'i' ? 2 : 1
                              let l:before_text = getline('.')[0 : col('.') - l:offset]
                              let l:before_text_len = strchars(l:before_text)
                            
                              if l:before_text_len == 0
                                return {}
                              endif
                            
                              let l:sources = vsnip#source#find(bufnr('%'))
                            
                              " Search prefix
                              for l:source in l:sources
                                for l:snippet in l:source
                                  for l:prefix in l:snippet.prefix
                                    let l:prefix_len = strchars(l:prefix)
                                    if strcharpart(l:before_text, l:before_text_len - l:prefix_len, l:prefix_len) !=# l:prefix
                                      continue
                                    endif
                                    if l:prefix =~# '^\h' && l:before_text !~# '\<\V' . escape(l:prefix, '\/?') . '\m$'
                                      continue
                                    endif
                                    return s:create_context(l:snippet, l:before_text_len, l:prefix_len)
                                  endfor
                                endfor
                              endfor
                            
                              " Search prefix-alias
                              for l:source in l:sources
                                for l:snippet in l:source
                                  for l:prefix in l:snippet.prefix_alias
                                    let l:prefix_len = strchars(l:prefix)
                                    if strcharpart(l:before_text, l:before_text_len - l:prefix_len, l:prefix_len) !=# l:prefix
                                      continue
                                    endif
                                    if l:prefix =~# '^\h' && l:before_text !~# '\<\V' . escape(l:prefix, '\/?') . '\m$'
                                      continue
                                    endif
                                    return s:create_context(l:snippet, l:before_text_len, l:prefix_len)
                                  endfor
                                endfor
                              endfor
                            
                              return {}
                            endfunction
                            
                            "
                            " vsnip#get_complete_items
                            "
    1              0.000002 function! vsnip#get_complete_items(bufnr) abort
                              let l:uniq = {}
                              let l:candidates = []
                            
                              for l:source in vsnip#source#find(a:bufnr)
                                for l:snippet in l:source
                                  for l:prefix in l:snippet.prefix
                                    if has_key(l:uniq, l:prefix)
                                      continue
                                    endif
                                    let l:uniq[l:prefix] = v:true
                            
                                    let l:menu = ''
                                    let l:menu .= '[v]'
                                    let l:menu .= ' '
                                    let l:menu .= (strlen(l:snippet.description) > 0 ? l:snippet.description : l:snippet.label)
                            
                                    call add(l:candidates, {
                                    \   'word': l:prefix,
                                    \   'abbr': l:prefix,
                                    \   'kind': 'Snippet',
                                    \   'menu': l:menu,
                                    \   'dup': 1,
                                    \   'user_data': json_encode({
                                    \     'vsnip': {
                                    \       'snippet': l:snippet.body
                                    \     }
                                    \   })
                                    \ })
                                  endfor
                                endfor
                              endfor
                            
                              return l:candidates
                            endfunction
                            
                            "
                            " vsnip#decode
                            "
    1              0.000002 function! vsnip#to_string(text) abort
                              let l:text = type(a:text) == type([]) ? join(a:text, "\n") : a:text
                              return s:Snippet.new(s:Position.cursor(), l:text).text()
                            endfunction
                            
                            "
                            " vsnip#debug
                            "
    1              0.000001 function! vsnip#debug() abort
                              if !empty(s:session)
                                call s:session.snippet.debug()
                              endif
                            endfunction
                            
                            "
                            " create_context
                            "
    1              0.000003 function! s:create_context(snippet, before_text_len, prefix_len) abort
                              let l:line = line('.') - 1
                              return {
                              \   'range': {
                              \     'start': {
                              \       'line': l:line,
                              \       'character': a:before_text_len - a:prefix_len
                              \     },
                              \     'end': {
                              \       'line': l:line,
                              \       'character': a:before_text_len
                              \     }
                              \   },
                              \   'snippet': a:snippet
                              \ }
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vsnip/session.vim
Sourced 1 time
Total time:   0.005185
 Self time:   0.000546

count  total (s)   self (s)
    1   0.002041   0.000248 let s:Snippet = vsnip#snippet#import()
    1   0.002210   0.000009 let s:TextEdit = vital#vsnip#import('VS.LSP.TextEdit')
    1   0.000065   0.000010 let s:Position = vital#vsnip#import('VS.LSP.Position')
    1   0.000598   0.000008 let s:Diff = vital#vsnip#import('VS.LSP.Diff')
                            
                            "
                            " import.
                            "
    1              0.000002 function! vsnip#session#import() abort
                              return s:Session
                            endfunction
                            
    1              0.000002 let s:Session = {}
                            
                            "
                            " new.
                            "
    1              0.000002 function! s:Session.new(bufnr, position, text) abort
                              return extend(deepcopy(s:Session), {
                              \   'bufnr': a:bufnr,
                              \   'buffer': getbufline(a:bufnr, '^', '$'),
                              \   'timer_id': -1,
                              \   'changedtick': getbufvar(a:bufnr, 'changedtick', 0),
                              \   'snippet': s:Snippet.new(a:position, vsnip#indent#adjust_snippet_body(getline('.'), a:text)),
                              \   'tabstop': -1,
                              \   'changenr': changenr(),
                              \   'changenrs': {},
                              \ })
                            endfunction
                            
                            "
                            " expand.
                            "
    1              0.000001 function! s:Session.expand() abort
                              " insert snippet.
                              call s:TextEdit.apply(self.bufnr, [{
                              \   'range': {
                              \     'start': self.snippet.position,
                              \     'end': self.snippet.position
                              \   },
                              \   'newText': self.snippet.text()
                              \ }])
                              call self.store(changenr())
                            endfunction
                            
                            "
                            " merge.
                            "
    1              0.000001 function! s:Session.merge(session) abort
                              call a:session.expand()
                              call self.snippet.merge(self.tabstop, a:session.snippet)
                              call self.snippet.insert(deepcopy(a:session.snippet.position), a:session.snippet.children)
                              call s:TextEdit.apply(self.bufnr, self.snippet.sync())
                            endfunction
                            
                            "
                            " jumpable.
                            "
    1              0.000001 function! s:Session.jumpable(direction) abort
                              if a:direction == 1
                                let l:jumpable = !empty(self.snippet.get_next_jump_point(self.tabstop))
                              else
                                let l:jumpable = !empty(self.snippet.get_prev_jump_point(self.tabstop))
                              endif
                              return l:jumpable
                            endfunction
                            
                            "
                            " jump.
                            "
    1              0.000001 function! s:Session.jump(direction) abort
                              call self.flush_changes()
                            
                              if a:direction == 1
                                let l:jump_point = self.snippet.get_next_jump_point(self.tabstop)
                              else
                                let l:jump_point = self.snippet.get_prev_jump_point(self.tabstop)
                              endif
                            
                              if empty(l:jump_point)
                                return
                              endif
                            
                              let self.tabstop = l:jump_point.placeholder.id
                            
                              " choice.
                              if len(l:jump_point.placeholder.choice) > 0
                                call self.choice(l:jump_point)
                            
                                " select.
                              elseif l:jump_point.range.start.character != l:jump_point.range.end.character
                                call self.select(l:jump_point)
                            
                                " move.
                              else
                                call self.move(l:jump_point)
                              endif
                            
                              doautocmd <nomodeline> User vsnip#jump
                            endfunction
                            
                            "
                            " choice.
                            "
    1              0.000001 function! s:Session.choice(jump_point) abort
                              call self.move(a:jump_point)
                            
                              let l:fn = {}
                              let l:fn.jump_point = a:jump_point
                              function! l:fn.next_tick() abort
                                if mode()[0] ==# 'i'
                                  let l:pos = s:Position.lsp_to_vim('%', self.jump_point.range.start)
                                  call complete(l:pos[1], map(copy(self.jump_point.placeholder.choice), { k, v -> {
                                  \   'word': v.escaped,
                                  \   'abbr': v.escaped,
                                  \   'menu': '[vsnip]',
                                  \   'kind': 'Choice'
                                  \ } }))
                                endif
                              endfunction
                              call timer_start(g:vsnip_choice_delay, { -> l:fn.next_tick() })
                            endfunction
                            
                            "
                            " select.
                            "
                            " @NOTE: Must work even if virtualedit=all/onmore or not.
                            "
    1              0.000001 function! s:Session.select(jump_point) abort
                              let l:pos = s:Position.lsp_to_vim('%', a:jump_point.range.end)
                              call cursor([l:pos[0], l:pos[1] - 1]) " Use `a:jump_point.range.end as inclusive position
                            
                              let l:select_length = strlen(a:jump_point.placeholder.text()) - 1
                              let l:cmd = ''
                              let l:cmd .= mode()[0] ==# 'i' ? "\<Esc>l" : ''
                              let l:cmd .= printf('v%s', l:select_length > 0 ? l:select_length . 'h' : '')
                              if get(g:, 'vsnip_test_mode', v:false)
                                let l:cmd .= "\<Esc>gvo\<C-g>" " Update `last visual selection` for getting it in test.
                                execute printf('normal! %s', l:cmd)
                              else
                                let l:cmd .= "o\<C-g>"
                                call s:feedkeys(l:cmd, 'n')
                              endif
                            endfunction
                            
                            "
                            " move.
                            "
                            " @NOTE: Must work even if virtualedit=all/onmore or not.
                            "
    1              0.000001 function! s:Session.move(jump_point) abort
                              let l:pos = s:Position.lsp_to_vim('%', a:jump_point.range.end)
                            
                              call cursor(l:pos)
                            
                              if l:pos[1] > strlen(getline(l:pos[0]))
                                startinsert!
                              else
                                startinsert
                              endif
                            endfunction
                            
                            "
                            " refresh
                            "
    1              0.000001 function! s:Session.refresh() abort
                              let self.buffer = getbufline(self.bufnr, '^', '$')
                              let self.changedtick = getbufvar(self.bufnr, 'changedtick', 0)
                            endfunction
                            
                            "
                            " on_insert_leave.
                            "
    1              0.000001 function! s:Session.on_insert_leave() abort
                              call self.flush_changes()
                            endfunction
                            
                            "
                            " on_text_changed.
                            "
    1              0.000001 function! s:Session.on_text_changed() abort
                              if self.bufnr != bufnr('%')
                                return vsnip#deactivate()
                              endif
                            
                              let l:changenr = changenr()
                            
                              " save state.
                              if self.changenr != l:changenr
                                call self.store(self.changenr)
                                let self.changenr = l:changenr
                                if has_key(self.changenrs, l:changenr)
                                  let self.tabstop = self.changenrs[l:changenr].tabstop
                                  let self.snippet = self.changenrs[l:changenr].snippet
                                  let self.changenr = l:changenr
                                  let self.buffer = getbufline(self.bufnr, '^', '$')
                                  return
                                endif
                              endif
                            
                              if g:vsnip_sync_delay == 0
                                call self.flush_changes()
                              elseif g:vsnip_sync_delay > 0
                                call timer_stop(self.timer_id)
                                let self.timer_id = timer_start(g:vsnip_sync_delay, { -> self.flush_changes() }, { 'repeat': 1 })
                              endif
                            endfunction
                            
                            "
                            " flush_changes
                            "
    1              0.000001 function! s:Session.flush_changes() abort
                              let l:changedtick = getbufvar(self.bufnr, 'changedtick', 0)
                              if self.changedtick == l:changedtick
                                return
                              endif
                              let self.changedtick = l:changedtick
                            
                              " compute diff.
                              let l:buffer = getbufline(self.bufnr, '^', '$')
                              let l:diff = s:Diff.compute(self.buffer, l:buffer)
                              let self.buffer = l:buffer
                              if l:diff.rangeLength == 0 && l:diff.text ==# ''
                                return
                              endif
                            
                              " if follow succeeded, sync placeholders and write back to the buffer.
                              if self.snippet.follow(self.tabstop, l:diff)
                                try
                                  let l:text_edits = self.snippet.sync()
                                  if len(l:text_edits) > 0
                                    undojoin | call s:TextEdit.apply(self.bufnr, l:text_edits)
                                  endif
                                  call self.refresh()
                                catch /.*/
                                  " TODO: More strict changenrs mangement.
                                  call vsnip#deactivate()
                                endtry
                              else
                                call vsnip#deactivate()
                              endif
                            endfunction
                            
                            "
                            " save.
                            "
    1              0.000001 function! s:Session.store(changenr) abort
                              let self.changenrs[a:changenr] = {
                              \   'tabstop': self.tabstop,
                              \   'snippet': deepcopy(self.snippet)
                              \ }
                            endfunction
                            
    1              0.000029 inoremap <silent><expr> <Plug>(_vsnip-feedkeys-s) <SID>feedkeys_s()
    1              0.000010 inoremap <silent><expr> <Plug>(_vsnip-feedkeys-e) <SID>feedkeys_e()
    1              0.000022 nnoremap <silent><expr> <Plug>(_vsnip-feedkeys-s) <SID>feedkeys_s()
    1              0.000010 nnoremap <silent><expr> <Plug>(_vsnip-feedkeys-e) <SID>feedkeys_e()
    1              0.000009 xnoremap <silent><expr> <Plug>(_vsnip-feedkeys-s) <SID>feedkeys_s()
    1              0.000008 xnoremap <silent><expr> <Plug>(_vsnip-feedkeys-e) <SID>feedkeys_e()
    1              0.000009 snoremap <silent><expr> <Plug>(_vsnip-feedkeys-s) <SID>feedkeys_s()
    1              0.000008 snoremap <silent><expr> <Plug>(_vsnip-feedkeys-e) <SID>feedkeys_e()
    1              0.000002 function! s:feedkeys_s() abort
                              let s:selection = &selection
                              set selection=inclusive
                              return "\<Ignore>"
                            endfunction
    1              0.000002 function! s:feedkeys(keys, mode) abort
                              call feedkeys("\<Plug>(_vsnip-feedkeys-s)", '')
                              call feedkeys(a:keys, a:mode)
                              call feedkeys("\<Plug>(_vsnip-feedkeys-e)", '')
                            endfunction
    1              0.000001 function! s:feedkeys_e() abort
                              if exists('s:selection')
                                let &selection = s:selection
                                unlet s:selection
                              endif
                              return "\<Ignore>"
                            endfunction
                            

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vsnip/snippet.vim
Sourced 1 time
Total time:   0.001775
 Self time:   0.000543

count  total (s)   self (s)
    1              0.000009 let s:max_tabstop = 1000000
    1   0.001466   0.000234 let s:Position = vital#vsnip#import('VS.LSP.Position')
                            
                            "
                            " import.
                            "
    1              0.000002 function! vsnip#snippet#import() abort
                              return s:Snippet
                            endfunction
                            
    1              0.000002 let s:Snippet = {}
                            
                            "
                            " new.
                            "
    1              0.000002 function! s:Snippet.new(position, text) abort
                              let l:pos = s:Position.lsp_to_vim('%', a:position)
                              let l:snippet = extend(deepcopy(s:Snippet), {
                              \   'type': 'snippet',
                              \   'position': a:position,
                              \   'before_text': getline(l:pos[0])[0 : l:pos[1] - 2],
                              \   'children': vsnip#snippet#node#create_from_ast(
                              \     vsnip#snippet#parser#parse(a:text)
                              \   )
                              \ })
                              call l:snippet.init()
                              call l:snippet.sync()
                              return l:snippet
                            endfunction
                            
                            "
                            " init.
                            "
                            " NOTE: Must not use the node range in this method.
                            "
    1              0.000001 function! s:Snippet.init() abort
                              let l:fn = {}
                              let l:fn.self = self
                              let l:fn.group = {}
                              let l:fn.variable_placeholder = {}
                              let l:fn.has_final_tabstop = v:false
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder'
                                  " Mark as follower placeholder.
                                  if !has_key(self.group, a:context.node.id)
                                    let self.group[a:context.node.id] = a:context.node
                                  else
                                    let a:context.node.follower = v:true
                                  endif
                            
                                  " Mark as having final tabstop
                                  if a:context.node.is_final
                                    let self.has_final_tabstop = v:true
                                  endif
                                elseif a:context.node.type ==# 'variable'
                                  " TODO refactor
                                  " variable placeholder
                                  if a:context.node.unknown
                                    let a:context.node.type = 'placeholder'
                                    let a:context.node.choice = []
                            
                                    if !has_key(self.variable_placeholder, a:context.node.name)
                                      let self.variable_placeholder[a:context.node.name] = s:max_tabstop - (len(self.variable_placeholder) + 1)
                                      let a:context.node.id = self.variable_placeholder[a:context.node.name]
                                      let a:context.node.follower = v:false
                                      let a:context.node.children = empty(a:context.node.children) ? [vsnip#snippet#node#create_text(a:context.node.name)] : a:context.node.children
                                      let self.group[a:context.node.id] =  a:context.node
                                    else
                                      let a:context.node.id = self.variable_placeholder[a:context.node.name]
                                      let a:context.node.follower = v:true
                                      let a:context.node.children = [vsnip#snippet#node#create_text(self.group[a:context.node.id].text())]
                                    endif
                                  else
                                    let l:text = a:context.node.resolve(a:context)
                                    let l:text = l:text is# v:null ? a:context.text : l:text
                                    let l:index = index(a:context.parent.children, a:context.node)
                                    call remove(a:context.parent.children, l:index)
                                    call insert(a:context.parent.children, vsnip#snippet#node#create_text(l:text), l:index)
                                  endif
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              " Append ${MAX_TABSTOP} for the end of snippet.
                              if !l:fn.has_final_tabstop
                                let self.children += [vsnip#snippet#node#create_from_ast({
                                \   'type': 'placeholder',
                                \   'id': 0,
                                \   'choice': [],
                                \ })]
                              endif
                            endfunction
                            
                            "
                            " follow.
                            "
    1              0.000002 function! s:Snippet.follow(current_tabstop, diff) abort
                              let l:range = self.range()
                              let l:in_range = v:true
                              let l:in_range = l:in_range && (l:range.start.line < a:diff.range.start.line || l:range.start.line == a:diff.range.start.line && l:range.start.character <= a:diff.range.start.character)
                              let l:in_range = l:in_range && (a:diff.range.end.line < l:range.end.line || a:diff.range.end.line == l:range.end.line && a:diff.range.end.character <= l:range.end.character)
                              if !l:in_range
                                return v:false
                              endif
                            
                              let a:diff.range = [
                              \   self.position_to_offset(a:diff.range.start),
                              \   self.position_to_offset(a:diff.range.end),
                              \ ]
                            
                              let l:fn = {}
                              let l:fn.current_tabstop = a:current_tabstop
                              let l:fn.diff = a:diff
                              let l:fn.is_target_context_fixed = v:false
                              let l:fn.target_context = v:null
                              let l:fn.contexts = []
                              function! l:fn.traverse(context) abort
                                if self.diff.range[1] < a:context.range[0]
                                  return v:true
                                endif
                                if a:context.node.type !=# 'text'
                                  return
                                endif
                            
                                let l:included = v:false
                                let l:included = l:included || a:context.range[0] <= self.diff.range[0] && self.diff.range[0] < a:context.range[1] " right
                                let l:included = l:included || a:context.range[0] < self.diff.range[1] && self.diff.range[1] <= a:context.range[1] " left
                                let l:included = l:included || self.diff.range[0] <= a:context.range[0] && a:context.range[1] <= self.diff.range[1] " middle
                                if l:included
                                  if !self.is_target_context_fixed && (empty(self.target_context) && a:context.parent.type ==# 'placeholder' || get(a:context.parent, 'id', -1) == self.current_tabstop)
                                    let self.is_target_context_fixed = get(a:context.parent, 'id', -1) == self.current_tabstop
                                    let self.target_context = a:context
                                  endif
                                  call add(self.contexts, a:context)
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              if empty(l:fn.contexts)
                                return v:false
                              endif
                            
                              let l:fn.target_context = empty(l:fn.target_context) ? l:fn.contexts[-1] : l:fn.target_context
                            
                              let l:diff_text = a:diff.text
                              for l:context in l:fn.contexts
                                let l:diff_range = [max([a:diff.range[0], l:context.range[0]]), min([a:diff.range[1], l:context.range[1]])]
                                let l:start = l:diff_range[0] - l:context.range[0]
                                let l:end = l:diff_range[1] - l:context.range[0]
                            
                                " Create patched new text.
                                let l:new_text = strcharpart(l:context.text, 0, l:start)
                                if l:fn.target_context is# l:context
                                  let l:new_text .= l:diff_text
                                  let l:followed = v:true
                                endif
                                let l:new_text .= strcharpart(l:context.text, l:end, l:context.length - l:end)
                            
                                " Apply patched new text.
                                let l:context.node.value = l:new_text
                              endfor
                            
                              " Squash nodes when the edit was unexpected
                              let l:squashed = []
                              for l:context in l:fn.contexts
                                let l:squash_targets = l:context.parents + [l:context.node]
                                for l:i in range(len(l:squash_targets) - 1, 1, -1)
                                  let l:node = l:squash_targets[l:i]
                                  let l:parent = l:squash_targets[l:i - 1]
                            
                                  let l:should_squash = v:false
                                  let l:should_squash = l:should_squash || get(l:node, 'follower', v:false)
                                  let l:should_squash = l:should_squash || get(l:parent, 'id', v:null) is# a:current_tabstop
                                  let l:should_squash = l:should_squash || l:context isnot# l:fn.target_context && strlen(l:node.text()) == 0
                                  if l:should_squash && index(l:squashed, l:node) == -1
                                    let l:index = index(l:parent.children, l:node)
                                    call remove(l:parent.children, l:index)
                                    call insert(l:parent.children, vsnip#snippet#node#create_text(l:node.text()), l:index)
                                    call add(l:squashed, l:node)
                                  endif
                                endfor
                              endfor
                            
                              return v:true
                            endfunction
                            
                            "
                            " sync.
                            "
    1              0.000001 function! s:Snippet.sync() abort
                              let l:fn = {}
                              let l:fn.new_texts = {}
                              let l:fn.targets = []
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder'
                                  if !has_key(self.new_texts, a:context.node.id)
                                    let self.new_texts[a:context.node.id] = a:context.text
                                  else
                                    if self.new_texts[a:context.node.id] !=# a:context.text
                                      call add(self.targets, {
                                      \   'range': a:context.range,
                                      \   'node': a:context.node,
                                      \   'new_text': self.new_texts[a:context.node.id],
                                      \ })
                                    endif
                                  endif
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              " Create text_edits.
                              let l:text_edits = []
                              for l:target in l:fn.targets
                                call add(l:text_edits, {
                                \   'node': l:target.node,
                                \   'range': {
                                \     'start': self.offset_to_position(l:target.range[0]),
                                \     'end': self.offset_to_position(l:target.range[1]),
                                \   },
                                \   'newText': l:target.new_text
                                \ })
                              endfor
                            
                              " Sync placeholder text after created text_edits (the reason is to avoid using a modified range).
                              for l:text_edit in l:text_edits
                                let l:text_edit.node.children = [vsnip#snippet#node#create_text(l:text_edit.newText)]
                              endfor
                            
                              return l:text_edits
                            endfunction
                            
                            "
                            " range.
                            "
    1              0.000001 function! s:Snippet.range() abort
                              return {
                              \   'start': self.offset_to_position(0),
                              \   'end': self.offset_to_position(strchars(self.text()))
                              \ }
                            endfunction
                            
                            "
                            " text.
                            "
    1              0.000001 function! s:Snippet.text() abort
                              return join(map(copy(self.children), 'v:val.text()'), '')
                            endfunction
                            
                            "
                            " get_placeholder_nodes
                            "
    1              0.000001 function! s:Snippet.get_placeholder_nodes() abort
                              let l:fn =  {}
                              let l:fn.nodes = []
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder'
                                  call add(self.nodes, a:context.node)
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              return sort(l:fn.nodes, { a, b -> a.id - b.id })
                            endfunction
                            
                            "
                            " get_next_jump_point.
                            "
    1              0.000002 function! s:Snippet.get_next_jump_point(current_tabstop) abort
                              let l:fn = {}
                              let l:fn.current_tabstop = a:current_tabstop
                              let l:fn.context = v:null
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder' && self.current_tabstop < a:context.node.id
                                  if !empty(self.context) && self.context.node.id <= a:context.node.id
                                    return v:false
                                  endif
                            
                                  let self.context = copy(a:context)
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              let l:context = l:fn.context
                              if empty(l:context)
                                return {}
                              endif
                            
                              return {
                              \   'placeholder': l:context.node,
                              \   'range': {
                              \     'start': self.offset_to_position(l:context.range[0]),
                              \     'end': self.offset_to_position(l:context.range[1])
                              \   }
                              \ }
                            endfunction
                            
                            "
                            " get_prev_jump_point.
                            "
    1              0.000001 function! s:Snippet.get_prev_jump_point(current_tabstop) abort
                              let l:fn = {}
                              let l:fn.current_tabstop = a:current_tabstop
                              let l:fn.context = v:null
                              function! l:fn.traverse(context) abort
                                if a:context.node.type ==# 'placeholder' && self.current_tabstop > a:context.node.id
                                  if !empty(self.context) && self.context.node.id >= a:context.node.id
                                    return v:false
                                  endif
                                  let self.context = copy(a:context)
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              let l:context = l:fn.context
                              if empty(l:context)
                                return {}
                              endif
                            
                              return {
                              \   'placeholder': l:context.node,
                              \   'range': {
                              \     'start': self.offset_to_position(l:context.range[0]),
                              \     'end': self.offset_to_position(l:context.range[1])
                              \   }
                              \ }
                            endfunction
                            
                            "
                            " normalize
                            "
                            " - merge adjacent text-nodes
                            "
    1              0.000001 function! s:Snippet.normalize() abort
                              let l:fn = {}
                              let l:fn.prev_context = v:null
                              function! l:fn.traverse(context) abort
                                if !empty(self.prev_context)
                                  if self.prev_context.node.type ==# 'text' && a:context.node.type ==# 'text' && self.prev_context.parent is# a:context.parent
                                    let a:context.node.value = self.prev_context.node.value . a:context.node.value
                                    call remove(self.prev_context.parent.children, index(self.prev_context.parent.children, self.prev_context.node))
                                  endif
                                endif
                                let self.prev_context = copy(a:context)
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            endfunction
                            
                            "
                            " merge
                            "
    1              0.000002 function! s:Snippet.merge(tabstop, snippet) abort
                              " increase new snippet's tabstop by current snippet's current tabstop
                              let l:offset = 1
                              let l:tabstop_map = {}
                              for l:node in a:snippet.get_placeholder_nodes()
                                if !has_key(l:tabstop_map, l:node.id)
                                  let l:tabstop_map[l:node.id] = a:tabstop + l:offset
                                endif
                                let l:node.id = l:tabstop_map[l:node.id]
                                let l:offset += 1
                              endfor
                              if empty(l:tabstop_map)
                                return
                              endif
                            
                              let l:tail = l:node
                            
                              " re-assign current snippet's tabstop by new snippet's final tabstop
                              let l:offset = 1
                              let l:tabstop_map = {}
                              for l:node in self.get_placeholder_nodes()
                                if l:node.id > a:tabstop
                                  if !has_key(l:tabstop_map, l:node.id)
                                    let l:tabstop_map[l:node.id] = l:tail.id + l:offset
                                  endif
                                  let l:node.id = l:tabstop_map[l:node.id]
                                  let l:offset += 1
                                endif
                              endfor
                            endfunction
                            
                            "
                            " insert
                            "
    1              0.000002 function! s:Snippet.insert(position, nodes_to_insert) abort
                              let l:offset = self.position_to_offset(a:position)
                            
                              " Search target node for inserting nodes.
                              let l:fn = {}
                              let l:fn.offset = l:offset
                              let l:fn.context = v:null
                              function! l:fn.traverse(context) abort
                                if a:context.range[0] <= self.offset && self.offset <= a:context.range[1] && a:context.node.type ==# 'text'
                                  " prefer more deeper node.
                                  if empty(self.context) || self.context.depth <= a:context.depth
                                    let self.context = copy(a:context)
                                  endif
                                endif
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                            
                              " This condition is unexpected normally
                              let l:context = l:fn.context
                              if empty(l:context)
                                return
                              endif
                            
                              " Remove target text node
                              let l:index = index(l:context.parent.children, l:context.node)
                              call remove(l:context.parent.children, l:index)
                            
                              " Should insert into existing text node when position is middle of node
                              let l:nodes_to_insert = reverse(a:nodes_to_insert)
                              if l:context.node.value !=# ''
                                let l:off = l:offset - l:context.range[0]
                                let l:before = vsnip#snippet#node#create_text(strcharpart(l:context.node.value, 0, l:off))
                                let l:after = vsnip#snippet#node#create_text(strcharpart(l:context.node.value, l:off, strchars(l:context.node.value) - l:off))
                                let l:nodes_to_insert = [l:after] + l:nodes_to_insert + [l:before]
                              endif
                            
                              " Insert nodes.
                              for l:node in l:nodes_to_insert
                                call insert(l:context.parent.children, l:node, l:index)
                              endfor
                            
                              call self.normalize()
                            endfunction
                            
                            "
                            " offset_to_position.
                            "
                            " @param offset 0-based index for snippet text.
                            " @return position buffer position
                            "
    1              0.000002 function! s:Snippet.offset_to_position(offset) abort
                              let l:lines = split(strcharpart(self.text(), 0, a:offset), "\n", v:true)
                              return {
                              \   'line': self.position.line + len(l:lines) - 1,
                              \   'character': strchars(l:lines[-1]) + (len(l:lines) == 1 ? self.position.character : 0),
                              \ }
                            endfunction
                            
                            "
                            " position_to_offset.
                            "
                            " @param position buffer position
                            " @return 0-based index for snippet text.
                            "
    1              0.000002 function! s:Snippet.position_to_offset(position) abort
                              let l:line = a:position.line - self.position.line
                              let l:char = a:position.character - (l:line == 0 ? self.position.character : 0)
                              let l:lines = split(self.text(), "\n", v:true)[0 : l:line]
                              let l:lines[-1] = strcharpart(l:lines[-1], 0, l:char)
                              return strchars(join(l:lines, "\n"))
                            endfunction
                            
                            "
                            " traverse.
                            "
    1              0.000002 function! s:Snippet.traverse(node, callback) abort
                              let l:state = {
                              \   'offset': 0,
                              \   'before_text': self.before_text,
                              \ }
                              let l:context = {
                              \   'depth': 0,
                              \   'parent': v:null,
                              \   'parents': [],
                              \ }
                              call s:traverse(a:node, a:callback, l:state, l:context)
                            endfunction
    1              0.000003 function! s:traverse(node, callback, state, context) abort
                              let l:text = ''
                              let l:length = 0
                              if a:node.type !=# 'snippet'
                                let l:text = a:node.text()
                                let l:length = strchars(l:text)
                                if a:callback({
                                \   'node': a:node,
                                \   'text': l:text,
                                \   'length': l:length,
                                \   'parent': a:context.parent,
                                \   'parents': a:context.parents,
                                \   'depth': a:context.depth,
                                \   'offset': a:state.offset,
                                \   'before_text': a:state.before_text,
                                \   'range': [a:state.offset, a:state.offset + l:length],
                                \ })
                                  return v:true
                                endif
                              endif
                            
                              if len(a:node.children) > 0
                                let l:next_context = {
                                  \   'parent': a:node,
                                  \   'parents': a:context.parents + [a:node],
                                  \   'depth': len(a:context.parents) + 1,
                                  \ }
                                for l:child in copy(a:node.children)
                                  if s:traverse(l:child, a:callback, a:state, l:next_context)
                                    return v:true
                                  endif
                                endfor
                              else
                                let a:state.before_text .= l:text
                                let a:state.offset += l:length
                              endif
                            endfunction
                            
                            "
                            " debug
                            "
    1              0.000001 function! s:Snippet.debug() abort
                              echomsg 'snippet.text()'
                              for l:line in split(self.text(), "\n", v:true)
                                echomsg string(l:line)
                              endfor
                              echomsg '-----'
                            
                              let l:fn = {}
                              function! l:fn.traverse(context) abort
                                echomsg repeat('    ', a:context.depth - 1) . a:context.node.to_string()
                              endfunction
                              call self.traverse(self, l:fn.traverse)
                              echomsg ' '
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vital/vsnip.vim
Sourced 1 time
Total time:   0.000358
 Self time:   0.000358

count  total (s)   self (s)
    1              0.000010 let s:plugin_name = expand('<sfile>:t:r')
    1              0.000004 let s:vital_base_dir = expand('<sfile>:h')
    1              0.000003 let s:project_root = expand('<sfile>:h:h:h')
    1              0.000003 let s:is_vital_vim = s:plugin_name is# 'vital'
                            
    1              0.000002 let s:loaded = {}
    1              0.000001 let s:cache_sid = {}
                            
    1              0.000006 function! vital#{s:plugin_name}#new() abort
                              return s:new(s:plugin_name)
                            endfunction
                            
    1              0.000003 function! vital#{s:plugin_name}#import(...) abort
                              if !exists('s:V')
                                let s:V = s:new(s:plugin_name)
                              endif
                              return call(s:V.import, a:000, s:V)
                            endfunction
                            
    1              0.000002 let s:Vital = {}
                            
    1              0.000004 function! s:new(plugin_name) abort
                              let base = deepcopy(s:Vital)
                              let base._plugin_name = a:plugin_name
                              return base
                            endfunction
                            
    1              0.000001 function! s:vital_files() abort
                              if !exists('s:vital_files')
                                let s:vital_files = map(
                                \   s:is_vital_vim ? s:_global_vital_files() : s:_self_vital_files(),
                                \   'fnamemodify(v:val, ":p:gs?[\\\\/]?/?")')
                              endif
                              return copy(s:vital_files)
                            endfunction
    1              0.000008 let s:Vital.vital_files = function('s:vital_files')
                            
    1              0.000002 function! s:import(name, ...) abort dict
                              let target = {}
                              let functions = []
                              for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
                              let module = self._import(a:name)
                              if empty(functions)
                                call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
                              return target
                            endfunction
    1              0.000004 let s:Vital.import = function('s:import')
                            
    1              0.000001 function! s:load(...) abort dict
                              for arg in a:000
                                let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
                                let target = split(join(as, ''), '\W\+')
                                let dict = self
                                let dict_type = type({})
                                while !empty(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == dict_type
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                                if exists('dict')
                                  call extend(dict, self._import(name))
                                endif
                                unlet arg
                              endfor
                              return self
                            endfunction
    1              0.000003 let s:Vital.load = function('s:load')
                            
    1              0.000001 function! s:unload() abort dict
                              let s:loaded = {}
                              let s:cache_sid = {}
                              unlet! s:vital_files
                            endfunction
    1              0.000003 let s:Vital.unload = function('s:unload')
                            
    1              0.000001 function! s:exists(name) abort dict
                              if a:name !~# '\v^\u\w*%(\.\u\w*)*$'
                                throw 'vital: Invalid module name: ' . a:name
                              endif
                              return s:_module_path(a:name) isnot# ''
                            endfunction
    1              0.000003 let s:Vital.exists = function('s:exists')
                            
    1              0.000001 function! s:search(pattern) abort dict
                              let paths = s:_extract_files(a:pattern, self.vital_files())
                              let modules = sort(map(paths, 's:_file2module(v:val)'))
                              return uniq(modules)
                            endfunction
    1              0.000003 let s:Vital.search = function('s:search')
                            
    1              0.000001 function! s:plugin_name() abort dict
                              return self._plugin_name
                            endfunction
    1              0.000003 let s:Vital.plugin_name = function('s:plugin_name')
                            
    1              0.000002 function! s:_self_vital_files() abort
                              let builtin = printf('%s/__%s__/', s:vital_base_dir, s:plugin_name)
                              let installed = printf('%s/_%s/', s:vital_base_dir, s:plugin_name)
                              let base = builtin . ',' . installed
                              return split(globpath(base, '**/*.vim', 1), "\n")
                            endfunction
                            
    1              0.000001 function! s:_global_vital_files() abort
                              let pattern = 'autoload/vital/__*__/**/*.vim'
                              return split(globpath(&runtimepath, pattern, 1), "\n")
                            endfunction
                            
    1              0.000002 function! s:_extract_files(pattern, files) abort
                              let tr = {'.': '/', '*': '[^/]*', '**': '.*'}
                              let target = substitute(a:pattern, '\.\|\*\*\?', '\=tr[submatch(0)]', 'g')
                              let regexp = printf('autoload/vital/[^/]\+/%s.vim$', target)
                              return filter(a:files, 'v:val =~# regexp')
                            endfunction
                            
    1              0.000002 function! s:_file2module(file) abort
                              let filename = fnamemodify(a:file, ':p:gs?[\\/]?/?')
                              let tail = matchstr(filename, 'autoload/vital/_\w\+/\zs.*\ze\.vim$')
                              return join(split(tail, '[\\/]\+'), '.')
                            endfunction
                            
                            " @param {string} name e.g. Data.List
    1              0.000001 function! s:_import(name) abort dict
                              if has_key(s:loaded, a:name)
                                return copy(s:loaded[a:name])
                              endif
                              let module = self._get_module(a:name)
                              if has_key(module, '_vital_created')
                                call module._vital_created(module)
                              endif
                              let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module._vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
                              let s:loaded[a:name] = export_module
                              if has_key(module, '_vital_loaded')
                                try
                                  call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception . " from:\n" . s:_format_throwpoint(v:throwpoint)
                                endtry
                              endif
                              return copy(s:loaded[a:name])
                            endfunction
    1              0.000006 let s:Vital._import = function('s:_import')
                            
    1              0.000003 function! s:_format_throwpoint(throwpoint) abort
                              let funcs = []
                              let stack = matchstr(a:throwpoint, '^function \zs.*, .\{-} \d\+$')
                              for line in split(stack, '\.\.')
                                let m = matchlist(line, '^\(.\+\)\%(\[\(\d\+\)\]\|, .\{-} \(\d\+\)\)$')
                                if !empty(m)
                                  let [name, lnum, lnum2] = m[1:3]
                                  if empty(lnum)
                                    let lnum = lnum2
                                  endif
                                  let info = s:_get_func_info(name)
                                  if !empty(info)
                                    let attrs = empty(info.attrs) ? '' : join([''] + info.attrs)
                                    let flnum = info.lnum == 0 ? '' : printf(' Line:%d', info.lnum + lnum)
                                    call add(funcs, printf('function %s(...)%s Line:%d (%s%s)',
                                    \        info.funcname, attrs, lnum, info.filename, flnum))
                                    continue
                                  endif
                                endif
                                " fallback when function information cannot be detected
                                call add(funcs, line)
                              endfor
                              return join(funcs, "\n")
                            endfunction
                            
    1              0.000002 function! s:_get_func_info(name) abort
                              let name = a:name
                              if a:name =~# '^\d\+$'  " is anonymous-function
                                let name = printf('{%s}', a:name)
                              elseif a:name =~# '^<lambda>\d\+$'  " is lambda-function
                                let name = printf("{'%s'}", a:name)
                              endif
                              if !exists('*' . name)
                                return {}
                              endif
                              let body = execute(printf('verbose function %s', name))
                              let lines = split(body, "\n")
                              let signature = matchstr(lines[0], '^\s*\zs.*')
                              let [_, file, lnum; __] = matchlist(lines[1],
                              \   '^\t\%(Last set from\|.\{-}:\)\s*\zs\(.\{-}\)\%( \S\+ \(\d\+\)\)\?$')
                              return {
                              \   'filename': substitute(file, '[/\\]\+', '/', 'g'),
                              \   'lnum': 0 + lnum,
                              \   'funcname': a:name,
                              \   'arguments': split(matchstr(signature, '(\zs.*\ze)'), '\s*,\s*'),
                              \   'attrs': filter(['dict', 'abort', 'range', 'closure'], 'signature =~# (").*" . v:val)'),
                              \ }
                            endfunction
                            
                            " s:_get_module() returns module object wihch has all script local functions.
    1              0.000002 function! s:_get_module(name) abort dict
                              let funcname = s:_import_func_name(self.plugin_name(), a:name)
                              try
                                return call(funcname, [])
                              catch /^Vim\%((\a\+)\)\?:E117:/
                                return s:_get_builtin_module(a:name)
                              endtry
                            endfunction
                            
    1              0.000002 function! s:_get_builtin_module(name) abort
                             return s:sid2sfuncs(s:_module_sid(a:name))
                            endfunction
                            
    1              0.000002 if s:is_vital_vim
                              " For vital.vim, we can use s:_get_builtin_module directly
                              let s:Vital._get_module = function('s:_get_builtin_module')
    1              0.000001 else
    1              0.000004   let s:Vital._get_module = function('s:_get_module')
    1              0.000001 endif
                            
    1              0.000002 function! s:_import_func_name(plugin_name, module_name) abort
                              return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))
                            endfunction
                            
    1              0.000001 function! s:_module_sid(name) abort
                              let path = s:_module_path(a:name)
                              if !filereadable(path)
                                throw 'vital: module not found: ' . a:name
                              endif
                              let vital_dir = s:is_vital_vim ? '__\w\+__' : printf('_\{1,2}%s\%%(__\)\?', s:plugin_name)
                              let base = join([vital_dir, ''], '[/\\]\+')
                              let p = base . substitute('' . a:name, '\.', '[/\\\\]\\+', 'g')
                              let sid = s:_sid(path, p)
                              if !sid
                                call s:_source(path)
                                let sid = s:_sid(path, p)
                                if !sid
                                  throw printf('vital: cannot get <SID> from path: %s', path)
                                endif
                              endif
                              return sid
                            endfunction
                            
    1              0.000001 function! s:_module_path(name) abort
                              return get(s:_extract_files(a:name, s:vital_files()), 0, '')
                            endfunction
                            
    1              0.000001 function! s:_module_sid_base_dir() abort
                              return s:is_vital_vim ? &rtp : s:project_root
                            endfunction
                            
    1              0.000001 function! s:_dot_to_sharp(name) abort
                              return substitute(a:name, '\.', '#', 'g')
                            endfunction
                            
    1              0.000001 function! s:_source(path) abort
                              execute 'source' fnameescape(a:path)
                            endfunction
                            
                            " @vimlint(EVL102, 1, l:_)
                            " @vimlint(EVL102, 1, l:__)
    1              0.000002 function! s:_sid(path, filter_pattern) abort
                              let unified_path = s:_unify_path(a:path)
                              if has_key(s:cache_sid, unified_path)
                                return s:cache_sid[unified_path]
                              endif
                              for line in filter(split(execute(':scriptnames'), "\n"), 'v:val =~# a:filter_pattern')
                                let [_, sid, path; __] = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
                                if s:_unify_path(path) is# unified_path
                                  let s:cache_sid[unified_path] = sid
                                  return s:cache_sid[unified_path]
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000015 if filereadable(expand('<sfile>:r') . '.VIM') " is case-insensitive or not
                              let s:_unify_path_cache = {}
                              " resolve() is slow, so we cache results.
                              " Note: On windows, vim can't expand path names from 8.3 formats.
                              " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                              " vital load duplicated scripts. Below's :~ avoid this issue.
                              function! s:_unify_path(path) abort
                                if has_key(s:_unify_path_cache, a:path)
                                  return s:_unify_path_cache[a:path]
                                endif
                                let value = tolower(fnamemodify(resolve(fnamemodify(
                                \                   a:path, ':p')), ':~:gs?[\\/]?/?'))
                                let s:_unify_path_cache[a:path] = value
                                return value
                              endfunction
    1              0.000001 else
    1              0.000002   function! s:_unify_path(path) abort
                                return resolve(fnamemodify(a:path, ':p:gs?[\\/]?/?'))
                              endfunction
    1              0.000001 endif
                            
                            " copied and modified from Vim.ScriptLocal
    1              0.000031 let s:SNR = join(map(range(len("\<SNR>")), '"[\\x" . printf("%0x", char2nr("\<SNR>"[v:val])) . "]"'), '')
    1              0.000002 function! s:sid2sfuncs(sid) abort
                              let fs = split(execute(printf(':function /^%s%s_', s:SNR, a:sid)), "\n")
                              let r = {}
                              let pattern = printf('\m^function\s<SNR>%d_\zs\w\{-}\ze(', a:sid)
                              for fname in map(fs, 'matchstr(v:val, pattern)')
                                let r[fname] = function(s:_sfuncname(a:sid, fname))
                              endfor
                              return r
                            endfunction
                            
                            "" Return funcname of script local functions with SID
    1              0.000002 function! s:_sfuncname(sid, funcname) abort
                              return printf('<SNR>%s_%s', a:sid, a:funcname)
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Position.vim
Sourced 1 time
Total time:   0.000096
 Self time:   0.000077

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000003 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000039   0.000021 execute join(['function! vital#_vsnip#VS#LSP#Position#import() abort', printf("return map({'cursor': '', 'vim_to_lsp': '', 'lsp_to_vim': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000003 delfunction s:_SID
                            " ___vital___
                            "
                            " cursor
                            "
    1              0.000001 function! s:cursor() abort
                              return s:vim_to_lsp('%', getpos('.')[1 : 3])
                            endfunction
                            
                            "
                            " vim_to_lsp
                            "
    1              0.000002 function! s:vim_to_lsp(expr, pos) abort
                              let l:line = s:_get_buffer_line(a:expr, a:pos[0])
                              if l:line is v:null
                                return {
                                \   'line': a:pos[0] - 1,
                                \   'character': a:pos[1] - 1
                                \ }
                              endif
                            
                              return {
                              \   'line': a:pos[0] - 1,
                              \   'character': strchars(strpart(l:line, 0, a:pos[1] - 1))
                              \ }
                            endfunction
                            
                            "
                            " lsp_to_vim
                            "
    1              0.000002 function! s:lsp_to_vim(expr, position) abort
                              let l:line = s:_get_buffer_line(a:expr, a:position.line + 1)
                              if l:line is v:null
                                return [a:position.line + 1, a:position.character + 1]
                              endif
                              return [a:position.line + 1, byteidx(l:line, a:position.character) + 1]
                            endfunction
                            
                            "
                            " _get_buffer_line
                            "
    1              0.000003 if exists('*bufload')
    1              0.000002   function! s:_get_buffer_line(expr, lnum) abort
                                if bufloaded(bufnr(a:expr))
                                  return get(getbufline(a:expr, a:lnum), 0, v:null)
                                elseif filereadable(a:expr)
                                  call bufload(bufnr(a:expr, v:true))
                                  return get(getbufline(a:expr, a:lnum), 0, v:null)
                                endif
                                return v:null
                              endfunction
                            else
                              function! s:_get_buffer_line(expr, lnum) abort
                                if bufloaded(bufnr(a:expr))
                                  return get(getbufline(a:expr, a:lnum), 0, v:null)
                                elseif filereadable(a:expr)
                                  return get(readfile(a:expr, '', a:lnum), 0, v:null)
                                endif
                                return v:null
                              endfunction
    1              0.000001 endif
                            

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip.vim
Sourced 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000007 let s:_plugin_name = expand('<sfile>:t:r')
                            
    1              0.000004 function! vital#{s:_plugin_name}#new() abort
                              return vital#{s:_plugin_name[1:]}#new()
                            endfunction
                            
    1              0.000003 function! vital#{s:_plugin_name}#function(funcname) abort
                              silent! return function(a:funcname)
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/TextEdit.vim
Sourced 1 time
Total time:   0.000156
 Self time:   0.000141

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000003 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000037   0.000021 execute join(['function! vital#_vsnip#VS#LSP#TextEdit#import() abort', printf("return map({'_vital_depends': '', 'apply': '', '_vital_loaded': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000002 delfunction s:_SID
                            " ___vital___
                            "
                            " _vital_loaded
                            "
    1              0.000002 function! s:_vital_loaded(V) abort
                              let s:Text = a:V.import('VS.LSP.Text')
                              let s:Position = a:V.import('VS.LSP.Position')
                              let s:Buffer = a:V.import('VS.Vim.Buffer')
                              let s:Option = a:V.import('VS.Vim.Option')
                            endfunction
                            
                            "
                            " _vital_depends
                            "
    1              0.000001 function! s:_vital_depends() abort
                              return ['VS.LSP.Text', 'VS.LSP.Position', 'VS.Vim.Buffer', 'VS.Vim.Option']
                            endfunction
                            
                            "
                            " apply
                            "
    1              0.000002 function! s:apply(path, text_edits) abort
                              let l:current_bufname = bufname('%')
                              let l:current_position = s:Position.cursor()
                            
                              let l:target_bufnr = s:_switch(a:path)
                              call s:_substitute(l:target_bufnr, a:text_edits, l:current_position)
                              let l:current_bufnr = s:_switch(l:current_bufname)
                            
                              if l:current_bufnr == l:target_bufnr
                                call cursor(s:Position.lsp_to_vim('%', l:current_position))
                              endif
                            endfunction
                            
                            "
                            " _substitute
                            "
    1              0.000002 function! s:_substitute(bufnr, text_edits, current_position) abort
                              try
                                " Save state.
                                let l:Restore = s:Option.define({
                                \   'foldenable': '0',
                                \ })
                                let l:view = winsaveview()
                            
                                " Apply substitute.
                                let [l:fixeol, l:text_edits] = s:_normalize(a:bufnr, a:text_edits)
                                for l:text_edit in l:text_edits
                                  let l:start = s:Position.lsp_to_vim(a:bufnr, l:text_edit.range.start)
                                  let l:end = s:Position.lsp_to_vim(a:bufnr, l:text_edit.range.end)
                                  let l:text = s:Text.normalize_eol(l:text_edit.newText)
                                  execute printf('noautocmd keeppatterns keepjumps silent %ssubstitute/\%%%sl\%%%sc\_.\{-}\%%%sl\%%%sc/\=l:text/%se',
                                  \   l:start[0],
                                  \   l:start[0],
                                  \   l:start[1],
                                  \   l:end[0],
                                  \   l:end[1],
                                  \   &gdefault ? 'g' : ''
                                  \ )
                                  call s:_fix_cursor_position(a:current_position, l:text_edit, s:Text.split_by_eol(l:text))
                                endfor
                            
                                " Remove last empty line if fixeol enabled.
                                if l:fixeol && getline('$') ==# ''
                                  noautocmd keeppatterns keepjumps silent $delete _
                                endif
                              catch /.*/
                                echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                              finally
                                " Restore state.
                                call l:Restore()
                                call winrestview(l:view)
                              endtry
                            endfunction
                            
                            "
                            " _fix_cursor_position
                            "
    1              0.000002 function! s:_fix_cursor_position(position, text_edit, lines) abort
                              let l:lines_len = len(a:lines)
                              let l:range_len = (a:text_edit.range.end.line - a:text_edit.range.start.line) + 1
                            
                              if a:text_edit.range.end.line < a:position.line
                                let a:position.line += l:lines_len - l:range_len
                              elseif a:text_edit.range.end.line == a:position.line && a:text_edit.range.end.character <= a:position.character
                                let a:position.line += l:lines_len - l:range_len
                                let a:position.character = strchars(a:lines[-1]) + (a:position.character - a:text_edit.range.end.character)
                                if l:lines_len == 1
                                  let a:position.character += a:text_edit.range.start.character
                                endif
                              endif
                            endfunction
                            
                            "
                            " _normalize
                            "
    1              0.000002 function! s:_normalize(bufnr, text_edits) abort
                              let l:text_edits = type(a:text_edits) == type([]) ? a:text_edits : [a:text_edits]
                              let l:text_edits = s:_range(l:text_edits)
                              let l:text_edits = sort(l:text_edits, function('s:_compare'))
                              let l:text_edits = reverse(l:text_edits)
                              return s:_fix_text_edits(a:bufnr, l:text_edits)
                            endfunction
                            
                            "
                            " _range
                            "
    1              0.000001 function! s:_range(text_edits) abort
                              let l:text_edits = []
                              for l:text_edit in a:text_edits
                                if type(l:text_edit) != type({})
                                  continue
                                endif
                                if l:text_edit.range.start.line > l:text_edit.range.end.line || (
                                \   l:text_edit.range.start.line == l:text_edit.range.end.line &&
                                \   l:text_edit.range.start.character > l:text_edit.range.end.character
                                \ )
                                  let l:text_edit.range = { 'start': l:text_edit.range.end, 'end': l:text_edit.range.start }
                                endif
                                let l:text_edits += [l:text_edit]
                              endfor
                              return l:text_edits
                            endfunction
                            
                            "
                            " _compare
                            "
    1              0.000002 function! s:_compare(text_edit1, text_edit2) abort
                              let l:diff = a:text_edit1.range.start.line - a:text_edit2.range.start.line
                              if l:diff == 0
                                return a:text_edit1.range.start.character - a:text_edit2.range.start.character
                              endif
                              return l:diff
                            endfunction
                            
                            "
                            " _fix_text_edits
                            "
    1              0.000002 function! s:_fix_text_edits(bufnr, text_edits) abort
                              let l:max = s:Buffer.get_line_count(a:bufnr)
                            
                              let l:fixeol = v:false
                              let l:text_edits = []
                              for l:text_edit in a:text_edits
                                if l:max <= l:text_edit.range.start.line
                                  let l:text_edit.range.start.line = l:max - 1
                                  let l:text_edit.range.start.character = strchars(get(getbufline(a:bufnr, '$'), 0, ''))
                                  let l:text_edit.newText = "\n" . l:text_edit.newText
                                  let l:fixeol = &fixendofline && !&binary
                                endif
                                if l:max <= l:text_edit.range.end.line
                                  let l:text_edit.range.end.line = l:max - 1
                                  let l:text_edit.range.end.character = strchars(get(getbufline(a:bufnr, '$'), 0, ''))
                                  let l:fixeol = &fixendofline && !&binary
                                endif
                                call add(l:text_edits, l:text_edit)
                              endfor
                            
                              return [l:fixeol, l:text_edits]
                            endfunction
                            
                            "
                            " _switch
                            "
    1              0.000001 function! s:_switch(path) abort
                              let l:curr = bufnr('%')
                              let l:next = bufnr(a:path)
                              if l:next >= 0
                                if l:curr != l:next
                                  execute printf('noautocmd keepalt keepjumps %sbuffer!', bufnr(a:path))
                                endif
                              else
                                execute printf('noautocmd keepalt keepjumps edit! %s', fnameescape(a:path))
                              endif
                              return bufnr('%')
                            endfunction
                            

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Text.vim
Sourced 1 time
Total time:   0.000059
 Self time:   0.000045

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000003 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000033   0.000019 execute join(['function! vital#_vsnip#VS#LSP#Text#import() abort', printf("return map({'normalize_eol': '', 'split_by_eol': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000002 delfunction s:_SID
                            " ___vital___
                            "
                            " normalize_eol
                            "
    1              0.000002 function! s:normalize_eol(text) abort
                              return substitute(a:text, "\r\n\\|\r", "\n", 'g')
                            endfunction
                            
                            "
                            " split_by_eol
                            "
    1              0.000001 function! s:split_by_eol(text) abort
                              return split(a:text, "\r\n\\|\r\\|\n", v:true)
                            endfunction
                            

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/Vim/Buffer.vim
Sourced 1 time
Total time:   0.000115
 Self time:   0.000102

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000003 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000032   0.000019 execute join(['function! vital#_vsnip#VS#Vim#Buffer#import() abort', printf("return map({'get_line_count': '', 'do': '', 'create': '', 'load': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000002 delfunction s:_SID
                            " ___vital___
    1              0.000004 let s:Do = { -> {} }
                            
    1              0.000006 let g:___VS_Vim_Buffer_id = get(g:, '___VS_Vim_Buffer_id', 0)
                            
                            "
                            " get_line_count
                            "
    1              0.000004 if exists('*nvim_buf_line_count')
    1              0.000002   function! s:get_line_count(bufnr) abort
                                return nvim_buf_line_count(a:bufnr)
                              endfunction
                            elseif has('patch-8.2.0019')
                              function! s:get_line_count(bufnr) abort
                                return getbufinfo(a:bufnr)[0].linecount
                              endfunction
                            else
                              function! s:get_line_count(bufnr) abort
                                if bufnr('%') == bufnr(a:bufnr)
                                  return line('$')
                                endif
                                return len(getbufline(a:bufnr, '^', '$'))
                              endfunction
    1              0.000001 endif
                            
                            "
                            " create
                            "
    1              0.000001 function! s:create(...) abort
                              let g:___VS_Vim_Buffer_id += 1
                              let l:bufnr = bufnr(printf('VS.Vim.Buffer: %s: %s',
                              \   g:___VS_Vim_Buffer_id,
                              \   get(a:000, 0, 'VS.Vim.Buffer.Default')
                              \ ), v:true)
                              call s:load(l:bufnr)
                              return l:bufnr
                            endfunction
                            
                            "
                            " load
                            "
    1              0.000002 if exists('*bufload')
    1              0.000001   function! s:load(bufnr_or_path) abort
                                let l:bufnr = bufnr(a:bufnr_or_path, v:true)
                                silent call bufload(l:bufnr)
                                return l:bufnr
                              endfunction
                            else
                              function! s:load(bufnr_or_path) abort
                                let l:curr_bufnr = bufnr('%')
                            
                                try
                                  let l:bufnr = bufnr(a:bufnr_or_path, v:true)
                                  execute printf('keepalt keepjumps silent %sbuffer', l:bufnr)
                                catch /.*/
                                  echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                                finally
                                  execute printf('noautocmd keepalt keepjumps silent %sbuffer', l:curr_bufnr)
                                endtry
                                return l:bufnr
                              endfunction
    1              0.000001 endif
                            
                            "
                            " do
                            "
    1              0.000002 function! s:do(bufnr, func) abort
                              let l:curr_bufnr = bufnr('%')
                              if l:curr_bufnr == a:bufnr
                                call a:func()
                                return
                              endif
                            
                              try
                                execute printf('noautocmd keepalt keepjumps silent %sbuffer', a:bufnr)
                                call a:func()
                              catch /.*/
                                echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                              finally
                                execute printf('noautocmd keepalt keepjumps silent %sbuffer', l:curr_bufnr)
                              endtry
                            endfunction
                            

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/Vim/Option.vim
Sourced 1 time
Total time:   0.000060
 Self time:   0.000043

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000003 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000037   0.000020 execute join(['function! vital#_vsnip#VS#Vim#Option#import() abort', printf("return map({'define': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000002 delfunction s:_SID
                            " ___vital___
                            "
                            " define
                            "
    1              0.000001 function! s:define(map) abort
                              let l:old = {}
                              for [l:key, l:value] in items(a:map)
                                let l:old[l:key] = eval(printf('&%s', l:key))
                                execute printf('let &%s = "%s"', l:key, l:value)
                              endfor
                              return { -> s:define(l:old) }
                            endfunction
                            

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Diff.vim
Sourced 1 time
Total time:   0.000175
 Self time:   0.000119

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000003 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000030   0.000019 execute join(['function! vital#_vsnip#VS#LSP#Diff#import() abort', printf("return map({'try_enable_lua': '', 'compute': ''}, \"vital#_vsnip#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000002 delfunction s:_SID
                            " ___vital___
                            "
                            " compute
                            "
    1              0.000002 function! s:compute(old, new) abort
                              let l:old = a:old
                              let l:new = a:new
                            
                              let l:old_len = len(l:old)
                              let l:new_len = len(l:new)
                              let l:min_len = min([l:old_len, l:new_len])
                            
                              " empty -> empty
                              if l:old_len == 0 && l:new_len == 0
                                return {
                                \   'range': {
                                \     'start': {
                                \       'line': 0,
                                \       'character': 0,
                                \     },
                                \     'end': {
                                \       'line': 0,
                                \       'character': 0,
                                \     }
                                \   },
                                \   'text': '',
                                \   'rangeLength': 0
                                \ }
                              " not empty -> empty
                              elseif l:old_len != 0 && l:new_len == 0
                                return {
                                \   'range': {
                                \     'start': {
                                \       'line': 0,
                                \       'character': 0,
                                \     },
                                \     'end': {
                                \       'line': l:old_len - 1,
                                \       'character': strchars(l:old[-1]),
                                \     }
                                \   },
                                \   'text': '',
                                \   'rangeLength': strchars(join(l:old, "\n"))
                                \ }
                              " empty -> not empty
                              elseif l:old_len == 0 && l:new_len != 0
                                return {
                                \   'range': {
                                \     'start': {
                                \       'line': 0,
                                \       'character': 0,
                                \     },
                                \     'end': {
                                \       'line': 0,
                                \       'character': 0,
                                \     }
                                \   },
                                \   'text': join(l:new, "\n"),
                                \   'rangeLength': 0
                                \ }
                              endif
                            
                              if s:is_lua_enabled
                                let [l:first_line, l:last_line] = luaeval('vital_vs_lsp_diff_search_line_region(_A[1], _A[2])', [l:old, l:new])
                              else
                                let l:first_line = 0
                                while l:first_line < l:min_len - 1
                                  if l:old[l:first_line] !=# l:new[l:first_line]
                                    break
                                  endif
                                  let l:first_line += 1
                                endwhile
                            
                                let l:last_line = -1
                                while l:last_line > -l:min_len + l:first_line
                                  if l:old[l:last_line] !=# l:new[l:last_line]
                                    break
                                  endif
                                  let l:last_line -= 1
                                endwhile
                              endif
                            
                              let l:old_lines = l:old[l:first_line : l:last_line]
                              let l:new_lines = l:new[l:first_line : l:last_line]
                              let l:old_text = join(l:old_lines, "\n") . "\n"
                              let l:new_text = join(l:new_lines, "\n") . "\n"
                              let l:old_text_len = strchars(l:old_text)
                              let l:new_text_len = strchars(l:new_text)
                              let l:min_text_len = min([l:old_text_len, l:new_text_len])
                            
                              let l:first_char = 0
                              for l:first_char in range(0, l:min_text_len - 1)
                                if strgetchar(l:old_text, l:first_char) != strgetchar(l:new_text, l:first_char)
                                  break
                                endif
                              endfor
                            
                              let l:last_char = 0
                              for l:last_char in range(0, -l:min_text_len + l:first_char, -1)
                                if strgetchar(l:old_text, l:old_text_len + l:last_char - 1) != strgetchar(l:new_text, l:new_text_len + l:last_char - 1)
                                  break
                                endif
                              endfor
                            
                              return {
                              \   'range': {
                              \     'start': {
                              \       'line': l:first_line,
                              \       'character': l:first_char,
                              \     },
                              \     'end': {
                              \       'line': l:old_len + l:last_line,
                              \       'character': strchars(l:old_lines[-1]) + l:last_char + 1,
                              \     }
                              \   },
                              \   'text': strcharpart(l:new_text, l:first_char, l:new_text_len + l:last_char - l:first_char),
                              \   'rangeLength': l:old_text_len + l:last_char - l:first_char
                              \ }
                            endfunction
                            
    1              0.000001 function! s:try_enable_lua() abort
                            lua <<EOF
                            function vital_vs_lsp_diff_search_line_region(old, new)
                              local old_len = #old
                              local new_len = #new
                              local min_len = math.min(#old, #new)
                            
                              local first_line = 0
                              while first_line < min_len - 1 do
                                if old[first_line + 1] ~= new[first_line + 1] then
                                  break
                                end
                                first_line = first_line + 1
                              end
                            
                              local last_line = -1
                              while last_line > -min_len + first_line do
                                if old[(old_len + last_line) + 1] ~= new[(new_len + last_line) + 1] then
                                  break
                                end
                                last_line = last_line - 1
                              end
                              return { first_line, last_line }
                            end
                            EOF
                            endfunction
                            
    1              0.000003 let s:is_lua_enabled = v:false
    1              0.000005 if has('nvim')
    1              0.000001   try
    1   0.000053   0.000008     call s:try_enable_lua()
    1              0.000003     let s:is_lua_enabled = v:true
                              catch /.*/
    1              0.000001   endtry
    1              0.000001 endif
                            

SCRIPT  /usr/share/nvim/runtime/ftplugin/lua.vim
Sourced 1 time
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            " Language:	Lua 4.0+
                            " Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Last Change:	2012 Mar 07
                            
                            " Only do this when not done yet for this buffer
    1              0.000012 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
                            
                            " Don't load another plugin for this buffer
    1              0.000005 let b:did_ftplugin = 1
                            
    1              0.000013 let s:cpo_save = &cpo
    1              0.000015 set cpo&vim
                            
                            " Set 'formatoptions' to break comment lines but not other lines, and insert
                            " the comment leader when hitting <CR> or using "o".
    1              0.000023 setlocal fo-=t fo+=croql
                            
    1              0.000009 setlocal com=:--
    1              0.000008 setlocal cms=--%s
    1              0.000004 setlocal suffixesadd=.lua
                            
                            
                            " The following lines enable the macros/matchit.vim plugin for
                            " extended matching with the % key.
    1              0.000006 if exists("loaded_matchit")
                            
    1              0.000004   let b:match_ignorecase = 0
    1              0.000009   let b:match_words =
                                \ '\<\%(do\|function\|if\)\>:' .
                                \ '\<\%(return\|else\|elseif\)\>:' .
                                \ '\<end\>,' .
                                \ '\<repeat\>:\<until\>'
                            
    1              0.000001 endif " exists("loaded_matchit")
                            
    1              0.000011 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
    1              0.000006 let b:undo_ftplugin = "setlocal fo< com< cms< suffixesadd<"

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/nlua.nvim/after/ftplugin/lua.vim
Sourced 1 time
Total time:   0.000436
 Self time:   0.000436

count  total (s)   self (s)
    1              0.000029 lua package.loaded['nlua.ftplugin'] = nil
    1              0.000397 lua require('nlua.ftplugin')()

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/everforest/after/ftplugin/lua/everforest.vim
Sourced 1 time
Total time:   0.000549
 Self time:   0.000549

count  total (s)   self (s)
    1              0.000014 if !exists('g:colors_name') || g:colors_name !=# 'everforest'
                                finish
    1              0.000001 endif
    1              0.000006 if index(g:everforest_loaded_file_types, 'lua') ==# -1
    1              0.000006     call add(g:everforest_loaded_file_types, 'lua')
                            else
                                finish
    1              0.000001 endif
                            " ft_begin: lua {{{
                            " builtin: {{{
    1              0.000068 highlight! link luaFunc Green
    1              0.000038 highlight! link luaFunction Aqua
    1              0.000029 highlight! link luaTable Fg
    1              0.000041 highlight! link luaIn RedItalic
                            " }}}
                            " vim-lua: https://github.com/tbastos/vim-lua {{{
    1              0.000028 highlight! link luaFuncCall Green
    1              0.000028 highlight! link luaLocal Orange
    1              0.000028 highlight! link luaSpecialValue Green
    1              0.000027 highlight! link luaBraces Fg
    1              0.000028 highlight! link luaBuiltIn Purple
    1              0.000027 highlight! link luaNoise Grey
    1              0.000027 highlight! link luaLabel Purple
    1              0.000027 highlight! link luaFuncTable Yellow
    1              0.000041 highlight! link luaFuncArgName Blue
    1              0.000029 highlight! link luaEllipsis Orange
    1              0.000029 highlight! link luaDocTag Green
                            " }}}
                            " ft_end

SCRIPT  /usr/share/nvim/runtime/indent/lua.vim
Sourced 1 time
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            
                            " Only load this indent file when no other was loaded.
    1              0.000008 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000005 let b:did_indent = 1
                            
    1              0.000011 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    1              0.000005 setlocal indentkeys+=0=end,0=until
                            
    1              0.000007 setlocal autoindent
                            
                            " Only define the function once.
    1              0.000006 if exists("*GetLuaIndent")
                              finish
    1              0.000001 endif
                            
    1              0.000003 function! GetLuaIndent()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{'
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '{\s*$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until and '}'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

SCRIPT  /usr/share/nvim/runtime/syntax/lua.vim
Sourced 1 time
Total time:   0.004207
 Self time:   0.004207

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Lua 4.0, Lua 5.0, Lua 5.1 and Lua 5.2
                            " Maintainer:	Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author:	Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:	2012 Aug 12
                            " Options:	lua_version = 4 or 5
                            "		lua_subversion = 0 (4.0, 5.0) or 1 (5.1) or 2 (5.2)
                            "		default 5.2
                            
                            " quit when a syntax file was already loaded
    1              0.000009 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
                            
    1              0.000015 let s:cpo_save = &cpo
    1              0.000012 set cpo&vim
                            
    1              0.000005 if !exists("lua_version")
                              " Default is lua 5.2
    1              0.000004   let lua_version = 5
    1              0.000003   let lua_subversion = 2
                            elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. So, set it to 0
                              let lua_subversion = 0
    1              0.000001 endif
                            
    1              0.000002 syn case match
                            
                            " syncing method
    1              0.000004 syn sync minlines=100
                            
                            " Comments
    1              0.000070 syn keyword luaTodo            contained TODO FIXME XXX
    1              0.000054 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    1              0.000006 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaComment start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    1              0.000006 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    1              0.000014   syn region luaComment        matchgroup=luaComment start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    1              0.000001 endif
                            
                            " First line may start with #!
    1              0.000006 syn match luaComment "\%^#!.*"
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
    1              0.000268 syn region luaParen      transparent                     start='(' end=')' contains=ALLBUT,luaParenError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
    1              0.000093 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=ALLBUT,luaBraceError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
                            
    1              0.000006 syn match  luaParenError ")"
    1              0.000004 syn match  luaBraceError "}"
    1              0.000034 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " function ... end
    1              0.000066 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " if ... then
    1              0.000057 syn region luaIfThen transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4           contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaIn nextgroup=luaThenEnd skipwhite skipempty
                            
                            " then ... end
    1              0.000030 syn region luaThenEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaThenEnd,luaIn
                            
                            " elseif ... then
    1              0.000032 syn region luaElseifThen contained transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " else
    1              0.000003 syn keyword luaElse contained else
                            
                            " do ... end
    1              0.000031 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>"          contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " repeat ... until
    1              0.000057 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>"   contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " while ... do
    1              0.000034 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaIn nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    1              0.000017 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2   contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd nextgroup=luaBlock skipwhite skipempty
                            
    1              0.000012 syn keyword luaIn contained in
                            
                            " other keywords
    1              0.000004 syn keyword luaStatement return local break
    1              0.000007 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000003   syn keyword luaStatement goto
    1              0.000015   syn match luaLabel "::\I\i*::"
    1              0.000002 endif
    1              0.000027 syn keyword luaOperator and or not
    1              0.000025 syn keyword luaConstant nil
    1              0.000008 if lua_version > 4
    1              0.000003   syn keyword luaConstant true false
    1              0.000001 endif
                            
                            " Strings
    1              0.000002 if lua_version < 5
                              syn match  luaSpecial contained "\\[\\abfnrtv\'\"]\|\\[[:digit:]]\{,3}"
    1              0.000003 elseif lua_version == 5
    1              0.000002   if lua_subversion == 0
                                syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
                                syn region luaString2 matchgroup=luaString start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    1              0.000002   else
    1              0.000003     if lua_subversion == 1
                                  syn match  luaSpecial contained #\\[\\abfnrtv'"]\|\\[[:digit:]]\{,3}#
    1              0.000002     else " Lua 5.2
    1              0.000016       syn match  luaSpecial contained #\\[\\abfnrtvz'"]\|\\x[[:xdigit:]]\{2}\|\\[[:digit:]]\{,3}#
    1              0.000002     endif
    1              0.000037     syn region luaString2 matchgroup=luaString start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    1              0.000002   endif
    1              0.000001 endif
    1              0.000013 syn region luaString  start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    1              0.000013 syn region luaString  start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    1              0.000028 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    1              0.000018 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, starting with a dot, optional exponent
    1              0.000006 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    1              0.000005 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    1              0.000004 if lua_version >= 5
    1              0.000002   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    1              0.000003   elseif lua_subversion >= 2
    1              0.000011     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    1              0.000001   endif
    1              0.000001 endif
                            
    1              0.000015 syn keyword luaFunc assert collectgarbage dofile error next
    1              0.000014 syn keyword luaFunc print rawget rawset tonumber tostring type _VERSION
                            
    1              0.000003 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    1              0.000003 elseif lua_version == 5
    1              0.000012   syn keyword luaFunc getmetatable setmetatable
    1              0.000011   syn keyword luaFunc ipairs pairs
    1              0.000011   syn keyword luaFunc pcall xpcall
    1              0.000012   syn keyword luaFunc _G loadfile rawequal require
    1              0.000003   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    1              0.000001   else
    1              0.000011     syn keyword luaFunc load select
    1              0.000016     syn match   luaFunc /\<package\.cpath\>/
    1              0.000016     syn match   luaFunc /\<package\.loaded\>/
    1              0.000015     syn match   luaFunc /\<package\.loadlib\>/
    1              0.000014     syn match   luaFunc /\<package\.path\>/
    1              0.000003     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.preload\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    1              0.000003     elseif lua_subversion == 2
    1              0.000012       syn keyword luaFunc _ENV rawlen
    1              0.000015       syn match   luaFunc /\<package\.config\>/
    1              0.000015       syn match   luaFunc /\<package\.preload\>/
    1              0.000015       syn match   luaFunc /\<package\.searchers\>/
    1              0.000014       syn match   luaFunc /\<package\.searchpath\>/
    1              0.000014       syn match   luaFunc /\<bit32\.arshift\>/
    1              0.000014       syn match   luaFunc /\<bit32\.band\>/
    1              0.000014       syn match   luaFunc /\<bit32\.bnot\>/
    1              0.000014       syn match   luaFunc /\<bit32\.bor\>/
    1              0.000014       syn match   luaFunc /\<bit32\.btest\>/
    1              0.000014       syn match   luaFunc /\<bit32\.bxor\>/
    1              0.000018       syn match   luaFunc /\<bit32\.extract\>/
    1              0.000014       syn match   luaFunc /\<bit32\.lrotate\>/
    1              0.000017       syn match   luaFunc /\<bit32\.lshift\>/
    1              0.000014       syn match   luaFunc /\<bit32\.replace\>/
    1              0.000014       syn match   luaFunc /\<bit32\.rrotate\>/
    1              0.000014       syn match   luaFunc /\<bit32\.rshift\>/
    1              0.000002     endif
    1              0.000015     syn match luaFunc /\<coroutine\.running\>/
    1              0.000001   endif
    1              0.000015   syn match   luaFunc /\<coroutine\.create\>/
    1              0.000016   syn match   luaFunc /\<coroutine\.resume\>/
    1              0.000022   syn match   luaFunc /\<coroutine\.status\>/
    1              0.000015   syn match   luaFunc /\<coroutine\.wrap\>/
    1              0.000015   syn match   luaFunc /\<coroutine\.yield\>/
    1              0.000014   syn match   luaFunc /\<string\.byte\>/
    1              0.000014   syn match   luaFunc /\<string\.char\>/
    1              0.000014   syn match   luaFunc /\<string\.dump\>/
    1              0.000014   syn match   luaFunc /\<string\.find\>/
    1              0.000014   syn match   luaFunc /\<string\.format\>/
    1              0.000014   syn match   luaFunc /\<string\.gsub\>/
    1              0.000014   syn match   luaFunc /\<string\.len\>/
    1              0.000014   syn match   luaFunc /\<string\.lower\>/
    1              0.000013   syn match   luaFunc /\<string\.rep\>/
    1              0.000013   syn match   luaFunc /\<string\.sub\>/
    1              0.000014   syn match   luaFunc /\<string\.upper\>/
    1              0.000004   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    1              0.000001   else
    1              0.000014     syn match luaFunc /\<string\.gmatch\>/
    1              0.000014     syn match luaFunc /\<string\.match\>/
    1              0.000020     syn match luaFunc /\<string\.reverse\>/
    1              0.000002   endif
    1              0.000003   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    1              0.000003   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    1              0.000002   elseif lua_subversion == 2
    1              0.000014     syn match luaFunc /\<table\.pack\>/
    1              0.000015     syn match luaFunc /\<table\.unpack\>/
    1              0.000001   endif
    1              0.000014   syn match   luaFunc /\<table\.concat\>/
    1              0.000015   syn match   luaFunc /\<table\.sort\>/
    1              0.000015   syn match   luaFunc /\<table\.insert\>/
    1              0.000015   syn match   luaFunc /\<table\.remove\>/
    1              0.000014   syn match   luaFunc /\<math\.abs\>/
    1              0.000014   syn match   luaFunc /\<math\.acos\>/
    1              0.000015   syn match   luaFunc /\<math\.asin\>/
    1              0.000015   syn match   luaFunc /\<math\.atan\>/
    1              0.000018   syn match   luaFunc /\<math\.atan2\>/
    1              0.000014   syn match   luaFunc /\<math\.ceil\>/
    1              0.000014   syn match   luaFunc /\<math\.sin\>/
    1              0.000014   syn match   luaFunc /\<math\.cos\>/
    1              0.000031   syn match   luaFunc /\<math\.tan\>/
    1              0.000015   syn match   luaFunc /\<math\.deg\>/
    1              0.000014   syn match   luaFunc /\<math\.exp\>/
    1              0.000014   syn match   luaFunc /\<math\.floor\>/
    1              0.000014   syn match   luaFunc /\<math\.log\>/
    1              0.000014   syn match   luaFunc /\<math\.max\>/
    1              0.000014   syn match   luaFunc /\<math\.min\>/
    1              0.000004   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    1              0.000002   else
    1              0.000003     if lua_subversion == 1
                                  syn match luaFunc /\<math\.log10\>/
    1              0.000001     endif
    1              0.000014     syn match luaFunc /\<math\.huge\>/
    1              0.000016     syn match luaFunc /\<math\.fmod\>/
    1              0.000014     syn match luaFunc /\<math\.modf\>/
    1              0.000015     syn match luaFunc /\<math\.cosh\>/
    1              0.000015     syn match luaFunc /\<math\.sinh\>/
    1              0.000014     syn match luaFunc /\<math\.tanh\>/
    1              0.000002   endif
    1              0.000014   syn match   luaFunc /\<math\.pow\>/
    1              0.000014   syn match   luaFunc /\<math\.rad\>/
    1              0.000014   syn match   luaFunc /\<math\.sqrt\>/
    1              0.000014   syn match   luaFunc /\<math\.frexp\>/
    1              0.000014   syn match   luaFunc /\<math\.ldexp\>/
    1              0.000014   syn match   luaFunc /\<math\.random\>/
    1              0.000015   syn match   luaFunc /\<math\.randomseed\>/
    1              0.000014   syn match   luaFunc /\<math\.pi\>/
    1              0.000014   syn match   luaFunc /\<io\.close\>/
    1              0.000014   syn match   luaFunc /\<io\.flush\>/
    1              0.000014   syn match   luaFunc /\<io\.input\>/
    1              0.000014   syn match   luaFunc /\<io\.lines\>/
    1              0.000014   syn match   luaFunc /\<io\.open\>/
    1              0.000014   syn match   luaFunc /\<io\.output\>/
    1              0.000018   syn match   luaFunc /\<io\.popen\>/
    1              0.000014   syn match   luaFunc /\<io\.read\>/
    1              0.000015   syn match   luaFunc /\<io\.stderr\>/
    1              0.000017   syn match   luaFunc /\<io\.stdin\>/
    1              0.000016   syn match   luaFunc /\<io\.stdout\>/
    1              0.000014   syn match   luaFunc /\<io\.tmpfile\>/
    1              0.000014   syn match   luaFunc /\<io\.type\>/
    1              0.000014   syn match   luaFunc /\<io\.write\>/
    1              0.000014   syn match   luaFunc /\<os\.clock\>/
    1              0.000014   syn match   luaFunc /\<os\.date\>/
    1              0.000014   syn match   luaFunc /\<os\.difftime\>/
    1              0.000015   syn match   luaFunc /\<os\.execute\>/
    1              0.000014   syn match   luaFunc /\<os\.exit\>/
    1              0.000014   syn match   luaFunc /\<os\.getenv\>/
    1              0.000017   syn match   luaFunc /\<os\.remove\>/
    1              0.000014   syn match   luaFunc /\<os\.rename\>/
    1              0.000017   syn match   luaFunc /\<os\.setlocale\>/
    1              0.000014   syn match   luaFunc /\<os\.time\>/
    1              0.000015   syn match   luaFunc /\<os\.tmpname\>/
    1              0.000015   syn match   luaFunc /\<debug\.debug\>/
    1              0.000019   syn match   luaFunc /\<debug\.gethook\>/
    1              0.000034   syn match   luaFunc /\<debug\.getinfo\>/
    1              0.000016   syn match   luaFunc /\<debug\.getlocal\>/
    1              0.000015   syn match   luaFunc /\<debug\.getupvalue\>/
    1              0.000015   syn match   luaFunc /\<debug\.setlocal\>/
    1              0.000015   syn match   luaFunc /\<debug\.setupvalue\>/
    1              0.000015   syn match   luaFunc /\<debug\.sethook\>/
    1              0.000015   syn match   luaFunc /\<debug\.traceback\>/
    1              0.000004   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
                                syn match luaFunc /\<debug\.getmetatable\>/
                                syn match luaFunc /\<debug\.setmetatable\>/
                                syn match luaFunc /\<debug\.getregistry\>/
    1              0.000003   elseif lua_subversion == 2
    1              0.000016     syn match luaFunc /\<debug\.getmetatable\>/
    1              0.000016     syn match luaFunc /\<debug\.setmetatable\>/
    1              0.000015     syn match luaFunc /\<debug\.getregistry\>/
    1              0.000019     syn match luaFunc /\<debug\.getuservalue\>/
    1              0.000040     syn match luaFunc /\<debug\.setuservalue\>/
    1              0.000016     syn match luaFunc /\<debug\.upvalueid\>/
    1              0.000016     syn match luaFunc /\<debug\.upvaluejoin\>/
    1              0.000002   endif
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000042 hi def link luaStatement		Statement
    1              0.000029 hi def link luaRepeat		Repeat
    1              0.000050 hi def link luaFor			Repeat
    1              0.000024 hi def link luaString		String
    1              0.000024 hi def link luaString2		String
    1              0.000024 hi def link luaNumber		Number
    1              0.000024 hi def link luaOperator		Operator
    1              0.000032 hi def link luaIn			Operator
    1              0.000023 hi def link luaConstant		Constant
    1              0.000023 hi def link luaCond		Conditional
    1              0.000023 hi def link luaElse		Conditional
    1              0.000030 hi def link luaFunction		Function
    1              0.000023 hi def link luaComment		Comment
    1              0.000022 hi def link luaTodo		Todo
    1              0.000030 hi def link luaTable		Structure
    1              0.000023 hi def link luaError		Error
    1              0.000023 hi def link luaParenError		Error
    1              0.000023 hi def link luaBraceError		Error
    1              0.000024 hi def link luaSpecial		SpecialChar
    1              0.000032 hi def link luaFunc		Identifier
    1              0.000030 hi def link luaLabel		Label
                            
                            
    1              0.000012 let b:current_syntax = "lua"
                            
    1              0.000033 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/autoload/ale/util.vim
Sourced 1 time
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Contains miscellaneous functions
                            
                            " A wrapper function for mode() so we can test calls for it.
    1              0.000005 function! ale#util#Mode(...) abort
                                return call('mode', a:000)
                            endfunction
                            
                            " A wrapper function for feedkeys so we can test calls for it.
    1              0.000003 function! ale#util#FeedKeys(...) abort
                                return call('feedkeys', a:000)
                            endfunction
                            
                            " Show a message in as small a window as possible.
                            "
                            " Vim 8 does not support echoing long messages from asynchronous callbacks,
                            " but NeoVim does. Small messages can be echoed in Vim 8, and larger messages
                            " have to be shown in preview windows.
    1              0.000003 function! ale#util#ShowMessage(string, ...) abort
                                let l:options = get(a:000, 0, {})
                            
                                if !has('nvim')
                                    call ale#preview#CloseIfTypeMatches('ale-preview.message')
                                endif
                            
                                " We have to assume the user is using a monospace font.
                                if has('nvim') || (a:string !~? "\n" && len(a:string) < &columns)
                                    execute 'echo a:string'
                                else
                                    call ale#preview#Show(split(a:string, "\n"), extend(
                                    \   {
                                    \       'filetype': 'ale-preview.message',
                                    \       'stay_here': 1,
                                    \   },
                                    \   l:options,
                                    \))
                                endif
                            endfunction
                            
                            " A wrapper function for execute, so we can test executing some commands.
    1              0.000003 function! ale#util#Execute(expr) abort
                                execute a:expr
                            endfunction
                            
    1              0.000007 if !exists('g:ale#util#nul_file')
                                " A null file for sending output to nothing.
    1              0.000005     let g:ale#util#nul_file = '/dev/null'
                            
    1              0.000008     if has('win32')
                                    let g:ale#util#nul_file = 'nul'
    1              0.000001     endif
    1              0.000001 endif
                            
                            " Given a job, a buffered line of data, a list of parts of lines, a mode data
                            " is being read in, and a callback, join the lines of output for a NeoVim job
                            " or socket together, and call the callback with the joined output.
                            "
                            " Note that jobs and IDs are the same thing on NeoVim.
    1              0.000005 function! ale#util#JoinNeovimOutput(job, last_line, data, mode, callback) abort
                                if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
                                endif
                            
                                let l:lines = a:data[:-2]
                            
                                if len(a:data) > 1
                                    let l:lines[0] = a:last_line . l:lines[0]
                                    let l:new_last_line = a:data[-1]
                                else
                                    let l:new_last_line = a:last_line . get(a:data, 0, '')
                                endif
                            
                                for l:line in l:lines
                                    call a:callback(a:job, l:line)
                                endfor
                            
                                return l:new_last_line
                            endfunction
                            
                            " Return the number of lines for a given buffer.
    1              0.000003 function! ale#util#GetLineCount(buffer) abort
                                return len(getbufline(a:buffer, 1, '$'))
                            endfunction
                            
    1              0.000003 function! ale#util#GetFunction(string_or_ref) abort
                                if type(a:string_or_ref) is v:t_string
                                    return function(a:string_or_ref)
                                endif
                            
                                return a:string_or_ref
                            endfunction
                            
                            " Open the file (at the given line).
                            " options['open_in'] can be:
                            "   current-buffer (default)
                            "   tab
                            "   split
                            "   vsplit
    1              0.000004 function! ale#util#Open(filename, line, column, options) abort
                                let l:open_in = get(a:options, 'open_in', 'current-buffer')
                                let l:args_to_open = '+' . a:line . ' ' . fnameescape(a:filename)
                            
                                if l:open_in is# 'tab'
                                    call ale#util#Execute('tabedit ' . l:args_to_open)
                                elseif l:open_in is# 'split'
                                    call ale#util#Execute('split ' . l:args_to_open)
                                elseif l:open_in is# 'vsplit'
                                    call ale#util#Execute('vsplit ' . l:args_to_open)
                                elseif bufnr(a:filename) isnot bufnr('')
                                    " Open another file only if we need to.
                                    call ale#util#Execute('edit ' . l:args_to_open)
                                else
                                    normal! m`
                                endif
                            
                                call cursor(a:line, a:column)
                                normal! zz
                            endfunction
                            
    1              0.000005 let g:ale#util#error_priority = 5
    1              0.000004 let g:ale#util#warning_priority = 4
    1              0.000005 let g:ale#util#info_priority = 3
    1              0.000004 let g:ale#util#style_error_priority = 2
    1              0.000005 let g:ale#util#style_warning_priority = 1
                            
    1              0.000003 function! ale#util#GetItemPriority(item) abort
                                if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
                                if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
                                endif
                            
                                if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
                                return g:ale#util#error_priority
                            endfunction
                            
                            " Compare two loclist items for ALE, sorted by their buffers, filenames, and
                            " line numbers and column numbers.
    1              0.000003 function! ale#util#LocItemCompare(left, right) abort
                                if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
                                if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
                                if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
                                if a:left.lnum < a:right.lnum
                                    return -1
                                endif
                            
                                if a:left.lnum > a:right.lnum
                                    return 1
                                endif
                            
                                if a:left.col < a:right.col
                                    return -1
                                endif
                            
                                if a:left.col > a:right.col
                                    return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " Compare two loclist items, including the text for the items.
                            "
                            " This function can be used for de-duplicating lists.
    1              0.000003 function! ale#util#LocItemCompareWithText(left, right) abort
                                let l:cmp_value = ale#util#LocItemCompare(a:left, a:right)
                            
                                if l:cmp_value
                                    return l:cmp_value
                                endif
                            
                                if a:left.text < a:right.text
                                    return -1
                                endif
                            
                                if a:left.text > a:right.text
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " This function will perform a binary search and a small sequential search
                            " on the list to find the last problem in the buffer and line which is
                            " on or before the column. The index of the problem will be returned.
                            "
                            " -1 will be returned if nothing can be found.
    1              0.000004 function! ale#util#BinarySearch(loclist, buffer, line, column) abort
                                let l:min = 0
                                let l:max = len(a:loclist) - 1
                            
                                while 1
                                    if l:max < l:min
                                        return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0
                                        \&& a:loclist[l:index - 1].bufnr == a:buffer
                                        \&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max
                                        \&& a:loclist[l:index + 1].bufnr == a:buffer
                                        \&& a:loclist[l:index + 1].lnum == a:line
                                        \&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max
                                        \&& a:loclist[l:index + 1].bufnr == a:buffer
                                        \&& a:loclist[l:index + 1].lnum == a:line
                                        \&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile
                            endfunction
                            
                            " A function for testing if a function is running inside a sandbox.
                            " See :help sandbox
    1              0.000002 function! ale#util#InSandbox() abort
                                try
                                    let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
                                return 0
                            endfunction
                            
    1              0.000002 function! ale#util#Tempname() abort
                                let l:clear_tempdir = 0
                            
                                if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
                                endif
                            
                                try
                                    let l:name = tempname() " no-custom-checks
                                finally
                                    if l:clear_tempdir
                                        let $TMPDIR = ''
                                    endif
                                endtry
                            
                                return l:name
                            endfunction
                            
                            " Given a single line, or a List of lines, and a single pattern, or a List
                            " of patterns, return all of the matches for the lines(s) from the given
                            " patterns, using matchlist().
                            "
                            " Only the first pattern which matches a line will be returned.
    1              0.000003 function! ale#util#GetMatches(lines, patterns) abort
                                let l:matches = []
                                let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
                                let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
                                for l:line in l:lines
                                    for l:pattern in l:patterns
                                        let l:match = matchlist(l:line, l:pattern)
                            
                                        if !empty(l:match)
                                            call add(l:matches, l:match)
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                return l:matches
                            endfunction
                            
    1              0.000004 function! s:LoadArgCount(function) abort
                                try
                                    let l:output = execute('function a:function')
                                catch /E123/
                                    return 0
                                endtry
                            
                                let l:match = matchstr(split(l:output, "\n")[0], '\v\([^)]+\)')[1:-2]
                                let l:arg_list = filter(split(l:match, ', '), 'v:val isnot# ''...''')
                            
                                return len(l:arg_list)
                            endfunction
                            
                            " Given the name of a function, a Funcref, or a lambda, return the number
                            " of named arguments for a function.
    1              0.000003 function! ale#util#FunctionArgCount(function) abort
                                let l:Function = ale#util#GetFunction(a:function)
                                let l:count = s:LoadArgCount(l:Function)
                            
                                " If we failed to get the count, forcibly load the autoload file, if the
                                " function is an autoload function. autoload functions aren't normally
                                " defined until they are called.
                                if l:count == 0
                                    let l:function_name = matchlist(string(l:Function), 'function([''"]\(.\+\)[''"])')[1]
                            
                                    if l:function_name =~# '#'
                                        execute 'runtime autoload/' . join(split(l:function_name, '#')[:-2], '/') . '.vim'
                                        let l:count = s:LoadArgCount(l:Function)
                                    endif
                                endif
                            
                                return l:count
                            endfunction
                            
                            " Escape a string so the characters in it will be safe for use inside of PCRE
                            " or RE2 regular expressions without characters having special meanings.
    1              0.000003 function! ale#util#EscapePCRE(unsafe_string) abort
                                return substitute(a:unsafe_string, '\([\-\[\]{}()*+?.^$|]\)', '\\\1', 'g')
                            endfunction
                            
                            " Escape a string so that it can be used as a literal string inside an evaled
                            " vim command.
    1              0.000003 function! ale#util#EscapeVim(unsafe_string) abort
                                return "'" . substitute(a:unsafe_string, "'", "''", 'g') . "'"
                            endfunction
                            
                            
                            " Given a String or a List of String values, try and decode the string(s)
                            " as a JSON value which can be decoded with json_decode. If the JSON string
                            " is invalid, the default argument value will be returned instead.
                            "
                            " This function is useful in code where the data can't be trusted to be valid
                            " JSON, and where throwing exceptions is mostly just irritating.
    1              0.000003 function! ale#util#FuzzyJSONDecode(data, default) abort
                                if empty(a:data)
                                    return a:default
                                endif
                            
                                let l:str = type(a:data) is v:t_string ? a:data : join(a:data, '')
                            
                                try
                                    let l:result = json_decode(l:str)
                            
                                    " Vim 8 only uses the value v:none for decoding blank strings.
                                    if !has('nvim') && l:result is v:none
                                        return a:default
                                    endif
                            
                                    return l:result
                                catch /E474\|E491/
                                    return a:default
                                endtry
                            endfunction
                            
                            " Write a file, including carriage return characters for DOS files.
                            "
                            " The buffer number is required for determining the fileformat setting for
                            " the buffer.
    1              0.000003 function! ale#util#Writefile(buffer, lines, filename) abort
                                let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'
                                \   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')
                                \   : a:lines
                            
                                " Set binary flag if buffer doesn't have eol and nofixeol to avoid appending newline
                                let l:flags = !getbufvar(a:buffer, '&eol') && exists('+fixeol') && !&fixeol ? 'bS' : 'S'
                            
                                call writefile(l:corrected_lines, a:filename, l:flags) " no-custom-checks
                            endfunction
                            
    1              0.000005 if !exists('s:patial_timers')
    1              0.000004     let s:partial_timers = {}
    1              0.000001 endif
                            
    1              0.000004 function! s:ApplyPartialTimer(timer_id) abort
                                if has_key(s:partial_timers, a:timer_id)
                                    let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
                                    call call(l:Callback, [a:timer_id] + l:args)
                                endif
                            endfunction
                            
                            " Given a delay, a callback, a List of arguments, start a timer with
                            " timer_start() and call the callback provided with [timer_id] + args.
                            "
                            " The timer must not be stopped with timer_stop().
                            " Use ale#util#StopPartialTimer() instead, which can stop any timer, and will
                            " clear any arguments saved for executing callbacks later.
    1              0.000004 function! ale#util#StartPartialTimer(delay, callback, args) abort
                                let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
                                let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
                                return l:timer_id
                            endfunction
                            
    1              0.000003 function! ale#util#StopPartialTimer(timer_id) abort
                                call timer_stop(a:timer_id)
                            
                                if has_key(s:partial_timers, a:timer_id)
                                    call remove(s:partial_timers, a:timer_id)
                                endif
                            endfunction
                            
                            " Given a possibly multi-byte string and a 1-based character position on a
                            " line, return the 1-based byte position on that line.
    1              0.000003 function! ale#util#Col(str, chr) abort
                                if a:chr < 2
                                    return a:chr
                                endif
                            
                                return strlen(join(split(a:str, '\zs')[0:a:chr - 2], '')) + 1
                            endfunction
                            
    1              0.000003 function! ale#util#FindItemAtCursor(buffer) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                                let l:loclist = get(l:info, 'loclist', [])
                                let l:pos = getpos('.')
                                let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
                                let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
                                return [l:info, l:loc]
                            endfunction
                            
    1              0.000003 function! ale#util#Input(message, value) abort
                                return input(a:message, a:value)
                            endfunction
                            
    1              0.000002 function! ale#util#HasBuflineApi() abort
                                return exists('*deletebufline') && exists('*setbufline')
                            endfunction
                            
                            " Sets buffer contents to lines
    1              0.000003 function! ale#util#SetBufferContents(buffer, lines) abort
                                let l:has_bufline_api = ale#util#HasBuflineApi()
                            
                                if !l:has_bufline_api && a:buffer isnot bufnr('')
                                    return
                                endif
                            
                                " If the file is in DOS mode, we have to remove carriage returns from
                                " the ends of lines before calling setline(), or we will see them
                                " twice.
                                let l:new_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'
                                \   ? map(copy(a:lines), 'substitute(v:val, ''\r\+$'', '''', '''')')
                                \   : a:lines
                                let l:first_line_to_remove = len(l:new_lines) + 1
                            
                                " Use a Vim API for setting lines in other buffers, if available.
                                if l:has_bufline_api
                                    call setbufline(a:buffer, 1, l:new_lines)
                                    call deletebufline(a:buffer, l:first_line_to_remove, '$')
                                " Fall back on setting lines the old way, for the current buffer.
                                else
                                    let l:old_line_length = line('$')
                            
                                    if l:old_line_length >= l:first_line_to_remove
                                        let l:save = winsaveview()
                                        silent execute
                                        \   l:first_line_to_remove . ',' . l:old_line_length . 'd_'
                                        call winrestview(l:save)
                                    endif
                            
                                    call setline(1, l:new_lines)
                                endif
                            
                                return l:new_lines
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/autoload/ale/linter.vim
Sourced 1 time
Total time:   0.000515
 Self time:   0.000515

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Linter registration and lazy-loading
                            "   Retrieves linters as requested by the engine, loading them if needed.
                            
    1              0.000006 let s:runtime_loaded_map = {}
    1              0.000003 let s:linters = {}
                            
                            " Default filetype aliases.
                            " The user defined aliases will be merged with this Dictionary.
                            "
                            " NOTE: Update the g:ale_linter_aliases documentation when modifying this.
    1              0.000037 let s:default_ale_linter_aliases = {
                            \   'Dockerfile': 'dockerfile',
                            \   'csh': 'sh',
                            \   'javascriptreact': ['javascript', 'jsx'],
                            \   'plaintex': 'tex',
                            \   'ps1': 'powershell',
                            \   'rmarkdown': 'r',
                            \   'rmd': 'r',
                            \   'systemverilog': 'verilog',
                            \   'typescriptreact': ['typescript', 'tsx'],
                            \   'verilog_systemverilog': ['verilog_systemverilog', 'verilog'],
                            \   'vimwiki': 'markdown',
                            \   'vue': ['vue', 'javascript'],
                            \   'xsd': ['xsd', 'xml'],
                            \   'xslt': ['xslt', 'xml'],
                            \   'zsh': 'sh',
                            \}
                            
                            " Default linters to run for particular filetypes.
                            " The user defined linter selections will be merged with this Dictionary.
                            "
                            " No linters are used for plaintext files by default.
                            "
                            " Only cargo and rls are enabled for Rust by default.
                            " rpmlint is disabled by default because it can result in code execution.
                            " hhast is disabled by default because it executes code in the project root.
                            "
                            " NOTE: Update the g:ale_linters documentation when modifying this.
    1              0.000036 let s:default_ale_linters = {
                            \   'apkbuild': ['apkbuild_lint', 'secfixes_check'],
                            \   'csh': ['shell'],
                            \   'elixir': ['credo', 'dialyxir', 'dogma'],
                            \   'go': ['gofmt', 'golint', 'go vet'],
                            \   'hack': ['hack'],
                            \   'help': [],
                            \   'inko': ['inko'],
                            \   'perl': ['perlcritic'],
                            \   'perl6': [],
                            \   'python': ['flake8', 'mypy', 'pylint', 'pyright'],
                            \   'rust': ['cargo', 'rls'],
                            \   'spec': [],
                            \   'text': [],
                            \   'vue': ['eslint', 'vls'],
                            \   'zsh': ['shell'],
                            \}
                            
                            " Testing/debugging helper to unload all linters.
    1              0.000004 function! ale#linter#Reset() abort
                                let s:runtime_loaded_map = {}
                                let s:linters = {}
                            endfunction
                            
                            " Return a reference to the linters loaded.
                            " This is only for tests.
                            " Do not call this function.
    1              0.000003 function! ale#linter#GetLintersLoaded() abort
                                " This command will throw from the sandbox.
                                let &l:equalprg=&l:equalprg
                            
                                return s:linters
                            endfunction
                            
    1              0.000004 function! s:IsCallback(value) abort
                                return type(a:value) is v:t_string || type(a:value) is v:t_func
                            endfunction
                            
    1              0.000003 function! s:IsBoolean(value) abort
                                return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)
                            endfunction
                            
    1              0.000003 function! ale#linter#PreProcess(filetype, linter) abort
                                if type(a:linter) isnot v:t_dict
                                    throw 'The linter object must be a Dictionary'
                                endif
                            
                                let l:obj = {
                                \   'name': get(a:linter, 'name'),
                                \   'lsp': get(a:linter, 'lsp', ''),
                                \}
                            
                                if type(l:obj.name) isnot v:t_string
                                    throw '`name` must be defined to name the linter'
                                endif
                            
                                let l:needs_address = l:obj.lsp is# 'socket'
                                let l:needs_executable = l:obj.lsp isnot# 'socket'
                                let l:needs_command = l:obj.lsp isnot# 'socket'
                                let l:needs_lsp_details = !empty(l:obj.lsp)
                            
                                if empty(l:obj.lsp)
                                    let l:obj.callback = get(a:linter, 'callback')
                            
                                    if !s:IsCallback(l:obj.callback)
                                        throw '`callback` must be defined with a callback to accept output'
                                    endif
                                endif
                            
                                if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                    throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
                                endif
                            
                                if !l:needs_executable
                                    if has_key(a:linter, 'executable')
                                        throw '`executable` cannot be used when lsp == ''socket'''
                                    endif
                                elseif has_key(a:linter, 'executable')
                                    let l:obj.executable = a:linter.executable
                            
                                    if type(l:obj.executable) isnot v:t_string
                                    \&& type(l:obj.executable) isnot v:t_func
                                        throw '`executable` must be a String or Function if defined'
                                    endif
                                else
                                    throw '`executable` must be defined'
                                endif
                            
                                if !l:needs_command
                                    if has_key(a:linter, 'command')
                                        throw '`command` cannot be used when lsp == ''socket'''
                                    endif
                                elseif has_key(a:linter, 'command')
                                    let l:obj.command = a:linter.command
                            
                                    if type(l:obj.command) isnot v:t_string
                                    \&& type(l:obj.command) isnot v:t_func
                                        throw '`command` must be a String or Function if defined'
                                    endif
                                else
                                    throw '`command` must be defined'
                                endif
                            
                                if !l:needs_address
                                    if has_key(a:linter, 'address')
                                        throw '`address` cannot be used when lsp != ''socket'''
                                    endif
                                elseif has_key(a:linter, 'address')
                                    if type(a:linter.address) isnot v:t_string
                                    \&& type(a:linter.address) isnot v:t_func
                                        throw '`address` must be a String or Function if defined'
                                    endif
                            
                                    let l:obj.address = a:linter.address
                                else
                                    throw '`address` must be defined for getting the LSP address'
                                endif
                            
                                if l:needs_lsp_details
                                    " Default to using the filetype as the language.
                                    let l:obj.language = get(a:linter, 'language', a:filetype)
                            
                                    if type(l:obj.language) isnot v:t_string
                                    \&& type(l:obj.language) isnot v:t_func
                                        throw '`language` must be a String or Funcref if defined'
                                    endif
                            
                                    if has_key(a:linter, 'project_root')
                                        let l:obj.project_root = a:linter.project_root
                            
                                        if type(l:obj.project_root) isnot v:t_string
                                        \&& type(l:obj.project_root) isnot v:t_func
                                            throw '`project_root` must be a String or Function'
                                        endif
                                    else
                                        throw '`project_root` must be defined for LSP linters'
                                    endif
                            
                                    if has_key(a:linter, 'completion_filter')
                                        let l:obj.completion_filter = a:linter.completion_filter
                            
                                        if !s:IsCallback(l:obj.completion_filter)
                                            throw '`completion_filter` must be a callback'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'initialization_options')
                                        let l:obj.initialization_options = a:linter.initialization_options
                            
                                        if type(l:obj.initialization_options) isnot v:t_dict
                                        \&& type(l:obj.initialization_options) isnot v:t_func
                                            throw '`initialization_options` must be a Dictionary or Function if defined'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'lsp_config')
                                        if type(a:linter.lsp_config) isnot v:t_dict
                                        \&& type(a:linter.lsp_config) isnot v:t_func
                                            throw '`lsp_config` must be a Dictionary or Function if defined'
                                        endif
                            
                                        let l:obj.lsp_config = a:linter.lsp_config
                                    endif
                                endif
                            
                                let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                            
                                if type(l:obj.output_stream) isnot v:t_string
                                \|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                    throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
                                endif
                            
                                " An option indicating that this linter should only be run against the
                                " file on disk.
                                let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                            
                                if !s:IsBoolean(l:obj.lint_file) && type(l:obj.lint_file) isnot v:t_func
                                    throw '`lint_file` must be `0`, `1`, or a Function'
                                endif
                            
                                " An option indicating that the buffer should be read.
                                let l:obj.read_buffer = get(a:linter, 'read_buffer', 1)
                            
                                if !s:IsBoolean(l:obj.read_buffer)
                                    throw '`read_buffer` must be `0` or `1`'
                                endif
                            
                                let l:obj.aliases = get(a:linter, 'aliases', [])
                            
                                if type(l:obj.aliases) isnot v:t_list
                                \|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                    throw '`aliases` must be a List of String values'
                                endif
                            
                                return l:obj
                            endfunction
                            
    1              0.000003 function! ale#linter#Define(filetype, linter) abort
                                " This command will throw from the sandbox.
                                let &l:equalprg=&l:equalprg
                            
                                let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                            
                                if !has_key(s:linters, a:filetype)
                                    let s:linters[a:filetype] = []
                                endif
                            
                                " Remove previously defined linters with the same name.
                                call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
                                call add(s:linters[a:filetype], l:new_linter)
                            endfunction
                            
                            " Prevent any linters from being loaded for a given filetype.
    1              0.000003 function! ale#linter#PreventLoading(filetype) abort
                                let s:runtime_loaded_map[a:filetype] = 1
                            endfunction
                            
    1              0.000003 function! ale#linter#GetAll(filetypes) abort
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
                                if ale#util#InSandbox()
                                    return []
                                endif
                            
                                let l:combined_linters = []
                            
                                for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
                                    if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
                                    call extend(l:combined_linters, get(s:linters, l:filetype, []))
                                endfor
                            
                                return l:combined_linters
                            endfunction
                            
    1              0.000003 function! s:GetAliasedFiletype(original_filetype) abort
                                let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
                                if type(l:buffer_aliases) is v:t_list
                                \|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
                                for l:dict in [
                                \   l:buffer_aliases,
                                \   g:ale_linter_aliases,
                                \   s:default_ale_linter_aliases,
                                \]
                                    if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
                                endfor
                            
                                return a:original_filetype
                            endfunction
                            
    1              0.000003 function! ale#linter#ResolveFiletype(original_filetype) abort
                                let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
                                if type(l:filetype) isnot v:t_list
                                    return [l:filetype]
                                endif
                            
                                return l:filetype
                            endfunction
                            
    1              0.000003 function! s:GetLinterNames(original_filetype) abort
                                let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
                                if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
                                if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
                                if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
                                if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
                                if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
                                if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'
                            endfunction
                            
    1              0.000003 function! ale#linter#Get(original_filetypes) abort
                                let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
                                for l:original_filetype in split(a:original_filetypes, '\.')
                                    let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
                                    let l:linter_names = s:GetLinterNames(l:original_filetype)
                                    let l:all_linters = ale#linter#GetAll(l:filetype)
                                    let l:filetype_linters = []
                            
                                    if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
                                    call extend(l:possibly_duplicated_linters, l:filetype_linters)
                                endfor
                            
                                let l:name_list = []
                                let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
                                for l:linter in reverse(l:possibly_duplicated_linters)
                                    if index(l:name_list, l:linter.name) < 0
                                        call add(l:name_list, l:linter.name)
                                        call add(l:combined_linters, l:linter)
                                    endif
                                endfor
                            
                                return reverse(l:combined_linters)
                            endfunction
                            
    1              0.000004 function! ale#linter#RemoveIgnored(buffer, filetype, linters) abort
                                " Apply ignore lists for linters only if needed.
                                let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
                                let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
                                return !empty(l:ignore_config) || l:disable_lsp
                                \   ? ale#engine#ignore#Exclude(a:filetype, a:linters, l:ignore_config, l:disable_lsp)
                                \   : a:linters
                            endfunction
                            
                            " Given a buffer and linter, get the executable String for the linter.
    1              0.000003 function! ale#linter#GetExecutable(buffer, linter) abort
                                let l:Executable = a:linter.executable
                            
                                return type(l:Executable) is v:t_func
                                \   ? l:Executable(a:buffer)
                                \   : l:Executable
                            endfunction
                            
                            " Given a buffer and linter, get the command String for the linter.
    1              0.000003 function! ale#linter#GetCommand(buffer, linter) abort
                                let l:Command = a:linter.command
                            
                                return type(l:Command) is v:t_func ? l:Command(a:buffer) : l:Command
                            endfunction
                            
                            " Given a buffer and linter, get the address for connecting to the server.
    1              0.000003 function! ale#linter#GetAddress(buffer, linter) abort
                                let l:Address = a:linter.address
                            
                                return type(l:Address) is v:t_func ? l:Address(a:buffer) : l:Address
                            endfunction
                            
    1              0.000003 function! ale#linter#GetLanguage(buffer, linter) abort
                                let l:Language = a:linter.language
                            
                                return type(l:Language) is v:t_func ? l:Language(a:buffer) : l:Language
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/ale_linters/lua/luac.vim
Sourced 1 time
Total time:   0.000500
 Self time:   0.000085

count  total (s)   self (s)
                            " Author: Jon Xie https://github.com/xiejiangzhi
                            " Description: luac linter for lua files
                            
    1   0.000038   0.000016 call ale#Set('lua_luac_executable', 'luac')
                            
    1              0.000004 function! ale_linters#lua#luac#Handle(buffer, lines) abort
                                " Matches patterns line the following:
                                "
                                " luac: stdin:5: '=' expected near ')'
                                " luac: stdin:8: ')' expected (to close '(' at line 6) near '123'
                                let l:pattern = '\v^.*:(\d+): (.+)$'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    call add(l:output, {
                                    \   'lnum': l:match[1] + 0,
                                    \   'type': 'E',
                                    \   'text': l:match[2],
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    1   0.000426   0.000033 call ale#linter#Define('lua', {
                            \   'name': 'luac',
                            \   'executable': {b -> ale#Var(b, 'lua_luac_executable')},
                            \   'command': '%e -p -',
                            \   'output_stream': 'stderr',
                            \   'callback': 'ale_linters#lua#luac#Handle',
                            \})

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/ale_linters/lua/luacheck.vim
Sourced 1 time
Total time:   0.000553
 Self time:   0.000115

count  total (s)   self (s)
                            " Author: Sol Bekic https://github.com/s-ol
                            " Description: luacheck linter for lua files
                            
    1   0.000032   0.000013 call ale#Set('lua_luacheck_executable', 'luacheck')
    1   0.000025   0.000010 call ale#Set('lua_luacheck_options', '')
                            
    1              0.000005 function! ale_linters#lua#luacheck#GetCommand(buffer) abort
                                return '%e' . ale#Pad(ale#Var(a:buffer, 'lua_luacheck_options'))
                                \   . ' --formatter plain --codes --filename %s -'
                            endfunction
                            
    1              0.000004 function! ale_linters#lua#luacheck#Handle(buffer, lines) abort
                                " Matches patterns line the following:
                                "
                                " artal.lua:159:17: (W111) shadowing definition of loop variable 'i' on line 106
                                " artal.lua:182:7: (W213) unused loop variable 'i'
                                let l:pattern = '^.*:\(\d\+\):\(\d\+\): (\([WE]\)\(\d\+\)) \(.\+\)$'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    if !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                    \   && l:match[3] is# 'W'
                                    \   && index(range(611, 614), str2nr(l:match[4])) >= 0
                                        continue
                                    endif
                            
                                    call add(l:output, {
                                    \   'lnum': l:match[1] + 0,
                                    \   'col': l:match[2] + 0,
                                    \   'type': l:match[3],
                                    \   'code': l:match[3] . l:match[4],
                                    \   'text': l:match[5],
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    1   0.000438   0.000034 call ale#linter#Define('lua', {
                            \   'name': 'luacheck',
                            \   'executable': {b -> ale#Var(b, 'lua_luacheck_executable')},
                            \   'command': function('ale_linters#lua#luacheck#GetCommand'),
                            \   'callback': 'ale_linters#lua#luacheck#Handle',
                            \})

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/autoload/ale/engine.vim
Sourced 1 time
Total time:   0.000766
 Self time:   0.000766

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Backend execution and job management
                            "   Executes linters in the background, using NeoVim or Vim 8 jobs
                            
                            " Remapping of linter problems.
    1              0.000009 let g:ale_type_map = get(g:, 'ale_type_map', {})
    1              0.000006 let g:ale_filename_mappings = get(g:, 'ale_filename_mappings', {})
                            
    1              0.000004 if !has_key(s:, 'executable_cache_map')
    1              0.000004     let s:executable_cache_map = {}
    1              0.000001 endif
                            
    1              0.000004 function! ale#engine#CleanupEveryBuffer() abort
                                for l:key in keys(g:ale_buffer_info)
                                    " The key could be a filename or a buffer number, so try and
                                    " convert it to a number. We need a number for the other
                                    " functions.
                                    let l:buffer = str2nr(l:key)
                            
                                    if l:buffer > 0
                                        " Stop all jobs and clear the results for everything, and delete
                                        " all of the data we stored for the buffer.
                                        call ale#engine#Cleanup(l:buffer)
                                    endif
                                endfor
                            endfunction
                            
    1              0.000004 function! ale#engine#MarkLinterActive(info, linter) abort
                                let l:found = 0
                            
                                for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
                                endfor
                            
                                if !l:found
                                    call add(a:info.active_linter_list, a:linter)
                                endif
                            endfunction
                            
    1              0.000003 function! ale#engine#MarkLinterInactive(info, linter_name) abort
                                call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')
                            endfunction
                            
    1              0.000003 function! ale#engine#ResetExecutableCache() abort
                                let s:executable_cache_map = {}
                            endfunction
                            
                            " Check if files are executable, and if they are, remember that they are
                            " for subsequent calls. We'll keep checking until programs can be executed.
    1              0.000003 function! ale#engine#IsExecutable(buffer, executable) abort
                                if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
                                let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
                                if l:result isnot v:null
                                    return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
                                let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
                                if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
                                endif
                            
                                return l:result
                            endfunction
                            
    1              0.000003 function! ale#engine#InitBufferInfo(buffer) abort
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {
                                    \   'active_linter_list': [],
                                    \   'active_other_sources_list': [],
                                    \   'loclist': [],
                                    \}
                            
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " This function is documented and part of the public API.
                            "
                            " Return 1 if ALE is busy checking a given buffer
    1              0.000003 function! ale#engine#IsCheckingBuffer(buffer) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                return !empty(get(l:info, 'active_linter_list', []))
                                \   || !empty(get(l:info, 'active_other_sources_list', []))
                            endfunction
                            
    1              0.000004 function! ale#engine#HandleLoclist(linter_name, buffer, loclist, from_other_source) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
                                    call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
                                endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
                                let l:linter_loclist = ale#engine#FixLocList(
                                \   a:buffer,
                                \   a:linter_name,
                                \   a:from_other_source,
                                \   a:loclist,
                                \)
                            
                                " Remove previous items for this linter.
                                call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
                                if !empty(l:linter_loclist)
                                    " Add the new items.
                                    call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
                                    call sort(l:info.loclist, 'ale#util#LocItemCompare')
                                endif
                            
                                if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                call ale#engine#SetResults(a:buffer, l:info.loclist)
                            endfunction
                            
    1              0.000005 function! s:HandleExit(job_info, buffer, output, data) abort
                                let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
                                if empty(l:buffer_info)
                                    return
                                endif
                            
                                let l:linter = a:job_info.linter
                                let l:executable = a:job_info.executable
                            
                                " Remove this job from the list.
                                call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
                                if ale#util#InSandbox()
                                    return
                                endif
                            
                                if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
                                endif
                            
                                try
                                    let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
                                endtry
                            
                                call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)
                            endfunction
                            
    1              0.000003 function! ale#engine#SetResults(buffer, loclist) abort
                                let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
                                if g:ale_set_signs
                                    call ale#sign#SetSigns(a:buffer, a:loclist)
                                endif
                            
                                if g:ale_set_quickfix || g:ale_set_loclist
                                    call ale#list#SetLists(a:buffer, a:loclist)
                                endif
                            
                                if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
                                endif
                            
                                if g:ale_set_highlights
                                    call ale#highlight#SetHighlights(a:buffer, a:loclist)
                                endif
                            
                                if l:linting_is_done
                                    if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#cursor#EchoCursorWarning()
                                    endif
                            
                                    if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
                                    endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
                                    call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
                                    call setbufvar(
                                    \   a:buffer,
                                    \   'ale_linted',
                                    \   getbufvar(a:buffer, 'ale_linted', 0) + 1
                                    \)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
                                    call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
                                    silent doautocmd <nomodeline> User ALELintPost
                                endif
                            endfunction
                            
    1              0.000004 function! s:RemapItemTypes(type_map, loclist) abort
                                for l:item in a:loclist
                                    let l:key = l:item.type
                                    \   . (get(l:item, 'sub_type', '') is# 'style' ? 'S' : '')
                                    let l:new_key = get(a:type_map, l:key, '')
                            
                                    if l:new_key is# 'E'
                                    \|| l:new_key is# 'ES'
                                    \|| l:new_key is# 'W'
                                    \|| l:new_key is# 'WS'
                                    \|| l:new_key is# 'I'
                                        let l:item.type = l:new_key[0]
                            
                                        if l:new_key is# 'ES' || l:new_key is# 'WS'
                                            let l:item.sub_type = 'style'
                                        elseif has_key(l:item, 'sub_type')
                                            call remove(l:item, 'sub_type')
                                        endif
                                    endif
                                endfor
                            endfunction
                            
    1              0.000005 function! ale#engine#FixLocList(buffer, linter_name, from_other_source, loclist) abort
                                let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                            
                                if !empty(l:mappings)
                                    " We need to apply reverse filename mapping here.
                                    let l:mappings = ale#filename_mapping#Invert(l:mappings)
                                endif
                            
                                let l:bufnr_map = {}
                                let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
                                let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
                                for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
                                    let l:item = {
                                    \   'bufnr': a:buffer,
                                    \   'text': l:old_item.text,
                                    \   'lnum': str2nr(l:old_item.lnum),
                                    \   'col': str2nr(get(l:old_item, 'col', 0)),
                                    \   'vcol': 0,
                                    \   'type': get(l:old_item, 'type', 'E'),
                                    \   'nr': get(l:old_item, 'nr', -1),
                                    \   'linter_name': a:linter_name,
                                    \}
                            
                                    if a:from_other_source
                                        let l:item.from_other_source = 1
                                    endif
                            
                                    if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
                                    endif
                            
                                    let l:old_name = get(l:old_item, 'filename', '')
                            
                                    " Map parsed from output to local filesystem files.
                                    if !empty(l:old_name) && !empty(l:mappings)
                                        let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
                                    endif
                            
                                    if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_name
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
                                    if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
                                    if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
                                    if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
                                    if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
                                    if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line
                                            \   ? getbufline(a:buffer, l:item.end_lnum)[0]
                                            \   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
                                    call add(l:new_loclist, l:item)
                                endfor
                            
                                let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
                                if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
                                return l:new_loclist
                            endfunction
                            
                            " Given part of a command, replace any % with %%, so that no characters in
                            " the string will be replaced with filenames, etc.
    1              0.000004 function! ale#engine#EscapeCommandPart(command_part) abort
                                " TODO: Emit deprecation warning here later.
                                return ale#command#EscapeCommandPart(a:command_part)
                            endfunction
                            
                            " Run a job.
                            "
                            " Returns 1 when a job was started successfully.
    1              0.000004 function! s:RunJob(command, options) abort
                                if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {
                                    \   command -> s:RunJob(command, a:options)
                                    \}
                            
                                    return 1
                                endif
                            
                                let l:command = a:command
                            
                                if empty(l:command)
                                    return 0
                                endif
                            
                                let l:executable = a:options.executable
                                let l:buffer = a:options.buffer
                                let l:linter = a:options.linter
                                let l:output_stream = a:options.output_stream
                                let l:read_buffer = a:options.read_buffer && !a:options.lint_file
                                let l:info = g:ale_buffer_info[l:buffer]
                            
                                let l:Callback = function('s:HandleExit', [{
                                \   'linter': l:linter,
                                \   'executable': l:executable,
                                \}])
                                let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {
                                \   'output_stream': l:output_stream,
                                \   'executable': l:executable,
                                \   'read_buffer': l:read_buffer,
                                \   'log_output': 1,
                                \   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:linter.name),
                                \})
                            
                                " Only proceed if the job is being run.
                                if empty(l:result)
                                    return 0
                                endif
                            
                                call ale#engine#MarkLinterActive(l:info, l:linter)
                            
                                silent doautocmd <nomodeline> User ALEJobStarted
                            
                                return 1
                            endfunction
                            
    1              0.000004 function! s:StopCurrentJobs(buffer, clear_lint_file_jobs, linter_slots) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                                call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
                                if a:clear_lint_file_jobs
                                    call ale#command#StopJobs(a:buffer, 'file_linter')
                                    let l:info.active_linter_list = []
                                else
                                    let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
                                    for [l:lint_file, l:linter] in a:linter_slots
                                        if l:lint_file is 1
                                            let l:lint_file_map[l:linter.name] = 1
                                        endif
                                    endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
                                    call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
                                endif
                            endfunction
                            
    1              0.000003 function! ale#engine#Stop(buffer) abort
                                call s:StopCurrentJobs(a:buffer, 1, [])
                            endfunction
                            
    1              0.000004 function! s:RemoveProblemsForDisabledLinters(buffer, linters) abort
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
                                let l:name_map = {}
                            
                                for l:linter in a:linters
                                    let l:name_map[l:linter.name] = 1
                                endfor
                            
                                call filter(
                                \   get(g:ale_buffer_info[a:buffer], 'loclist', []),
                                \   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',
                                \)
                            endfunction
                            
    1              0.000004 function! s:AddProblemsFromOtherBuffers(buffer, linters) abort
                                let l:filename = expand('#' . a:buffer . ':p')
                                let l:loclist = []
                                let l:name_map = {}
                            
                                " Build a map of the active linters.
                                for l:linter in a:linters
                                    let l:name_map[l:linter.name] = 1
                                endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
                                for l:info in values(g:ale_buffer_info)
                                    for l:item in l:info.loclist
                                        if has_key(l:item, 'filename')
                                        \&& l:item.filename is# l:filename
                                        \&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
                                        endif
                                    endfor
                                endfor
                            
                                if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
                                endif
                            endfunction
                            
    1              0.000004 function! s:RunIfExecutable(buffer, linter, lint_file, executable) abort
                                if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {
                                    \   executable -> s:RunIfExecutable(
                                    \       a:buffer,
                                    \       a:linter,
                                    \       a:lint_file,
                                    \       executable
                                    \   )
                                    \}
                            
                                    return 1
                                endif
                            
                                if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
                                    let l:job_type = a:lint_file ? 'file_linter' : 'linter'
                                    call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                                    let l:options = {
                                    \   'executable': a:executable,
                                    \   'buffer': a:buffer,
                                    \   'linter': a:linter,
                                    \   'output_stream': get(a:linter, 'output_stream', 'stdout'),
                                    \   'read_buffer': a:linter.read_buffer,
                                    \   'lint_file': a:lint_file,
                                    \}
                            
                                    return s:RunJob(l:command, l:options)
                                endif
                            
                                return 0
                            endfunction
                            
                            " Run a linter for a buffer.
                            "
                            " Returns 1 if the linter was successfully run.
    1              0.000003 function! s:RunLinter(buffer, linter, lint_file) abort
                                if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
                                else
                                    let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
                                    return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000003 function! s:GetLintFileSlots(buffer, linters) abort
                                let l:linter_slots = []
                            
                                for l:linter in a:linters
                                    let l:LintFile = l:linter.lint_file
                            
                                    if type(l:LintFile) is v:t_func
                                        let l:LintFile = l:LintFile(a:buffer)
                                    endif
                            
                                    call add(l:linter_slots, [l:LintFile, l:linter])
                                endfor
                            
                                return l:linter_slots
                            endfunction
                            
    1              0.000003 function! s:GetLintFileValues(slots, Callback) abort
                                let l:deferred_list = []
                                let l:new_slots = []
                            
                                for [l:lint_file, l:linter] in a:slots
                                    while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
                                        let l:lint_file = l:lint_file.value
                                    endwhile
                            
                                    if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
                                        call add(l:deferred_list, l:lint_file)
                                    else
                                        " If we have the value now, coerce it to 0 or 1.
                                        let l:lint_file = l:lint_file is 1
                                    endif
                            
                                    call add(l:new_slots, [l:lint_file, l:linter])
                                endfor
                            
                                if !empty(l:deferred_list)
                                    for l:deferred in l:deferred_list
                                        let l:deferred.result_callback =
                                        \   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                    endfor
                                else
                                    call a:Callback(l:new_slots)
                                endif
                            endfunction
                            
    1              0.000009 function! s:RunLinters(
                            \   buffer,
                            \   linters,
                            \   slots,
                            \   should_lint_file,
                            \   new_buffer,
                            \) abort
                                call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
                                call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
                                let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                silent doautocmd <nomodeline> User ALELintPre
                            
                                for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
                                    if !l:lint_file || a:should_lint_file
                                        if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
                                            let l:can_clear_results = 0
                                        endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
                                endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
                                if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif a:new_buffer
                                    call s:AddProblemsFromOtherBuffers(
                                    \   a:buffer,
                                    \   map(copy(a:slots), 'v:val[1]')
                                    \)
                                endif
                            endfunction
                            
    1              0.000004 function! ale#engine#RunLinters(buffer, linters, should_lint_file) abort
                                " Initialise the buffer information if needed.
                                let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
                                call s:GetLintFileValues(
                                \   s:GetLintFileSlots(a:buffer, a:linters),
                                \   {
                                \       slots -> s:RunLinters(
                                \           a:buffer,
                                \           a:linters,
                                \           slots,
                                \           a:should_lint_file,
                                \           l:new_buffer,
                                \       )
                                \   }
                                \)
                            endfunction
                            
                            " Clean up a buffer.
                            "
                            " This function will stop all current jobs for the buffer,
                            " clear the state of everything, and remove the Dictionary for managing
                            " the buffer.
    1              0.000003 function! ale#engine#Cleanup(buffer) abort
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
                                if get(v:, 'exiting', v:null) isnot v:null
                                    return
                                endif
                            
                                if exists('*ale#lsp#CloseDocument')
                                    call ale#lsp#CloseDocument(a:buffer)
                                endif
                            
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
                                call ale#engine#RunLinters(a:buffer, [], 1)
                            
                                call remove(g:ale_buffer_info, a:buffer)
                            endfunction
                            
                            " Given a buffer number, return the warnings and errors for a given buffer.
    1              0.000003 function! ale#engine#GetLoclist(buffer) abort
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    return []
                                endif
                            
                                return g:ale_buffer_info[a:buffer].loclist
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/autoload/ale/command.vim
Sourced 1 time
Total time:   0.000430
 Self time:   0.000430

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Functions for formatting command strings, running commands, and
                            "   managing files during linting and fixing cycles.
                            
                            " This dictionary holds lists of files and directories to remove later.
    1              0.000007 if !exists('s:buffer_data')
    1              0.000004     let s:buffer_data = {}
    1              0.000001 endif
                            
                            " Used to get the data in tests.
    1              0.000003 function! ale#command#GetData() abort
                                return deepcopy(s:buffer_data)
                            endfunction
                            
    1              0.000003 function! ale#command#ClearData() abort
                                let s:buffer_data = {}
                            endfunction
                            
    1              0.000002 function! ale#command#InitData(buffer) abort
                                if !has_key(s:buffer_data, a:buffer)
                                    let s:buffer_data[a:buffer] = {
                                    \   'jobs': {},
                                    \   'file_list': [],
                                    \   'directory_list': [],
                                    \}
                                endif
                            endfunction
                            
    1              0.000003 function! ale#command#ManageFile(buffer, file) abort
                                call ale#command#InitData(a:buffer)
                                call add(s:buffer_data[a:buffer].file_list, a:file)
                            endfunction
                            
    1              0.000003 function! ale#command#ManageDirectory(buffer, directory) abort
                                call ale#command#InitData(a:buffer)
                                call add(s:buffer_data[a:buffer].directory_list, a:directory)
                            endfunction
                            
    1              0.000003 function! ale#command#CreateFile(buffer) abort
                                " This variable can be set to 1 in tests to stub this out.
                                if get(g:, 'ale_create_dummy_temporary_file')
                                    return 'TEMP'
                                endif
                            
                                let l:temporary_file = ale#util#Tempname()
                                call ale#command#ManageFile(a:buffer, l:temporary_file)
                            
                                return l:temporary_file
                            endfunction
                            
                            " Create a new temporary directory and manage it in one go.
    1              0.000003 function! ale#command#CreateDirectory(buffer) abort
                                " This variable can be set to 1 in tests to stub this out.
                                if get(g:, 'ale_create_dummy_temporary_file')
                                    return 'TEMP_DIR'
                                endif
                            
                                let l:temporary_directory = ale#util#Tempname()
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
                                call mkdir(l:temporary_directory, '', 0750)
                                call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                            
                                return l:temporary_directory
                            endfunction
                            
    1              0.000003 function! ale#command#RemoveManagedFiles(buffer) abort
                                let l:info = get(s:buffer_data, a:buffer, {})
                            
                                if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
                                    if ale#util#InSandbox()
                                        return
                                    endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
                                    for l:filename in l:info.file_list
                                        call delete(l:filename)
                                    endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
                                    for l:directory in l:info.directory_list
                                        call delete(l:directory, 'rf')
                                    endfor
                            
                                    call remove(s:buffer_data, a:buffer)
                                endif
                            endfunction
                            
    1              0.000003 function! ale#command#CreateTempFile(buffer, temporary_file, input) abort
                                if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
                                endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
                                let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
                                let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
                                call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
                                call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
                                call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
                                return 1
                            endfunction
                            
    1              0.000004 function! s:TemporaryFilename(buffer) abort
                                let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
                                return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename
                            endfunction
                            
                            " Given part of a command, replace any % with %%, so that no characters in
                            " the string will be replaced with filenames, etc.
    1              0.000003 function! ale#command#EscapeCommandPart(command_part) abort
                                return substitute(a:command_part, '%', '%%', 'g')
                            endfunction
                            
                            " Format a filename, converting it with filename mappings, if non-empty,
                            " and escaping it for putting into a command string.
                            "
                            " The filename can be modified.
    1              0.000004 function! s:FormatFilename(filename, mappings, modifiers) abort
                                let l:filename = a:filename
                            
                                if !empty(a:mappings)
                                    let l:filename = ale#filename_mapping#Map(l:filename, a:mappings)
                                endif
                            
                                if !empty(a:modifiers)
                                    let l:filename = fnamemodify(l:filename, a:modifiers)
                                endif
                            
                                return ale#Escape(l:filename)
                            endfunction
                            
                            " Given a command string, replace every...
                            " %s -> with the current filename
                            " %t -> with the name of an unused file in a temporary directory
                            " %% -> with a literal %
    1              0.000007 function! ale#command#FormatCommand(
                            \   buffer,
                            \   executable,
                            \   command,
                            \   pipe_file_if_needed,
                            \   input,
                            \   mappings,
                            \) abort
                                let l:temporary_file = ''
                                let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
                                let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
                                if !empty(a:executable) && l:command =~# '%e'
                                    let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
                                endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
                                if l:command =~# '%s'
                                    let l:filename = fnamemodify(bufname(a:buffer), ':p')
                                    let l:command = substitute(
                                    \   l:command,
                                    \   '\v\%s(%(:h|:t|:r|:e)*)',
                                    \   '\=s:FormatFilename(l:filename, a:mappings, submatch(1))',
                                    \   'g'
                                    \)
                                endif
                            
                                if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(
                                    \   l:command,
                                    \   '\v\%t(%(:h|:t|:r|:e)*)',
                                    \   '\=s:FormatFilename(l:temporary_file, a:mappings, submatch(1))',
                                    \   'g'
                                    \)
                                endif
                            
                                " Finish formatting so %% becomes %.
                                let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
                                if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
                                endif
                            
                                let l:file_created = ale#command#CreateTempFile(
                                \   a:buffer,
                                \   l:temporary_file,
                                \   a:input,
                                \)
                            
                                return [l:temporary_file, l:command, l:file_created]
                            endfunction
                            
    1              0.000003 function! ale#command#StopJobs(buffer, job_type) abort
                                let l:info = get(s:buffer_data, a:buffer, {})
                            
                                if !empty(l:info)
                                    let l:new_map = {}
                            
                                    for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
                                    endfor
                            
                                    let l:info.jobs = l:new_map
                                endif
                            endfunction
                            
    1              0.000004 function! s:GatherOutput(line_list, job_id, line) abort
                                call add(a:line_list, a:line)
                            endfunction
                            
    1              0.000004 function! s:ExitCallback(buffer, line_list, Callback, data) abort
                                if !has_key(s:buffer_data, a:buffer)
                                    return
                                endif
                            
                                let l:jobs = s:buffer_data[a:buffer].jobs
                            
                                if !has_key(l:jobs, a:data.job_id)
                                    return
                                endif
                            
                                let l:job_type = remove(l:jobs, a:data.job_id)
                            
                                if g:ale_history_enabled
                                    call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
                                    if g:ale_history_log_output && a:data.log_output is 1
                                        call ale#history#RememberOutput(
                                        \   a:buffer,
                                        \   a:data.job_id,
                                        \   a:line_list[:]
                                        \)
                                    endif
                                endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
                                call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                                let l:value = a:Callback(a:buffer, a:line_list, {
                                \   'exit_code': a:data.exit_code,
                                \   'temporary_file': a:data.temporary_file,
                                \})
                            
                                let l:result = a:data.result
                                let l:result.value = l:value
                            
                                if get(l:result, 'result_callback', v:null) isnot v:null
                                    call call(l:result.result_callback, [l:value])
                                endif
                            endfunction
                            
    1              0.000003 function! ale#command#Run(buffer, command, Callback, ...) abort
                                let l:options = get(a:000, 0, {})
                            
                                if len(a:000) > 1
                                    throw 'Too many arguments!'
                                endif
                            
                                let l:output_stream = get(l:options, 'output_stream', 'stdout')
                                let l:line_list = []
                            
                                let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(
                                \   a:buffer,
                                \   get(l:options, 'executable', ''),
                                \   a:command,
                                \   get(l:options, 'read_buffer', 0),
                                \   get(l:options, 'input', v:null),
                                \   get(l:options, 'filename_mappings', []),
                                \)
                                let l:command = ale#job#PrepareCommand(a:buffer, l:command)
                                let l:job_options = {
                                \   'exit_cb': {job_id, exit_code -> s:ExitCallback(
                                \       a:buffer,
                                \       l:line_list,
                                \       a:Callback,
                                \       {
                                \           'job_id': job_id,
                                \           'exit_code': exit_code,
                                \           'temporary_file': l:temporary_file,
                                \           'log_output': get(l:options, 'log_output', 1),
                                \           'result': l:result,
                                \       }
                                \   )},
                                \   'mode': 'nl',
                                \}
                            
                                if l:output_stream is# 'stdout'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                endif
                            
                                let l:status = 'failed'
                            
                                if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
                                elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
                                else
                                    let l:job_id = ale#job#Start(l:command, l:job_options)
                                endif
                            
                                if l:job_id
                                    let l:status = 'started'
                                    let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
                                    call ale#command#InitData(a:buffer)
                                    let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
                                endif
                            
                                if !l:job_id
                                    return 0
                                endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The original command here is used in tests.
                                let l:result = {
                                \   '_deferred_job_id': l:job_id,
                                \   'executable': get(l:options, 'executable', ''),
                                \   'command': a:command,
                                \}
                            
                                if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(
                                        \   g:ale_run_synchronously_callbacks,
                                        \   {exit_code, output -> [
                                        \       extend(l:line_list, output),
                                        \       l:job_options.exit_cb(l:job_id, exit_code),
                                        \   ]}
                                        \)
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(
                                        \   type(l:command) is v:t_list
                                        \       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])
                                        \       : l:command
                                        \))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')
                                        \&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(
                                        \   g:ale_run_synchronously_callbacks,
                                        \   {-> l:job_options.exit_cb(l:job_id, v:shell_error)}
                                        \)
                                    endif
                                endif
                            
                                return l:result
                            endfunction
                            
    1              0.000004 function! ale#command#IsDeferred(value) abort
                                return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/autoload/ale/history.vim
Sourced 1 time
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Tools for managing command history
                            
                            " A flag for controlling the maximum size of the command history to store.
    1              0.000010 let g:ale_max_buffer_history_size = get(g:, 'ale_max_buffer_history_size', 20)
                            
                            " Return a shallow copy of the command history for a given buffer number.
    1              0.000004 function! ale#history#Get(buffer) abort
                                return copy(getbufvar(a:buffer, 'ale_history', []))
                            endfunction
                            
    1              0.000004 function! ale#history#Add(buffer, status, job_id, command) abort
                                if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
                                let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
                                if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
                                endif
                            
                                call add(l:history, {
                                \   'status': a:status,
                                \   'job_id': a:job_id,
                                \   'command': a:command,
                                \})
                            
                                call setbufvar(a:buffer, 'ale_history', l:history)
                            endfunction
                            
    1              0.000004 function! s:FindHistoryItem(buffer, job_id) abort
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
                                for l:obj in reverse(ale#history#Get(a:buffer))
                                    if l:obj.job_id == a:job_id
                                        return l:obj
                                    endif
                                endfor
                            
                                return {}
                            endfunction
                            
                            " Set an exit code for a command which finished.
    1              0.000004 function! ale#history#SetExitCode(buffer, job_id, exit_code) abort
                                let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
                                let l:obj.exit_code = a:exit_code
                                let l:obj.status = 'finished'
                            endfunction
                            
                            " Set the output for a command which finished.
    1              0.000003 function! ale#history#RememberOutput(buffer, job_id, output) abort
                                let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                let l:obj.output = a:output
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/autoload/ale/job.vim
Sourced 1 time
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: APIs for working with Asynchronous jobs, with an API normalised
                            " between Vim 8 and NeoVim.
                            "
                            " Important functions are described below. They are:
                            "
                            "   ale#job#Start(command, options) -> job_id
                            "   ale#job#IsRunning(job_id) -> 1 if running, 0 otherwise.
                            "   ale#job#Stop(job_id)
                            
                            " A setting for wrapping commands.
    1              0.000009 let g:ale_command_wrapper = get(g:, 'ale_command_wrapper', '')
                            
    1              0.000004 if !has_key(s:, 'job_map')
    1              0.000003     let s:job_map = {}
    1              0.000001 endif
                            
                            " A map from timer IDs to jobs, for tracking jobs that need to be killed
                            " with SIGKILL if they don't terminate right away.
    1              0.000010 if !has_key(s:, 'job_kill_timers')
    1              0.000003     let s:job_kill_timers = {}
    1              0.000015 endif
                            
    1              0.000008 function! s:KillHandler(timer) abort
                                let l:job = remove(s:job_kill_timers, a:timer)
                                call job_stop(l:job, 'kill')
                            endfunction
                            
    1              0.000003 function! s:NeoVimCallback(job, data, event) abort
                                let l:info = s:job_map[a:job]
                            
                                if a:event is# 'stdout'
                                    let l:info.out_cb_line = ale#util#JoinNeovimOutput(
                                    \   a:job,
                                    \   l:info.out_cb_line,
                                    \   a:data,
                                    \   l:info.mode,
                                    \   ale#util#GetFunction(l:info.out_cb),
                                    \)
                                elseif a:event is# 'stderr'
                                    let l:info.err_cb_line = ale#util#JoinNeovimOutput(
                                    \   a:job,
                                    \   l:info.err_cb_line,
                                    \   a:data,
                                    \   l:info.mode,
                                    \   ale#util#GetFunction(l:info.err_cb),
                                    \)
                                else
                                    if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
                                    endif
                            
                                    if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
                                    endif
                            
                                    try
                                        call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
                                    finally
                                        " Automatically forget about the job after it's done.
                                        if has_key(s:job_map, a:job)
                                            call remove(s:job_map, a:job)
                                        endif
                                    endtry
                                endif
                            endfunction
                            
    1              0.000002 function! s:VimOutputCallback(channel, data) abort
                                let l:job = ch_getjob(a:channel)
                                let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
                                if l:job_id > 0 && has_key(s:job_map, l:job_id)
                                    call ale#util#GetFunction(s:job_map[l:job_id].out_cb)(l:job_id, a:data)
                                endif
                            endfunction
                            
    1              0.000002 function! s:VimErrorCallback(channel, data) abort
                                let l:job = ch_getjob(a:channel)
                                let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
                                if l:job_id > 0 && has_key(s:job_map, l:job_id)
                                    call ale#util#GetFunction(s:job_map[l:job_id].err_cb)(l:job_id, a:data)
                                endif
                            endfunction
                            
    1              0.000002 function! s:VimCloseCallback(channel) abort
                                let l:job = ch_getjob(a:channel)
                                let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                                let l:info = get(s:job_map, l:job_id, {})
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                " job_status() can trigger the exit handler.
                                " The channel can close before the job has exited.
                                if job_status(l:job) is# 'dead'
                                    try
                                        if !empty(l:info) && has_key(l:info, 'exit_cb')
                                            " We have to remove the callback, so we don't call it twice.
                                            call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, get(l:info, 'exit_code', 1))
                                        endif
                                    finally
                                        " Automatically forget about the job after it's done.
                                        if has_key(s:job_map, l:job_id)
                                            call remove(s:job_map, l:job_id)
                                        endif
                                    endtry
                                endif
                            endfunction
                            
    1              0.000002 function! s:VimExitCallback(job, exit_code) abort
                                let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
                                let l:info = get(s:job_map, l:job_id, {})
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                let l:info.exit_code = a:exit_code
                            
                                " The program can exit before the data has finished being read.
                                if ch_status(job_getchannel(a:job)) is# 'closed'
                                    try
                                        if !empty(l:info) && has_key(l:info, 'exit_cb')
                                            " We have to remove the callback, so we don't call it twice.
                                            call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, a:exit_code)
                                        endif
                                    finally
                                        " Automatically forget about the job after it's done.
                                        if has_key(s:job_map, l:job_id)
                                            call remove(s:job_map, l:job_id)
                                        endif
                                    endtry
                                endif
                            endfunction
                            
    1              0.000002 function! ale#job#ParseVim8ProcessID(job_string) abort
                                return matchstr(a:job_string, '\d\+') + 0
                            endfunction
                            
    1              0.000002 function! ale#job#ValidateArguments(command, options) abort
                                if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif
                            endfunction
                            
    1              0.000002 function! s:PrepareWrappedCommand(original_wrapper, command) abort
                                let l:match = matchlist(a:command, '\v^(.*(\&\&|;)) *(.*)$')
                                let l:prefix = ''
                                let l:command = a:command
                            
                                if !empty(l:match)
                                    let l:prefix = l:match[1] . ' '
                                    let l:command = l:match[3]
                                endif
                            
                                let l:format = a:original_wrapper
                            
                                if l:format =~# '%@'
                                    let l:wrapped = substitute(l:format, '%@', ale#Escape(l:command), '')
                                else
                                    if l:format !~# '%\*'
                                        let l:format .= ' %*'
                                    endif
                            
                                    let l:wrapped = substitute(l:format, '%\*', l:command, '')
                                endif
                            
                                return l:prefix . l:wrapped
                            endfunction
                            
    1              0.000002 function! ale#job#PrepareCommand(buffer, command) abort
                                let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
                                let l:command = !empty(l:wrapper)
                                \ ? s:PrepareWrappedCommand(l:wrapper, a:command)
                                \ : a:command
                            
                                " If a custom shell is specified, use that.
                                if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
                                endif
                            
                                if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
                                endif
                            
                                if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
                                endif
                            
                                return split(&shell) + split(&shellcmdflag) + [l:command]
                            endfunction
                            
                            " Start a job with options which are agnostic to Vim and NeoVim.
                            "
                            " The following options are accepted:
                            "
                            " out_cb  - A callback for receiving stdin.  Arguments: (job_id, data)
                            " err_cb  - A callback for receiving stderr. Arguments: (job_id, data)
                            " exit_cb - A callback for program exit.     Arguments: (job_id, status_code)
                            " mode    - A mode for I/O. Can be 'nl' for split lines or 'raw'.
    1              0.000002 function! ale#job#Start(command, options) abort
                                call ale#job#ValidateArguments(a:command, a:options)
                            
                                let l:job_info = copy(a:options)
                                let l:job_options = {}
                            
                                if has('nvim')
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        let l:job_options.on_exit = function('s:NeoVimCallback')
                                    endif
                            
                                    let l:job_info.job = jobstart(a:command, l:job_options)
                                    let l:job_id = l:job_info.job
                                else
                                    let l:job_options = {
                                    \   'in_mode': l:job_info.mode,
                                    \   'out_mode': l:job_info.mode,
                                    \   'err_mode': l:job_info.mode,
                                    \}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
                                endif
                            
                                if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
                                    let s:job_map[l:job_id] = l:job_info
                                endif
                            
                                return l:job_id
                            endfunction
                            
                            " Force running commands in a Windows CMD command line.
                            " This means the same command syntax works everywhere.
    1              0.000002 function! ale#job#StartWithCmd(command, options) abort
                                let l:shell = &l:shell
                                let l:shellcmdflag = &l:shellcmdflag
                                let &l:shell = 'cmd'
                                let &l:shellcmdflag = '/c'
                            
                                try
                                    let l:job_id = ale#job#Start(a:command, a:options)
                                finally
                                    let &l:shell = l:shell
                                    let &l:shellcmdflag = l:shellcmdflag
                                endtry
                            
                                return l:job_id
                            endfunction
                            
                            " Send raw data to the job.
    1              0.000002 function! ale#job#SendRaw(job_id, string) abort
                                if has('nvim')
                                    call jobsend(a:job_id, a:string)
                                else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    if ch_status(l:job) is# 'open'
                                        call ch_sendraw(job_getchannel(l:job), a:string)
                                    endif
                                endif
                            endfunction
                            
                            " Given a job ID, return 1 if the job is currently running.
                            " Invalid job IDs will be ignored.
    1              0.000002 function! ale#job#IsRunning(job_id) abort
                                if has('nvim')
                                    try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
                                        call jobpid(a:job_id)
                            
                                        return 1
                                    catch
                                    endtry
                                elseif has_key(s:job_map, a:job_id)
                                    let l:job = s:job_map[a:job_id].job
                            
                                    return job_status(l:job) is# 'run'
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000002 function! ale#job#HasOpenChannel(job_id) abort
                                if ale#job#IsRunning(a:job_id)
                                    if has('nvim')
                                        " TODO: Implement a check for NeoVim.
                                        return 1
                                    endif
                            
                                    " Check if the Job's channel can be written to.
                                    return ch_status(s:job_map[a:job_id].job) is# 'open'
                                endif
                            
                                return 0
                            endfunction
                            
                            " Given a Job ID, stop that job.
                            " Invalid job IDs will be ignored.
    1              0.000001 function! ale#job#Stop(job_id) abort
                                if !has_key(s:job_map, a:job_id)
                                    return
                                endif
                            
                                if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
                                    silent! call jobstop(a:job_id)
                                else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
                                    if ch_status(job_getchannel(l:job)) is# 'open'
                                        call ch_close_in(job_getchannel(l:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
                                    call job_stop(l:job)
                            
                                    if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
                                endif
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/autoload/ale/sign.vim
Sourced 1 time
Total time:   0.000951
 Self time:   0.000782

count  total (s)   self (s)
    1              0.000005 scriptencoding utf8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Draws error and warning signs into signcolumn
                            
                            " This flag can be set to some integer to control the maximum number of signs
                            " that ALE will set.
    1              0.000008 let g:ale_max_signs = get(g:, 'ale_max_signs', -1)
                            " This flag can be set to 1 to enable changing the sign column colors when
                            " there are errors.
    1              0.000004 let g:ale_change_sign_column_color = get(g:, 'ale_change_sign_column_color', 0)
                            " These variables dictate what signs are used to indicate errors and warnings.
    1              0.000005 let g:ale_sign_error = get(g:, 'ale_sign_error', '>>')
    1              0.000004 let g:ale_sign_style_error = get(g:, 'ale_sign_style_error', g:ale_sign_error)
    1              0.000003 let g:ale_sign_warning = get(g:, 'ale_sign_warning', '--')
    1              0.000004 let g:ale_sign_style_warning = get(g:, 'ale_sign_style_warning', g:ale_sign_warning)
    1              0.000003 let g:ale_sign_info = get(g:, 'ale_sign_info', g:ale_sign_warning)
    1              0.000003 let g:ale_sign_priority = get(g:, 'ale_sign_priority', 30)
                            " This variable sets an offset which can be set for sign IDs.
                            " This ID can be changed depending on what IDs are set for other plugins.
                            " The dummy sign will use the ID exactly equal to the offset.
    1              0.000003 let g:ale_sign_offset = get(g:, 'ale_sign_offset', 1000000)
                            " This flag can be set to 1 to keep sign gutter always open
    1              0.000003 let g:ale_sign_column_always = get(g:, 'ale_sign_column_always', 0)
    1              0.000004 let g:ale_sign_highlight_linenrs = get(g:, 'ale_sign_highlight_linenrs', 0)
                            
    1              0.000007 let s:supports_sign_groups = has('nvim-0.4.2') || has('patch-8.1.614')
                            
    1              0.000037 if !hlexists('ALEErrorSign')
                                highlight link ALEErrorSign error
    1              0.000001 endif
                            
    1              0.000030 if !hlexists('ALEStyleErrorSign')
    1              0.000035     highlight link ALEStyleErrorSign ALEErrorSign
    1              0.000001 endif
                            
    1              0.000014 if !hlexists('ALEWarningSign')
                                highlight link ALEWarningSign todo
    1              0.000001 endif
                            
    1              0.000016 if !hlexists('ALEStyleWarningSign')
    1              0.000032     highlight link ALEStyleWarningSign ALEWarningSign
    1              0.000001 endif
                            
    1              0.000013 if !hlexists('ALEInfoSign')
                                highlight link ALEInfoSign ALEWarningSign
    1              0.000001 endif
                            
    1              0.000016 if !hlexists('ALESignColumnWithErrors')
    1              0.000032     highlight link ALESignColumnWithErrors error
    1              0.000001 endif
                            
    1              0.000003 function! ale#sign#SetUpDefaultColumnWithoutErrorsHighlight() abort
                                let l:verbose = &verbose
                                set verbose=0
                                redir => l:output
                                    0verbose silent highlight SignColumn
                                redir end
                                let &verbose = l:verbose
                            
                                let l:highlight_syntax = join(split(l:output)[2:])
                                let l:match = matchlist(l:highlight_syntax, '\vlinks to (.+)$')
                            
                                if !empty(l:match)
                                    execute 'highlight link ALESignColumnWithoutErrors ' . l:match[1]
                                elseif l:highlight_syntax isnot# 'cleared'
                                    execute 'highlight ALESignColumnWithoutErrors ' . l:highlight_syntax
                                endif
                            endfunction
                            
    1              0.000017 if !hlexists('ALESignColumnWithoutErrors')
    1   0.000137   0.000015     call ale#sign#SetUpDefaultColumnWithoutErrorsHighlight()
    1              0.000001 endif
                            
                            " Spaces and backslashes need to be escaped for signs.
    1              0.000003 function! s:EscapeSignText(sign_text) abort
                                return substitute(substitute(a:sign_text, ' *$', '', ''), '\\\| ', '\\\0', 'g')
                            endfunction
                            
                            " Signs show up on the left for error markers.
    1   0.000056   0.000043 execute 'sign define ALEErrorSign text=' . s:EscapeSignText(g:ale_sign_error)
                            \   . ' texthl=ALEErrorSign linehl=ALEErrorLine'
    1   0.000034   0.000025 execute 'sign define ALEStyleErrorSign text=' .  s:EscapeSignText(g:ale_sign_style_error)
                            \   . ' texthl=ALEStyleErrorSign linehl=ALEErrorLine'
    1   0.000043   0.000034 execute 'sign define ALEWarningSign text=' . s:EscapeSignText(g:ale_sign_warning)
                            \   . ' texthl=ALEWarningSign linehl=ALEWarningLine'
    1   0.000032   0.000024 execute 'sign define ALEStyleWarningSign text=' . s:EscapeSignText(g:ale_sign_style_warning)
                            \   . ' texthl=ALEStyleWarningSign linehl=ALEWarningLine'
    1   0.000042   0.000033 execute 'sign define ALEInfoSign text=' . s:EscapeSignText(g:ale_sign_info)
                            \   . ' texthl=ALEInfoSign linehl=ALEInfoLine'
    1              0.000002 sign define ALEDummySign
                            
    1              0.000003 if g:ale_sign_highlight_linenrs && has('nvim-0.3.2')
                                if !hlexists('ALEErrorSignLineNr')
                                    highlight link ALEErrorSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEStyleErrorSignLineNr')
                                    highlight link ALEStyleErrorSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEWarningSignLineNr')
                                    highlight link ALEWarningSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEStyleWarningSignLineNr')
                                    highlight link ALEStyleWarningSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEInfoSignLineNr')
                                    highlight link ALEInfoSignLineNr CursorLineNr
                                endif
                            
                                sign define ALEErrorSign numhl=ALEErrorSignLineNr
                                sign define ALEStyleErrorSign numhl=ALEStyleErrorSignLineNr
                                sign define ALEWarningSign numhl=ALEWarningSignLineNr
                                sign define ALEStyleWarningSign numhl=ALEStyleWarningSignLineNr
                                sign define ALEInfoSign numhl=ALEInfoSignLineNr
    1              0.000001 endif
                            
    1              0.000002 function! ale#sign#GetSignName(sublist) abort
                                let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
                                for l:item in a:sublist
                                    let l:item_priority = ale#util#GetItemPriority(l:item)
                            
                                    if l:item_priority > l:priority
                                        let l:priority = l:item_priority
                                    endif
                                endfor
                            
                                if l:priority is# g:ale#util#error_priority
                                    return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'
                            endfunction
                            
    1              0.000002 function! s:PriorityCmd() abort
                                if s:supports_sign_groups
                                    return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif
                            endfunction
                            
    1              0.000001 function! s:GroupCmd() abort
                                if s:supports_sign_groups
                                    return ' group=ale '
                                else
                                    return ' '
                                endif
                            endfunction
                            
                            " Read sign data for a buffer to a list of lines.
    1              0.000002 function! ale#sign#ReadSigns(buffer) abort
                                redir => l:output
                                    silent execute 'sign place ' . s:GroupCmd() . s:PriorityCmd()
                                    \ . ' buffer=' . a:buffer
                                redir end
                            
                                return split(l:output, "\n")
                            endfunction
                            
    1              0.000001 function! ale#sign#ParsePattern() abort
                                if s:supports_sign_groups
                                    " Matches output like :
                                    " line=4  id=1  group=ale  name=ALEErrorSign
                                    " строка=1  id=1000001  группа=ale  имя=ALEErrorSign
                                    " 行=1  識別子=1000001  グループ=ale  名前=ALEWarningSign
                                    " línea=12 id=1000001 grupo=ale  nombre=ALEWarningSign
                                    " riga=1 id=1000001  gruppo=ale   nome=ALEWarningSign
                                    " Zeile=235  id=1000001 Gruppe=ale  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale>.*\=(ALE[a-zA-Z]+Sign)'
                                else
                                    " Matches output like :
                                    " line=4  id=1  name=ALEErrorSign
                                    " строка=1  id=1000001  имя=ALEErrorSign
                                    " 行=1  識別子=1000001  名前=ALEWarningSign
                                    " línea=12 id=1000001 nombre=ALEWarningSign
                                    " riga=1 id=1000001  nome=ALEWarningSign
                                    " Zeile=235  id=1000001  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
                                endif
                            
                                return l:pattern
                            endfunction
                            
                            " Given a list of lines for sign output, return a List of [line, id, group]
    1              0.000002 function! ale#sign#ParseSigns(line_list) abort
                                let l:pattern =ale#sign#ParsePattern()
                                let l:result = []
                                let l:is_dummy_sign_set = 0
                            
                                for l:line in a:line_list
                                    let l:match = matchlist(l:line, l:pattern)
                            
                                    if len(l:match) > 0
                                        if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
                                        else
                                            call add(l:result, [
                                            \   str2nr(l:match[1]),
                                            \   str2nr(l:match[2]),
                                            \   l:match[3],
                                            \])
                                        endif
                                    endif
                                endfor
                            
                                return [l:is_dummy_sign_set, l:result]
                            endfunction
                            
    1              0.000002 function! ale#sign#FindCurrentSigns(buffer) abort
                                let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
                                return ale#sign#ParseSigns(l:line_list)
                            endfunction
                            
                            " Given a loclist, group the List into with one List per line.
    1              0.000002 function! s:GroupLoclistItems(buffer, loclist) abort
                                let l:grouped_items = []
                                let l:last_lnum = -1
                            
                                for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
                                endfor
                            
                                return l:grouped_items
                            endfunction
                            
    1              0.000002 function! s:UpdateLineNumbers(buffer, current_sign_list, loclist) abort
                                let l:line_map = {}
                                let l:line_numbers_changed = 0
                            
                                for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
                                endfor
                            
                                for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
                                endfor
                            
                                " When the line numbers change, sort the list again
                                if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif
                            endfunction
                            
    1              0.000002 function! s:BuildSignMap(buffer, current_sign_list, grouped_items) abort
                                let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
                                if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
                                    let l:selected_grouped_items = a:grouped_items
                                endif
                            
                                let l:sign_map = {}
                                let l:sign_offset = g:ale_sign_offset
                            
                                for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_info = get(l:sign_map, l:line, {
                                    \   'current_id_list': [],
                                    \   'current_name_list': [],
                                    \   'new_id': 0,
                                    \   'new_name': '',
                                    \   'items': [],
                                    \})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
                                    call add(l:sign_info.current_id_list, l:sign_id)
                                    call add(l:sign_info.current_name_list, l:name)
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
                                for l:group in l:selected_grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {
                                    \   'current_id_list': [],
                                    \   'current_name_list': [],
                                    \   'new_id': 0,
                                    \   'new_name': '',
                                    \   'items': [],
                                    \})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    let l:index = index(
                                    \   l:sign_info.current_name_list,
                                    \   l:sign_info.new_name
                                    \)
                            
                                    if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
                                return l:sign_map
                            endfunction
                            
    1              0.000002 function! ale#sign#GetSignCommands(buffer, was_sign_set, sign_map) abort
                                let l:command_list = []
                                let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
                                if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '
                                    \   .  g:ale_sign_offset
                                    \   . s:GroupCmd()
                                    \   . s:PriorityCmd()
                                    \   . ' line=1 name=ALEDummySign '
                                    \   . ' buffer=' . a:buffer
                                    \)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
                                for [l:line_str, l:info] in items(a:sign_map)
                                    if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '
                                            \   . (l:info.new_id)
                                            \   . s:GroupCmd()
                                            \   . s:PriorityCmd()
                                            \   . ' line=' . l:line_str
                                            \   . ' name=' . (l:info.new_name)
                                            \   . ' buffer=' . a:buffer
                                            \)
                                        endif
                                    endif
                                endfor
                            
                                " Remove signs without new IDs.
                                for l:info in values(a:sign_map)
                                    for l:current_id in l:info.current_id_list
                                        if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '
                                            \   . l:current_id
                                            \   . s:GroupCmd()
                                            \   . ' buffer=' . a:buffer
                                            \)
                                        endif
                                    endfor
                                endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
                                if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '
                                    \   . g:ale_sign_offset
                                    \   . s:GroupCmd()
                                    \   . ' buffer=' . a:buffer
                                    \)
                                endif
                            
                                return l:command_list
                            endfunction
                            
                            " This function will set the signs which show up on the left.
    1              0.000002 function! ale#sign#SetSigns(buffer, loclist) abort
                                if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
                                let [l:is_dummy_sign_set, l:current_sign_list] =
                                \   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
                                call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
                                let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
                                let l:sign_map = s:BuildSignMap(
                                \   a:buffer,
                                \   l:current_sign_list,
                                \   l:grouped_items,
                                \)
                            
                                let l:command_list = ale#sign#GetSignCommands(
                                \   a:buffer,
                                \   l:is_dummy_sign_set,
                                \   l:sign_map,
                                \)
                            
                                " Change the sign column color if the option is on.
                                if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
                                for l:command in l:command_list
                                    silent! execute l:command
                                endfor
                            
                                " Reset the sign column color when there are no more errors.
                                if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif
                            endfunction
                            
                            " Remove all signs.
    1              0.000001 function! ale#sign#Clear() abort
                                if s:supports_sign_groups
                                    sign unplace group=ale *
                                else
                                    sign unplace *
                                endif
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/autoload/ale/list.vim
Sourced 1 time
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
                            " Author: Bjorn Neergaard <bjorn@neersighted.com>, modified by Yann fery <yann@fery.me>
                            " Description: Manages the loclist and quickfix lists
                            
                            " This flag dictates if ale open the configured loclist
    1              0.000005 let g:ale_open_list = get(g:, 'ale_open_list', 0)
                            " This flag dictates if ale keeps open loclist even if there is no error in loclist
    1              0.000004 let g:ale_keep_list_window_open = get(g:, 'ale_keep_list_window_open', 0)
                            " This flag dictates that quickfix windows should be opened vertically
    1              0.000003 let g:ale_list_vertical = get(g:, 'ale_list_vertical', 0)
                            " The window size to set for the quickfix and loclist windows
    1              0.000003 let g:ale_list_window_size = get(g:, 'ale_list_window_size', 10)
                            " A string format for the loclist messages.
    1              0.000006 let g:ale_loclist_msg_format = get(g:, 'ale_loclist_msg_format',
                            \   get(g:, 'ale_echo_msg_format', '%code: %%s')
                            \)
                            
    1              0.000003 if !exists('s:timer_args')
    1              0.000002     let s:timer_args = {}
    1              0.000001 endif
                            
                            " Return 1 if there is a buffer with buftype == 'quickfix' in bufffer list
    1              0.000002 function! ale#list#IsQuickfixOpen() abort
                                let l:res = getqflist({ 'winid' : winnr() })
                            
                                if has_key(l:res, 'winid') && l:res.winid > 0
                                    return 1
                                endif
                            
                                let l:res = getloclist(0, { 'winid' : winnr() })
                            
                                if has_key(l:res, 'winid') && l:res.winid > 0
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " Check if we should open the list, based on the save event being fired, and
                            " that setting being on, or the setting just being set to `1`.
    1              0.000003 function! s:ShouldOpen(buffer) abort
                                let l:val = ale#Var(a:buffer, 'open_list')
                                let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
                                return l:val is 1 || (l:val is# 'on_save' && l:saved)
                            endfunction
                            
    1              0.000001 function! ale#list#GetCombinedList() abort
                                let l:list = []
                            
                                for l:info in values(g:ale_buffer_info)
                                    call extend(l:list, l:info.loclist)
                                endfor
                            
                                call sort(l:list, function('ale#util#LocItemCompareWithText'))
                                call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                            
                                return l:list
                            endfunction
                            
    1              0.000002 function! s:FixList(buffer, list) abort
                                let l:format = ale#Var(a:buffer, 'loclist_msg_format')
                                let l:new_list = []
                            
                                for l:item in a:list
                                    let l:fixed_item = copy(l:item)
                            
                                    let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
                                endfor
                            
                                return l:new_list
                            endfunction
                            
    1              0.000002 function! s:WinFindBuf(buffer) abort
                                return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]
                            endfunction
                            
    1              0.000002 function! s:SetListsImpl(timer_id, buffer, loclist) abort
                                let l:title = expand('#' . a:buffer . ':p')
                            
                                if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
                                    let l:ids = s:WinFindBuf(a:buffer)
                            
                                    for l:id in l:ids
                                        if has('nvim')
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                        else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
                                        endif
                                    endfor
                                endif
                            
                                " Save the current view before opening/closing any window
                                call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
                                if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
                                if !ale#engine#IsCheckingBuffer(a:buffer)
                                    call s:CloseWindowIfNeeded(a:buffer)
                                endif
                            endfunction
                            
                            " Try to restore the window view after closing any of the lists to avoid making
                            " the it moving around, especially useful when on insert mode
    1              0.000002 function! s:RestoreViewIfNeeded(buffer) abort
                                let l:saved_view = getbufvar(a:buffer, 'ale_winview', {})
                            
                                " Saved view is empty, can't do anything
                                if empty(l:saved_view)
                                    return
                                endif
                            
                                " Check wether the cursor has moved since linting was actually requested. If
                                " the user has indeed moved lines, do nothing
                                let l:current_view = winsaveview()
                            
                                if l:current_view['lnum'] != l:saved_view['lnum']
                                    return
                                endif
                            
                                " Anchor view by topline if the list is set to open horizontally
                                if ale#Var(a:buffer, 'list_vertical') == 0
                                    call winrestview({'topline': l:saved_view['topline']})
                                endif
                            endfunction
                            
    1              0.000002 function! ale#list#SetLists(buffer, loclist) abort
                                if get(g:, 'ale_set_lists_synchronously') == 1
                                \|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
                                    call ale#util#StartPartialTimer(
                                    \   0,
                                    \   function('s:SetListsImpl'),
                                    \   [a:buffer, a:loclist],
                                    \)
                                endif
                            endfunction
                            
    1              0.000002 function! s:CloseWindowIfNeeded(buffer) abort
                                if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
                                    return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/autoload/ale/highlight.vim
Sourced 1 time
Total time:   0.000581
 Self time:   0.000581

count  total (s)   self (s)
    1              0.000004 scriptencoding utf8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: This module implements error/warning highlighting.
                            
    1              0.000029 if !hlexists('ALEError')
                                highlight link ALEError SpellBad
    1              0.000001 endif
                            
    1              0.000039 if !hlexists('ALEStyleError')
    1              0.000036     highlight link ALEStyleError ALEError
    1              0.000001 endif
                            
    1              0.000014 if !hlexists('ALEWarning')
                                highlight link ALEWarning SpellCap
    1              0.000001 endif
                            
    1              0.000016 if !hlexists('ALEStyleWarning')
    1              0.000030     highlight link ALEStyleWarning ALEWarning
    1              0.000001 endif
                            
    1              0.000013 if !hlexists('ALEInfo')
                                highlight link ALEInfo ALEWarning
    1              0.000001 endif
                            
                            " The maximum number of items for the second argument of matchaddpos()
    1              0.000003 let s:MAX_POS_VALUES = 8
    1              0.000002 let s:MAX_COL_SIZE = 1073741824 " pow(2, 30)
                            
    1              0.000006 let s:has_nvim_highlight = exists('*nvim_buf_add_highlight') && exists('*nvim_buf_clear_namespace')
                            
    1              0.000001 if s:has_nvim_highlight
    1              0.000010     let s:ns_id = nvim_create_namespace('ale_highlight')
    1              0.000001 endif
                            
                            " Wrappers are necessary to test this functionality by faking the calls in tests.
    1              0.000004 function! ale#highlight#nvim_buf_add_highlight(buffer, ns_id, hl_group, line, col_start, col_end) abort
                                " Ignore all errors for adding highlights.
                                try
                                    call nvim_buf_add_highlight(a:buffer, a:ns_id, a:hl_group, a:line, a:col_start, a:col_end)
                                catch
                                endtry
                            endfunction
                            
    1              0.000003 function! ale#highlight#nvim_buf_clear_namespace(buffer, ns_id, line_start, line_end) abort
                                call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)
                            endfunction
                            
    1              0.000002 function! ale#highlight#CreatePositions(line, col, end_line, end_col) abort
                                if a:line >= a:end_line
                                    " For single lines, just return the one position.
                                    return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =
                                \   [[a:line, a:col, s:MAX_COL_SIZE]]
                                \   + range(a:line + 1, a:end_line - 1)
                                \   + [[a:end_line, 1, a:end_col]]
                            
                                return map(
                                \   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),
                                \   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',
                                \)
                            endfunction
                            
                            " Given a loclist for current items to highlight, remove all highlights
                            " except these which have matching loclist item entries.
                            
    1              0.000002 function! ale#highlight#RemoveHighlights() abort
                                if s:has_nvim_highlight
                                    call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
                                else
                                    for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
                                    endfor
                                endif
                            endfunction
                            
                            " Same semantics of matchaddpos but will use nvim_buf_add_highlight if
                            " available. This involves iterating over the position list, switching from
                            " 1-based indexing to 0-based indexing, and translating the multiple ways
                            " that position can be specified for matchaddpos into line + col_start +
                            " col_end.
    1              0.000003 function! s:matchaddpos(group, pos_list) abort
                                if s:has_nvim_highlight
                                    for l:pos in a:pos_list
                                        let l:line = type(l:pos) == v:t_number
                                        \   ? l:pos - 1
                                        \   : l:pos[0] - 1
                            
                                        if type(l:pos) == v:t_number || len(l:pos) == 1
                                            let l:col_start = 0
                                            let l:col_end = s:MAX_COL_SIZE
                                        else
                                            let l:col_start = l:pos[1] - 1
                                            let l:col_end = l:col_start + get(l:pos, 2, 1)
                                        endif
                            
                                        call ale#highlight#nvim_buf_add_highlight(
                                        \   bufnr(''),
                                        \   s:ns_id,
                                        \   a:group,
                                        \   l:line,
                                        \   l:col_start,
                                        \   l:col_end,
                                        \)
                                    endfor
                                else
                                    call matchaddpos(a:group, a:pos_list)
                                endif
                            endfunction
                            
    1              0.000002 function! s:highlight_line(bufnr, lnum, group) abort
                                call s:matchaddpos(a:group, [a:lnum])
                            endfunction
                            
    1              0.000002 function! s:highlight_range(bufnr, range, group) abort
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
                                call map(
                                \   ale#highlight#CreatePositions(
                                \       a:range.lnum,
                                \       a:range.col,
                                \       a:range.end_lnum,
                                \       a:range.end_col
                                \   ),
                                \   's:matchaddpos(a:group, v:val)'
                                \)
                            endfunction
                            
    1              0.000002 function! ale#highlight#UpdateHighlights() abort
                                let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled
                                \   ? get(b:, 'ale_highlight_items', [])
                                \   : []
                            
                                call ale#highlight#RemoveHighlights()
                            
                                for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:range = {
                                    \   'lnum': l:item.lnum,
                                    \   'col': l:item.col,
                                    \   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),
                                    \   'end_col': get(l:item, 'end_col', l:item.col)
                                    \}
                            
                                    call s:highlight_range(l:item.bufnr, l:range, l:group)
                                endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
                                if !g:ale_set_signs
                                    let l:available_groups = {
                                    \   'ALEWarningLine': hlexists('ALEWarningLine'),
                                    \   'ALEInfoLine': hlexists('ALEInfoLine'),
                                    \   'ALEErrorLine': hlexists('ALEErrorLine'),
                                    \}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
                                endif
                            endfunction
                            
    1              0.000002 function! ale#highlight#BufferHidden(buffer) abort
                                " Remove highlights right away when buffers are hidden.
                                " They will be restored later when buffers are entered.
                                call ale#highlight#RemoveHighlights()
                            endfunction
                            
    1              0.000005 augroup ALEHighlightBufferGroup
    1              0.000214     autocmd!
    1              0.000010     autocmd BufEnter * call ale#highlight#UpdateHighlights()
    1              0.000005     autocmd BufHidden * call ale#highlight#BufferHidden(expand('<abuf>'))
    1              0.000001 augroup END
                            
    1              0.000002 function! ale#highlight#SetHighlights(buffer, loclist) abort
                                let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled
                                \   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')
                                \   : []
                            
                                " Set the list in the buffer variable.
                                call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
                            
                                if !empty(l:exclude_list)
                                    call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
                                endif
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
                                call ale#highlight#UpdateHighlights()
                            endfunction

SCRIPT  /home/lusamreth/.nvim/autoload/plugged/ale/autoload/ale/cursor.vim
Sourced 1 time
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
    1              0.000003 scriptencoding utf-8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Author: João Paulo S. de Souza <joao.paulo.silvasouza@hotmail.com>
                            " Description: Echoes lint message for the current line, if any
                            
                            " Controls the milliseconds delay before echoing a message.
    1              0.000005 let g:ale_echo_delay = get(g:, 'ale_echo_delay', 10)
                            " A string format for the echoed message.
    1              0.000003 let g:ale_echo_msg_format = get(g:, 'ale_echo_msg_format', '%code: %%s')
                            
    1              0.000002 let s:cursor_timer = -1
                            
    1              0.000002 function! ale#cursor#TruncatedEcho(original_message) abort
                                let l:message = a:original_message
                                " Change tabs to spaces.
                                let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
                                let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
                                let l:shortmess_options = &l:shortmess
                            
                                try
                                    let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
                                    silent! setlocal shortmess+=T
                            
                                    try
                                        exec "norm! :echomsg l:message\n"
                                    catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    catch /E481/
                                        " Do nothing if running from a visual selection.
                                    endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
                                    if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
                                    endif
                                finally
                                    let &l:shortmess = l:shortmess_options
                                endtry
                            endfunction
                            
    1              0.000002 function! s:StopCursorTimer() abort
                                if s:cursor_timer != -1
                                    call timer_stop(s:cursor_timer)
                                    let s:cursor_timer = -1
                                endif
                            endfunction
                            
    1              0.000002 function! ale#cursor#EchoCursorWarning(...) abort
                                let l:buffer = bufnr('')
                            
                                if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode(1) isnot# 'n'
                                    return
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
                                if g:ale_echo_cursor
                                    if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
                                    elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
                                    endif
                                endif
                            
                                if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif
                            endfunction
                            
    1              0.000002 function! ale#cursor#EchoCursorWarningWithDelay() abort
                                let l:buffer = bufnr('')
                            
                                if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode(1) isnot# 'n'
                                    return
                                endif
                            
                                call s:StopCursorTimer()
                            
                                let l:pos = getpos('.')[0:2]
                            
                                if !exists('w:last_pos')
                                    let w:last_pos = [0, 0, 0]
                                endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
                                if l:pos != w:last_pos
                                    let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
                                    let w:last_pos = l:pos
                                    let s:cursor_timer = timer_start(
                                    \   l:delay,
                                    \   function('ale#cursor#EchoCursorWarning')
                                    \)
                                endif
                            endfunction
                            
    1              0.000002 function! s:ShowCursorDetailForItem(loc, options) abort
                                let l:stay_here = get(a:options, 'stay_here', 0)
                            
                                let s:last_detailed_line = line('.')
                                let l:message = get(a:loc, 'detail', a:loc.text)
                                let l:lines = split(l:message, "\n")
                            
                                if g:ale_floating_preview || g:ale_detail_to_floating_preview
                                    call ale#floating_preview#Show(l:lines)
                                else
                                    call ale#preview#Show(l:lines, {'stay_here': l:stay_here})
                            
                                    " Clear the echo message if we manually displayed details.
                                    if !l:stay_here
                                        execute 'echo'
                                    endif
                                endif
                            endfunction
                            
    1              0.000001 function! ale#cursor#ShowCursorDetail() abort
                                let l:buffer = bufnr('')
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode() isnot# 'n'
                                    return
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                call s:StopCursorTimer()
                            
                                let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
                                if !empty(l:loc)
                                    call s:ShowCursorDetailForItem(l:loc, {'stay_here': 0})
                                endif
                            endfunction

FUNCTION  FugitiveExtractGitDir()
    Defined: ~/.nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:215
Called 2 times
Total time:   0.001997
 Self time:   0.001402

count  total (s)   self (s)
    2   0.000034   0.000026   let path = s:Slash(a:path)
    2              0.000015   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
    2              0.000006   elseif empty(path)
                                return ''
    2              0.000012   elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
    2              0.000002   else
    2              0.000027     let path = fnamemodify(path, ':p:h:s?/$??')
    2              0.000002   endif
    2              0.000027   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    2              0.000008   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
    2              0.000001   endif
    2              0.000028   let root = resolve(path)
    2              0.000004   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
    2              0.000001   endif
    2              0.000004   let previous = ""
    2              0.000022   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    2   0.000057   0.000025   call s:Tree(env_git_dir)
   12              0.000024   while root !=# previous
   10              0.000073     if root =~# '\v^//%([^/]+/?)?$'
                                  break
   10              0.000006     endif
   10   0.000478   0.000156     if index(s:CeilingDirectories(), root) >= 0
                                  break
   10              0.000006     endif
   10              0.000051     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
   10              0.000034     elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
   10              0.000006     endif
   10              0.000096     let dir = substitute(root, '[\/]$', '', '') . '/.git'
   10              0.000061     let type = getftype(dir)
   10              0.000027     if type ==# 'dir' && FugitiveIsGitDir(dir)
                                  return dir
   10              0.000024     elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
   10              0.000036     elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
   10   0.000321   0.000088     elseif FugitiveIsGitDir(root)
                                  return root
   10              0.000007     endif
   10              0.000020     let previous = root
   10              0.000035     let root = fnamemodify(root, ':h')
   12              0.000014   endwhile
    2              0.000003   return ''

FUNCTION  1()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:14
Called 112 times
Total time:   0.006129
 Self time:   0.004127

count  total (s)   self (s)
  112              0.000238     let l:prependWorkingDir = 0
                            
  112   0.001629   0.000720     if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
  112              0.000071     else
  112              0.000576         let l:prependWorkingDir = a:pathStr !~# '^/'
  112              0.000068     endif
                            
  112              0.000212     let l:result = a:pathStr
                            
  112              0.000122     if l:prependWorkingDir
   26              0.000139         let l:result = getcwd()
                            
   26   0.000776   0.000209         if l:result[-1:] == nerdtree#slash()
                                        let l:result = l:result . a:pathStr
   26              0.000018         else
   26   0.000750   0.000224             let l:result = l:result . nerdtree#slash() . a:pathStr
   26              0.000017         endif
  112              0.000058     endif
                            
  112              0.000133     return l:result

FUNCTION  3()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:47
Called 105 times
Total time:   0.005614
 Self time:   0.003913

count  total (s)   self (s)
  105   0.001793   0.000661     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
  105              0.000089     if self.isExecutable
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
  105              0.000048     endif
                            
  105              0.000196     let self._bookmarkNames = []
  105   0.001087   0.000518     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
  105              0.000069     endfor
  105              0.000219     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
  105              0.000046     endif
                            
  105              0.000086     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
  105              0.000044     endif
                            
  105              0.000087     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
  105              0.000044     endif

FUNCTION  ale#events#LintOnEnter()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/events.vim:42
Called 4 times
Total time:   0.014055
 Self time:   0.000106

count  total (s)   self (s)
                                " Unmark a file as being changed outside of Vim after we try to check it.
    4              0.000018     call setbufvar(a:buffer, 'ale_file_changed', 0)
                            
    4   0.000102   0.000035     if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
    4   0.013922   0.000040         call ale#Queue(0, 'lint_file', a:buffer)
    4              0.000002     endif

FUNCTION  ale_linters#lua#luac#Handle()
    Defined: ~/.nvim/autoload/plugged/ale/ale_linters/lua/luac.vim:6
Called 1 time
Total time:   0.000046
 Self time:   0.000022

count  total (s)   self (s)
                                " Matches patterns line the following:
                                "
                                " luac: stdin:5: '=' expected near ')'
                                " luac: stdin:8: ')' expected (to close '(' at line 6) near '123'
    1              0.000002     let l:pattern = '\v^.*:(\d+): (.+)$'
    1              0.000001     let l:output = []
                            
    1   0.000034   0.000010     for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    call add(l:output, {   'lnum': l:match[1] + 0,   'type': 'E',   'text': l:match[2],})
    1              0.000001     endfor
                            
    1              0.000001     return l:output

FUNCTION  ale#linter#Get()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:353
Called 1 time
Total time:   0.005053
 Self time:   0.000246

count  total (s)   self (s)
    1              0.000005     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    2              0.000016     for l:original_filetype in split(a:original_filetypes, '\.')
    1   0.000124   0.000016         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    1   0.000081   0.000021         let l:linter_names = s:GetLinterNames(l:original_filetype)
    1   0.004656   0.000016         let l:all_linters = ale#linter#GetAll(l:filetype)
    1              0.000003         let l:filetype_linters = []
                            
    1              0.000007         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    1              0.000003             let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
    1              0.000002         endif
                            
    1              0.000006         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    2              0.000003     endfor
                            
    1              0.000003     let l:name_list = []
    1              0.000003     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
    3              0.000009     for l:linter in reverse(l:possibly_duplicated_linters)
    2              0.000010         if index(l:name_list, l:linter.name) < 0
    2              0.000009             call add(l:name_list, l:linter.name)
    2              0.000008             call add(l:combined_linters, l:linter)
    2              0.000002         endif
    3              0.000003     endfor
                            
    1              0.000003     return reverse(l:combined_linters)

FUNCTION  <SNR>61_setup_styledEmmetAbbreviation()
    Defined: ~/.nvim/autoload/plugged/emmet-vim/plugin/emmet.vim:177
Called 4 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
    4              0.000045   if index(['javascript', 'javascriptreact', 'typescript', 'typescriptreact'], &filetype) != -1
                                syntax match styledEmmetAbbreviation "[a-z0-9#+!%]\+" containedin=styledDefinition contained
    4              0.000004   endif

FUNCTION  <SNR>143_RemoveProblemsForDisabledLinters()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:475
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    1              0.000004     let l:name_map = {}
                            
    3              0.000007     for l:linter in a:linters
    2              0.000009         let l:name_map[l:linter.name] = 1
    3              0.000004     endfor
                            
    1              0.000012     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  <SNR>143_StopCurrentJobs()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:447
Called 1 time
Total time:   0.000142
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000009     let l:info = get(g:ale_buffer_info, a:buffer, {})
    1   0.000053   0.000015     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    1              0.000002     if a:clear_lint_file_jobs
    1   0.000051   0.000016         call ale#command#StopJobs(a:buffer, 'file_linter')
    1              0.000004         let l:info.active_linter_list = []
                                else
                                    let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
                                    for [l:lint_file, l:linter] in a:linter_slots
                                        if l:lint_file is 1
                                            let l:lint_file_map[l:linter.name] = 1
                                        endif
                                    endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
                                    call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
    1              0.000001     endif

FUNCTION  vital#_vsnip#VS#LSP#Position#import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Position.vim:7
Called 1 time
Total time:   0.000284
 Self time:   0.000234

count  total (s)   self (s)
    1   0.000283   0.000233 return map({'cursor': '', 'vim_to_lsp': '', 'lsp_to_vim': ''}, "vital#_vsnip#function('<SNR>127_' . v:key)")

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/highlight.vim:72
Called 7 times
Total time:   0.000273
 Self time:   0.000212

count  total (s)   self (s)
    7              0.000017     if s:has_nvim_highlight
    7   0.000164   0.000103         call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
                                else
                                    for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
                                    endfor
    7              0.000005     endif

FUNCTION  <SNR>45_customOpenFile()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:90
Called 1 time
Total time:   0.087388
 Self time:   0.000029

count  total (s)   self (s)
    1   0.087386   0.000027     call a:node.activate(s:initCustomOpenArgs().file)

FUNCTION  ale#command#ManageDirectory()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:34
Called 1 time
Total time:   0.000041
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000033   0.000015     call ale#command#InitData(a:buffer)
    1              0.000007     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  <SNR>56_rooter()
    Defined: ~/.nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:68
Called 10 times
Total time:   0.014633
 Self time:   0.000382

count  total (s)   self (s)
   10   0.000617   0.000105   if !s:activate() | return | endif
                            
    6              0.000027   let root = getbufvar('%', 'rootDir')
    6              0.000014   if empty(root)
    6   0.013665   0.000071     let root = s:root()
    6              0.000045     call setbufvar('%', 'rootDir', root)
    6              0.000005   endif
                            
    6              0.000014   if empty(root)
    6   0.000218   0.000072     call s:rootless()
    6              0.000007     return
                              endif
                            
                              call s:cd(root)

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:231
Called 1 time
Total time:   0.000165
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000049   0.000008     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    1   0.000116   0.000009     return ale#sign#ParseSigns(l:line_list)

FUNCTION  <SNR>143_HandleExit()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:151
Called 1 time
Total time:   0.003988
 Self time:   0.000075

count  total (s)   self (s)
    1              0.000004     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    1              0.000002     if empty(l:buffer_info)
                                    return
    1              0.000001     endif
                            
    1              0.000002     let l:linter = a:job_info.linter
    1              0.000002     let l:executable = a:job_info.executable
                            
                                " Remove this job from the list.
    1   0.000015   0.000009     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    1   0.000025   0.000006     if ale#util#InSandbox()
                                    return
    1              0.000001     endif
                            
    1              0.000007     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
    1              0.000000     endif
                            
    1              0.000001     try
    1   0.000070   0.000017         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
    1              0.000001     endtry
                            
    1   0.003848   0.000012     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  nerdtree#slash()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:47
Called 587 times
Total time:   0.011608
 Self time:   0.007512

count  total (s)   self (s)
  587   0.007760   0.003664     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
  587              0.000334     endif
                            
  587              0.000494     return '/'

FUNCTION  ale#GetFilenameMappings()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale.vim:269
Called 2 times
Total time:   0.000097
 Self time:   0.000062

count  total (s)   self (s)
    2   0.000056   0.000021     let l:linter_mappings = ale#Var(a:buffer, 'filename_mappings')
                            
    2              0.000006     if type(l:linter_mappings) is v:t_list
                                    return l:linter_mappings
    2              0.000001     endif
                            
    2              0.000004     let l:name = a:name
                            
    2              0.000007     if !has_key(l:linter_mappings, l:name)
                                    " Use * as a default setting for all tools.
    2              0.000003         let l:name = '*'
    2              0.000001     endif
                            
    2              0.000007     return get(l:linter_mappings, l:name, [])

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/highlight.vim:136
Called 5 times
Total time:   0.000560
 Self time:   0.000377

count  total (s)   self (s)
    5              0.000045     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    5   0.000236   0.000053     call ale#highlight#RemoveHighlights()
                            
    5              0.000011     for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
                                    call s:highlight_range(l:item.bufnr, l:range, l:group)
    5              0.000007     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    5              0.000008     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
    5              0.000003     endif

FUNCTION  <SNR>146_NeoVimCallback()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/job.vim:29
Called 2 times
Total time:   0.004414
 Self time:   0.000179

count  total (s)   self (s)
    2              0.000021     let l:info = s:job_map[a:job]
                            
    2              0.000007     if a:event is# 'stdout'
                                    let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
    2              0.000005     elseif a:event is# 'stderr'
    1   0.000103   0.000038         let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
    1              0.000001     else
    1              0.000003         if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
    1              0.000001         endif
                            
    1              0.000004         if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
    1              0.000001         endif
                            
    1              0.000001         try
    1   0.004186   0.000016             call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
    1              0.000001         finally
                                        " Automatically forget about the job after it's done.
    1              0.000003             if has_key(s:job_map, a:job)
    1              0.000003                 call remove(s:job_map, a:job)
    1              0.000001             endif
    1              0.000001         endtry
    2              0.000001     endif

FUNCTION  ale#job#Start()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/job.vim:215
Called 1 time
Total time:   0.001391
 Self time:   0.001385

count  total (s)   self (s)
    1   0.000018   0.000012     call ale#job#ValidateArguments(a:command, a:options)
                            
    1              0.000004     let l:job_info = copy(a:options)
    1              0.000002     let l:job_options = {}
                            
    1              0.000002     if has('nvim')
    1              0.000002         if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
    1              0.000001         endif
                            
    1              0.000002         if has_key(a:options, 'err_cb')
    1              0.000005             let l:job_options.on_stderr = function('s:NeoVimCallback')
    1              0.000002             let l:job_info.err_cb_line = ''
    1              0.000001         endif
                            
    1              0.000002         if has_key(a:options, 'exit_cb')
    1              0.000004             let l:job_options.on_exit = function('s:NeoVimCallback')
    1              0.000001         endif
                            
    1              0.001285         let l:job_info.job = jobstart(a:command, l:job_options)
    1              0.000007         let l:job_id = l:job_info.job
                                else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
    1              0.000001     endif
                            
    1              0.000002     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    1              0.000006         let s:job_map[l:job_id] = l:job_info
    1              0.000001     endif
                            
    1              0.000003     return l:job_id

FUNCTION  <SNR>51_OnFileType()
    Defined: ~/.nvim/autoload/plugged/LanguageClient-neovim/plugin/LanguageClient.vim:169
Called 4 times
Total time:   0.000237
 Self time:   0.000067

count  total (s)   self (s)
    4   0.000226   0.000056   if !LanguageClient#HasCommand(&filetype)
    4              0.000004     return
                              endif
                            
                              call LanguageClient#handleFileType()
                              call s:ConfigureAutocmds()

FUNCTION  <SNR>126__import_func_name()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/vsnip.vim:238
Called 6 times
Total time:   0.000101
 Self time:   0.000060

count  total (s)   self (s)
    6   0.000099   0.000058   return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))

FUNCTION  <SNR>10_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:14
Called 4 times
Total time:   0.037314
 Self time:   0.035343

count  total (s)   self (s)
    4              0.000020     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    4              0.000003     endif
                            
    4              0.000019     let s = expand("<amatch>")
    4              0.000007     if s != ""
    4              0.000050       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    4              0.000003       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    8              0.000041       for name in split(s, '\.')
    4   0.037075   0.035104 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    8              0.000025       endfor
    4              0.000006     endif

FUNCTION  <SNR>148_WinFindBuf()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/list.vim:80
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  ale#events#ReadOrEnterEvent()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/events.vim:51
Called 10 times
Total time:   0.000355
 Self time:   0.000355

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
   10              0.000063     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
   10              0.000008     endif
                            
                                " When entering a buffer, we are no longer quitting it.
   10              0.000047     call setbufvar(a:buffer, 'ale_quitting', 0)
   10              0.000050     let l:filetype = getbufvar(a:buffer, '&filetype')
   10              0.000052     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
   10              0.000030     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
   10              0.000007     endif

FUNCTION  <SNR>126_new()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/vsnip.vim:22
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000014   let base = deepcopy(s:Vital)
    2              0.000005   let base._plugin_name = a:plugin_name
    2              0.000003   return base

FUNCTION  <SNR>148_SetListsImpl()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/list.vim:84
Called 1 time
Total time:   0.000269
 Self time:   0.000149

count  total (s)   self (s)
    1              0.000014     let l:title = expand('#' . a:buffer . ':p')
                            
    1              0.000001     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
    1              0.000001     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    1   0.000015   0.000008         let l:ids = s:WinFindBuf(a:buffer)
                            
    2              0.000003         for l:id in l:ids
    1              0.000004             if has('nvim')
    1   0.000049   0.000013                 call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                        else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
    1              0.000001             endif
    2              0.000002         endfor
    1              0.000001     endif
                            
                                " Save the current view before opening/closing any window
    1              0.000005     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    1   0.000030   0.000008     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    1              0.000001     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    1   0.000020   0.000009     if !ale#engine#IsCheckingBuffer(a:buffer)
    1   0.000052   0.000008         call s:CloseWindowIfNeeded(a:buffer)
    1              0.000001     endif

FUNCTION  12()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:244
Called 184 times
Total time:   0.006928
 Self time:   0.001315

count  total (s)   self (s)
  184              0.000287     if self.cachedDisplayString ==# ''
  105   0.006047   0.000433         call self.cacheDisplayString()
  184              0.000087     endif
                            
  184              0.000204     return self.cachedDisplayString

FUNCTION  13()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:253
Called 1 time
Total time:   0.085916
 Self time:   0.007822

count  total (s)   self (s)
    1   0.000354   0.000014     let l:bufname = self.str({'format': 'Edit'})
    1              0.000005     if bufname('%') !=# l:bufname
    1   0.085554   0.007800         exec 'edit ' . l:bufname
    1              0.000002     endif

FUNCTION  14()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:263
Called 112 times
Total time:   0.002927
 Self time:   0.002222

count  total (s)   self (s)
  112   0.001361   0.000657     if nerdtree#runningWindows()
                                    if a:fullpath =~# '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', 'g')
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
  112              0.000061     else
  112              0.000290         let self.drive = ''
  112              0.000060     endif
                            

FUNCTION  16()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:286
Called 2 times
Total time:   0.000028
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000020   0.000010     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>$"
    2              0.000001     endif
                            
    2              0.000003     return " \\`\|\"#%&,?()\*^<>[]{}$"

FUNCTION  18()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:314
Called 2 times
Total time:   0.000659
 Self time:   0.000047

count  total (s)   self (s)
    2   0.000024   0.000012     if nerdtree#runningWindows()
                                    let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
    2              0.000001     else
    2              0.000012         let path = '/'. join(self.pathSegments[0:-2], '/')
    2              0.000001     endif
                            
    2   0.000612   0.000012     return s:Path.New(path)

FUNCTION  19()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:331
Called 603 times
Total time:   0.006719
 Self time:   0.006719

count  total (s)   self (s)
  603              0.001199     if empty(self.pathSegments)
                                    return ''
  603              0.000309     endif
  603              0.001300     let toReturn = self.pathSegments[-1]
  603              0.000909     if a:dirSlash && self.isDirectory
  122              0.000247         let toReturn = toReturn . '/'
  603              0.000289     endif
  603              0.000672     return toReturn

FUNCTION  <SNR>150_StopCursorTimer()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/cursor.vim:56
Called 8 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    8              0.000016     if s:cursor_timer != -1
    6              0.000020         call timer_stop(s:cursor_timer)
    6              0.000012         let s:cursor_timer = -1
    8              0.000005     endif

FUNCTION  ale#history#RememberOutput()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/history.vim:58
Called 1 time
Total time:   0.000031
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000028   0.000007     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    1              0.000002     let l:obj.output = a:output

FUNCTION  105()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:13
Called 1 time
Total time:   0.087299
 Self time:   0.000057

count  total (s)   self (s)
    1   0.087298   0.000057     call self.open(a:0 ? a:1 : {})

FUNCTION  ale#linter#RemoveIgnored()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:399
Called 1 time
Total time:   0.000077
 Self time:   0.000036

count  total (s)   self (s)
                                " Apply ignore lists for linters only if needed.
    1   0.000035   0.000012     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    1   0.000028   0.000011     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
    1              0.000010     return !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(a:filetype, a:linters, l:ignore_config, l:disable_lsp)   : a:linters

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale.vim:32
Called 13 times
Total time:   0.002144
 Self time:   0.001121

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   13              0.000075     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
   13              0.000007     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   13              0.000047     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
   13              0.000007     endif
                            
   13              0.000081     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   13              0.000020     if l:filetype is# ''
    2              0.000002         return 1
   11              0.000006     endif
                            
                                " Do nothing for diff buffers.
   11              0.000031     if getbufvar(a:buffer, '&diff')
                                    return 1
   11              0.000006     endif
                            
                                " Do nothing for blacklisted files.
   11              0.000068     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
    4              0.000004         return 1
    7              0.000004     endif
                            
                                " Do nothing if running from command mode.
    7              0.000026     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
    7              0.000004     endif
                            
    7              0.000039     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
    7              0.000012     if l:filename is# '.'
                                    return 1
    7              0.000004     endif
                            
                                " Don't start linting and so on when an operator is pending.
    7   0.001017   0.000211     if ale#util#Mode(1) is# 'no'
                                    return 1
    7              0.000005     endif
                            
                                " Do nothing if running in the sandbox.
    7   0.000186   0.000056     if ale#util#InSandbox()
                                    return 1
    7              0.000004     endif
                            
                                " Do nothing if the file is too large.
    7   0.000148   0.000060     if ale#FileTooLarge(a:buffer)
                                    return 1
    7              0.000004     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
    7              0.000064     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
    7              0.000004     endif
                            
    7              0.000006     return 0

FUNCTION  <SNR>133_try_enable_lua()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Diff.vim:129
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000001 lua <<EOF
                            function vital_vs_lsp_diff_search_line_region(old, new)
                              local old_len = #old
                              local new_len = #new
                              local min_len = math.min(#old, #new)
                            
                              local first_line = 0
                              while first_line < min_len - 1 do
                                if old[first_line + 1] ~= new[first_line + 1] then
                                  break
                                end
                                first_line = first_line + 1
                              end
                            
                              local last_line = -1
                              while last_line > -min_len + first_line do
                                if old[(old_len + last_line) + 1] ~= new[(new_len + last_line) + 1] then
                                  break
                                end
                                last_line = last_line - 1
                              end
                              return { first_line, last_line }
                            end
                            EOF

FUNCTION  20()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:344
Called 105 times
Total time:   0.009304
 Self time:   0.006109

count  total (s)   self (s)
  105              0.000164     let i = 0
  325              0.000699     while i < len(g:NERDTreeSortOrder)
  281   0.007061   0.003866         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
   61              0.000065             return i
  220              0.000108         endif
  220              0.000287         let i = i + 1
  264              0.000178     endwhile
                            
   44              0.000102     return index(g:NERDTreeSortOrder, '*')

FUNCTION  22()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:374
Called 860 times
Total time:   0.060955
 Self time:   0.050565

count  total (s)   self (s)
  860              0.002883     if !exists('self._sortKey') || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
                                    " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
  105              0.000163         let metadata = []
  630              0.000683         for tag in g:NERDTreeSortOrder
  525              0.001909             if tag =~? '\[\[-\?timestamp\]\]'
                                            let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~# '-' ? -1 : 1)]
  525              0.001529             elseif tag =~? '\[\[-\?size\]\]'
                                            let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~# '-' ? -1 : 1)]
  525              0.001641             elseif tag =~? '\[\[extension\]\]'
                                            let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
                                            let metadata += [self.isDirectory ? '' : (extension ==# '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
  525              0.000272             endif
  630              0.000398         endfor
                            
  105              0.000396         if g:NERDTreeSortOrder[0] =~# '\[\[.*\]\]'
                                        " Apply tags' sorting first if specified first.
                                        let self._sortKey = metadata + [self.getSortOrderIndex()]
  105              0.000064         else
                                        " Otherwise, do regex grouping first.
  105   0.010175   0.000871             let self._sortKey = [self.getSortOrderIndex()] + metadata
  105              0.000067         endif
                            
  105   0.001696   0.000611         let path = self.getLastPathComponent(0)
  105              0.000138         if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
  105              0.000064         endif
  105              0.000129         if !g:NERDTreeCaseSensitiveSort
  105              0.000237             let path = tolower(path)
  105              0.000057         endif
                            
  105              0.000550         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
  860              0.000485     endif
  860              0.000957     return self._sortKey

FUNCTION  23()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:411
Called 1 time
Total time:   0.000090
 Self time:   0.000027

count  total (s)   self (s)
                            
    1   0.000068   0.000005     if !self.isUnder(a:path)
                                    return 0
    1              0.000001     endif
                            
    1              0.000002     let l:startIndex = len(a:path.pathSegments)
    1              0.000003     let l:segments = self.pathSegments[l:startIndex : ]
                            
    2              0.000003     for l:segment in l:segments
                            
    1              0.000004         if l:segment =~# '^\.'
                                        return 1
    1              0.000000         endif
    2              0.000001     endfor
                            
    1              0.000001     return 0

FUNCTION  26()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:453
Called 210 times
Total time:   0.010666
 Self time:   0.008415

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
  210   0.001267   0.000920     if a:nerdtree.ui.isIgnoreFilterEnabled()
  210              0.000336         for i in g:NERDTreeIgnore
                                        if self._ignorePatternMatches(i)
                                            return 1
                                        endif
  210              0.000138         endfor
                            
  210   0.002260   0.001012         for l:Callback in g:NERDTree.PathFilters()
                                        let l:Callback = type(l:Callback) ==# type(function('tr')) ? l:Callback : function(l:Callback)
                                        if l:Callback({'path': self, 'nerdtree': a:nerdtree})
                                           return 1
                                        endif
  210              0.000137         endfor
  210              0.000104     endif
                            
                                "dont show hidden files unless instructed to
  210   0.001460   0.001130     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
  210              0.000100     endif
                            
  210   0.001356   0.001029     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
  210              0.000096     endif
                            
  210              0.000151     return 0

FUNCTION  29()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:514
Called 3 times
Total time:   0.000148
 Self time:   0.000128

count  total (s)   self (s)
    3              0.000005     if a:parent.isDirectory ==# 0
                                    return 0
    3              0.000002     endif
    3   0.000041   0.000021     if nerdtree#runningWindows() && a:parent.drive !=# self.drive
                                    return 0
    3              0.000001     endif
    3              0.000009     let l:this_count = len(self.pathSegments)
    3              0.000004     if l:this_count ==# 0
                                    return 0
    3              0.000001     endif
    3              0.000008     let l:that_count = len(a:parent.pathSegments)
    3              0.000003     if l:that_count ==# 0
                                    return 1
    3              0.000001     endif
    3              0.000004     if l:that_count >= l:this_count
    1              0.000001         return 0
    2              0.000001     endif
    8              0.000012     for i in range(0, l:that_count-1)
    6              0.000014         if self.pathSegments[i] !=# a:parent.pathSegments[i]
                                        return 0
    6              0.000003         endif
    8              0.000005     endfor
    2              0.000002     return 1

FUNCTION  <SNR>143_RunLinter()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:563
Called 2 times
Total time:   0.004231
 Self time:   0.000085

count  total (s)   self (s)
    2              0.000009     if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
    2              0.000002     else
    2   0.000125   0.000026         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    2   0.004083   0.000037         return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0

FUNCTION  111()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:88
Called 74 times
Total time:   0.004974
 Self time:   0.000699

count  total (s)   self (s)
   74   0.004946   0.000670     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  113()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:112
Called 4 times
Total time:   0.001521
 Self time:   0.000051

count  total (s)   self (s)
    4   0.001502   0.000032     if a:path.equals(self.path)
    1              0.000002         return self
    3              0.000002     endif
    3              0.000006     return {}

FUNCTION  115()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:157
Called 541 times
Total time:   0.000902
 Self time:   0.000902

count  total (s)   self (s)
  541              0.000702     return self._nerdtree

FUNCTION  117()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:173
Called 1 time
Total time:   0.008880
 Self time:   0.000043

count  total (s)   self (s)
                            
    1              0.000002     try
    1   0.001977   0.000016         let l:path = b:NERDTree.ui.getPath(line('.'))
                            
    1              0.000003         if empty(l:path)
                                        return {}
    1              0.000001         endif
                            
    1   0.006888   0.000012         return b:NERDTree.root.findNode(l:path)
                                catch
                                    return {}
    1              0.000002     endtry

FUNCTION  119()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:196
Called 118 times
Total time:   0.025950
 Self time:   0.001782

count  total (s)   self (s)
  118   0.000865   0.000518     if !g:NERDTree.ExistsForBuf()
                                    throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
  118              0.000054     endif
                            
  118   0.024782   0.000961     return self.equals(self.getNerdtree().root)

FUNCTION  nerdtree#compareNodes()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:102
Called 430 times
Total time:   0.082322
 Self time:   0.003644

count  total (s)   self (s)
  430   0.082140   0.003462     return nerdtree#compareNodePaths(a:n1.path, a:n2.path)

FUNCTION  ale#job#ValidateArguments()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/job.vim:144
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
    1              0.000001     endif

FUNCTION  ale#sign#ParseSigns()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:207
Called 1 time
Total time:   0.000107
 Self time:   0.000093

count  total (s)   self (s)
    1   0.000021   0.000007     let l:pattern =ale#sign#ParsePattern()
    1              0.000002     let l:result = []
    1              0.000003     let l:is_dummy_sign_set = 0
                            
    2              0.000008     for l:line in a:line_list
    1              0.000030         let l:match = matchlist(l:line, l:pattern)
                            
    1              0.000004         if len(l:match) > 0
                                        if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
                                        else
                                            call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
                                        endif
    1              0.000001         endif
    2              0.000003     endfor
                            
    1              0.000004     return [l:is_dummy_sign_set, l:result]

FUNCTION  vital#_vsnip#VS#Vim#Buffer#import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/Vim/Buffer.vim:7
Called 1 time
Total time:   0.000046
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000046   0.000032 return map({'get_line_count': '', 'do': '', 'create': '', 'load': ''}, "vital#_vsnip#function('<SNR>131_' . v:key)")

FUNCTION  ale#engine#MarkLinterActive()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:28
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000002     let l:found = 0
                            
    1              0.000005     for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
    1              0.000001     endfor
                            
    1              0.000001     if !l:found
    1              0.000003         call add(a:info.active_linter_list, a:linter)
    1              0.000001     endif

FUNCTION  31()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:556
Called 48 times
Total time:   0.011568
 Self time:   0.000987

count  total (s)   self (s)
   48   0.000649   0.000300     if nerdtree#runningWindows()
                                    return self.str() ==? a:path.str()
   48              0.000031     else
   48   0.010739   0.000507         return self.str() ==# a:path.str()
                                endif

FUNCTION  32()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:565
Called 112 times
Total time:   0.035965
 Self time:   0.005413

count  total (s)   self (s)
  112              0.002857     let l:newPath = copy(self)
                            
  112   0.030855   0.001243     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                            
  112              0.000220     let l:newPath.cachedDisplayString = ''
  112   0.001697   0.000757     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                            
  112              0.000123     return l:newPath

FUNCTION  33()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:581
Called 227 times
Total time:   0.004791
 Self time:   0.004791

count  total (s)   self (s)
  227              0.002423     let tmp = resolve(a:path)
  227              0.002224     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  34()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:590
Called 112 times
Total time:   0.023483
 Self time:   0.012133

count  total (s)   self (s)
  112   0.003504   0.000577     call self.extractDriveLetter(a:fullpath)
                            
  112   0.002340   0.000720     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
  112              0.000893     if getftype(fullpath) ==# 'fifo'
                                    throw 'NERDTree.InvalidFiletypeError: Cant handle FIFO files: ' . a:fullpath
  112              0.000064     endif
                            
  112              0.001642     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
  112              0.000287     let self.isReadOnly = 0
  112              0.000541     if isdirectory(a:fullpath)
   67              0.000165         let self.isDirectory = 1
   45              0.000332     elseif filereadable(a:fullpath)
   45              0.000123         let self.isDirectory = 0
   45              0.000327         let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                else
                                    throw 'NERDTree.InvalidArgumentsError: Invalid path = ' . a:fullpath
  112              0.000054     endif
                            
  112              0.000263     let self.isExecutable = 0
  112              0.000137     if !self.isDirectory
   45              0.000282         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
  112              0.000059     endif
                            
                                "grab the last part of the path (minus the trailing slash)
  112   0.002086   0.000779     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
  112   0.004297   0.001182     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
  112   0.003214   0.000833     let self.isSymLink = (s:Path.Resolve(hardPath) !=# hardPath)
  112              0.000136     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
  112              0.000055     endif

FUNCTION  38()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:698
Called 540 times
Total time:   0.055074
 Self time:   0.027088

count  total (s)   self (s)
  540              0.001383     let options = a:0 ? a:1 : {}
  540              0.000730     let toReturn = ''
                            
  540              0.001085     if has_key(options, 'format')
    9              0.000023         let format = options['format']
    9              0.000031         if has_key(self, '_strFor' . format)
    9   0.000437   0.000098             exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
    9              0.000006         endif
  531              0.000293     else
  531   0.028034   0.002781         let toReturn = self._str()
  540              0.000319     endif
                            
  540   0.005584   0.003522     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
  540              0.000276     endif
                            
  540              0.000985     if has_key(options, 'truncateTo')
    3              0.000010         let limit = options['truncateTo']
    3              0.000015         if strdisplaywidth(toReturn) > limit-1
                                        while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
                                            let toReturn = substitute(toReturn, '^.', '', '')
                                        endwhile
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
    3              0.000002         endif
  540              0.000260     endif
                            
  540              0.000631     return toReturn

FUNCTION  39()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:735
Called 6 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    6              0.000044     let toReturn = '/' . join(self.pathSegments, '/')
    6              0.000018     if self.isDirectory && toReturn !=# '/'
    6              0.000016         let toReturn  = toReturn . '/'
    6              0.000005     endif
    6              0.000010     return toReturn

FUNCTION  120()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:210
Called 105 times
Total time:   0.004426
 Self time:   0.001610

count  total (s)   self (s)
  105              0.000130     if a:path.isDirectory
   61   0.003201   0.000385         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
   44              0.000027     else
   44              0.000548         let newTreeNode = copy(self)
   44              0.000093         let newTreeNode.path = a:path
   44              0.000083         let newTreeNode.parent = {}
   44              0.000082         let newTreeNode._nerdtree = a:nerdtree
   44              0.000056         return newTreeNode
                                endif

FUNCTION  121()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:223
Called 1 time
Total time:   0.087241
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000004     let opts = a:0 ? a:1 : {}
    1   0.000115   0.000015     let opener = g:NERDTreeOpener.New(self.path, opts)
    1   0.087122   0.000015     call opener.open(self)

FUNCTION  126()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:262
Called 3 times
Total time:   0.003792
 Self time:   0.000109

count  total (s)   self (s)
    3   0.003721   0.000037     let ln = self.getNerdtree().ui.getLineNum(self)
    3              0.000004     if ln != -1
    3              0.000003         if a:isJump
    1              0.000002             mark '
    3              0.000002         endif
    3              0.000012         call cursor(ln, col('.'))
                                else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call self._nerdtree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
    3              0.000002     endif

FUNCTION  FugitiveIsGitDir()
    Defined: ~/.nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:155
Called 10 times
Total time:   0.000232
 Self time:   0.000232

count  total (s)   self (s)
   10              0.000103   let path = substitute(a:path, '[\/]$', '', '') . '/'
   10              0.000118   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:61
Called 9 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
    9              0.000086     if !isdirectory(a:dir)
    9              0.000012         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  ale#util#Writefile()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:421
Called 1 time
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    1              0.000012     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
                                " Set binary flag if buffer doesn't have eol and nofixeol to avoid appending newline
    1              0.000012     let l:flags = !getbufvar(a:buffer, '&eol') && exists('+fixeol') && !&fixeol ? 'bS' : 'S'
                            
    1              0.000066     call writefile(l:corrected_lines, a:filename, l:flags) " no-custom-checks

FUNCTION  41()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:753
Called 1 time
Total time:   0.000242
 Self time:   0.000055

count  total (s)   self (s)
                            
                                " Make the path relative to the current working directory, if possible.
    1   0.000192   0.000016     let l:result = fnamemodify(self.str(), ':.')
                            
                                " On Windows, the drive letter may be removed by "fnamemodify()".  Add it
                                " back, if necessary.
    1   0.000030   0.000017     if nerdtree#runningWindows() && l:result[0] == nerdtree#slash()
                                    let l:result = self.drive . l:result
    1              0.000001     endif
                            
    1              0.000005     let l:result = fnameescape(l:result)
                            
    1              0.000003     if empty(l:result)
                                    let l:result = '.'
    1              0.000001     endif
                            
    1              0.000002     return l:result

FUNCTION  42()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:774
Called 2 times
Total time:   0.000238
 Self time:   0.000102

count  total (s)   self (s)
    2   0.000065   0.000025     let lead = nerdtree#slash()
                            
                                "if we are running windows then slap a drive letter on the front
    2   0.000035   0.000017     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
    2              0.000001     endif
                            
    2   0.000062   0.000021     let toReturn = lead . join(self.pathSegments, nerdtree#slash())
                            
    2   0.000021   0.000011     if !nerdtree#runningWindows()
    2   0.000042   0.000014         let toReturn = escape(toReturn, self._escChars())
    2              0.000001     endif
    2              0.000002     return toReturn

FUNCTION  43()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:793
Called 531 times
Total time:   0.025253
 Self time:   0.011736

count  total (s)   self (s)
  531   0.013660   0.003226     let l:separator = nerdtree#slash()
  531              0.000964     let l:leader = l:separator
                            
  531   0.006341   0.003259     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
  531              0.000287     endif
                            
  531              0.002354     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  44()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:806
Called 112 times
Total time:   0.000789
 Self time:   0.000789

count  total (s)   self (s)
  112              0.000738     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  45()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:814
Called 1 time
Total time:   0.000270
 Self time:   0.000093

count  total (s)   self (s)
    1   0.000186   0.000009     let str = self.str()
    2              0.000008     for t in range(tabpagenr('$'))
    3              0.000009         for b in tabpagebuflist(t+1)
    2              0.000038             if str ==# expand('#' . b . ':p')
                                            return t+1
    2              0.000002             endif
    3              0.000003         endfor
    2              0.000002     endfor
    1              0.000002     return 0

FUNCTION  46()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:833
Called 112 times
Total time:   0.001620
 Self time:   0.000899

count  total (s)   self (s)
  112   0.001389   0.000668     if !nerdtree#runningWindows()
  112              0.000157         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', '')
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', '')
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', 'g')
                            
                                return toReturn

FUNCTION  <SNR>56_has()
    Defined: ~/.nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:168
Called 180 times
Total time:   0.002199
 Self time:   0.002199

count  total (s)   self (s)
  180              0.002076   return !empty(globpath(a:dir, a:identifier, 1))

FUNCTION  130()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:310
Called 3 times
Total time:   0.069898
 Self time:   0.000058

count  total (s)   self (s)
    3   0.069895   0.000056     return self._renderToString(0, 0)

FUNCTION  131()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:319
Called 187 times
Total time:   0.129040
 Self time:   0.082502

count  total (s)   self (s)
  187              0.000254     let output = ''
  187              0.000221     if a:drawText ==# 1
                            
  184              0.000481         let treeParts = repeat('  ', a:depth - 1)
  184              0.000646         let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
                            
  184   0.048040   0.001127         let line = treeParts . self.displayString()
  184              0.000419         let output = output . line . "\n"
  187              0.000102     endif
                            
                                " if the node is an open dir, draw its children
  187              0.000327     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
    4   0.012323   0.000036         let childNodesToDraw = self.getVisibleChildren()
                            
    4   0.001818   0.000024         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
    4              0.000009         elseif len(childNodesToDraw) > 0
  188              0.000189             for i in childNodesToDraw
  184              0.001072                 let output = output . i._renderToString(a:depth + 1, 1)
  188              0.000120             endfor
    4              0.000002         endif
  187              0.000085     endif
                            
  187              0.000198     return output

FUNCTION  134()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:45
Called 105 times
Total time:   0.000986
 Self time:   0.000986

count  total (s)   self (s)
  105              0.000323     call add(self.children, a:treenode)
  105              0.000215     let a:treenode.parent = self
                            
  105              0.000100     if a:inOrder
                                    call self.sortChildren()
  105              0.000058     endif

FUNCTION  137()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:86
Called 105 times
Total time:   0.007439
 Self time:   0.001848

count  total (s)   self (s)
  105   0.005623   0.001017     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
  105   0.001628   0.000641     call self.addChild(newTreeNode, a:inOrder)
  105              0.000117     return newTreeNode

FUNCTION  138()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:95
Called 110 times
Total time:   0.041939
 Self time:   0.004835

count  total (s)   self (s)
  110              0.000155     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
  110              0.000142     let l:label = ''
  110   0.031154   0.000554     let l:cascade = self.getCascade()
  220              0.000291     for l:dirNode in l:cascade
  110   0.004725   0.000609         let l:next = l:dirNode.path.displayString()
  110              0.000451         let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
  220              0.000149     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
  110              0.000413     let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
  110              0.000293     let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
  110   0.003073   0.000686     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
  110              0.000243     return l:symbol . l:flags . l:label

FUNCTION  139()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:120
Called 43 times
Total time:   0.039453
 Self time:   0.018839

count  total (s)   self (s)
   43   0.010118   0.000229     if a:path.equals(self.path)
    1              0.000001         return self
   42              0.000021     endif
   42   0.008990   0.000485     if stridx(a:path.str(), self.path.str(), 0) ==# -1
   40              0.000055         return {}
    2              0.000001     endif
                            
    2              0.000003     if self.path.isDirectory
   45              0.000059         for i in self.children
   45   0.001750   0.000230             let retVal = i.findNode(a:path)
   45              0.000077             if retVal !=# {}
    2              0.000003                 return retVal
   43              0.000025             endif
   43              0.000032         endfor
                                endif
                                return {}

FUNCTION  <SNR>119_GetVar()
    Defined: ~/.nvim/autoload/plugged/LanguageClient-neovim/autoload/LanguageClient.vim:379
Called 13 times
Total time:   0.000271
 Self time:   0.000271

count  total (s)   self (s)
   13              0.000046     let name = a:1
                            
   13              0.000062     if exists('b:' . name)
                                    return get(b:, name)
   13              0.000053     elseif exists('g:' . name)
   13              0.000042         return get(g:, name)
                                else
                                    return get(a:000, 1, v:null)
                                endif

FUNCTION  <SNR>143_GetLintFileValues()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:591
Called 1 time
Total time:   0.005539
 Self time:   0.000300

count  total (s)   self (s)
    1              0.000004     let l:deferred_list = []
    1              0.000002     let l:new_slots = []
                            
    3              0.000009     for [l:lint_file, l:linter] in a:slots
    2   0.000623   0.000145         while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
                                        let l:lint_file = l:lint_file.value
    2              0.000003         endwhile
                            
    2   0.000035   0.000023         if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
                                        call add(l:deferred_list, l:lint_file)
    2              0.000002         else
                                        " If we have the value now, coerce it to 0 or 1.
    2              0.000007             let l:lint_file = l:lint_file is 1
    2              0.000002         endif
                            
    2              0.000012         call add(l:new_slots, [l:lint_file, l:linter])
    3              0.000004     endfor
                            
    1              0.000003     if !empty(l:deferred_list)
                                    for l:deferred in l:deferred_list
                                        let l:deferred.result_callback =   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                    endfor
    1              0.000001     else
    1   0.004773   0.000025         call a:Callback(l:new_slots)
    1              0.000001     endif

FUNCTION  ale#linter#Define()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:237
Called 2 times
Total time:   0.000796
 Self time:   0.000099

count  total (s)   self (s)
                                " This command will throw from the sandbox.
    2              0.000015     let &l:equalprg=&l:equalprg
                            
    2   0.000728   0.000031     let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                            
    2              0.000008     if !has_key(s:linters, a:filetype)
    1              0.000005         let s:linters[a:filetype] = []
    2              0.000002     endif
                            
                                " Remove previously defined linters with the same name.
    2              0.000016     call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
    2              0.000011     call add(s:linters[a:filetype], l:new_linter)

FUNCTION  205()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:372
Called 4 times
Total time:   0.398495
 Self time:   0.000220

count  total (s)   self (s)
    4   0.000212   0.000042     if g:NERDTree.ExistsForTab()
    3   0.000214   0.000029         if !g:NERDTree.IsOpen()
    1   0.021432   0.000009             call self._createTreeWin()
    1              0.000004             if !empty(a:dir) && a:dir !=# b:NERDTree.root.path.str()
                                            call self.createTabTree(a:dir)
    1              0.000001             elseif !&hidden
                                            call b:NERDTree.render()
    1              0.000001             endif
    1   0.000109   0.000011             call b:NERDTree.ui.restoreScreenState()
    2              0.000002         else
    2   0.010000   0.000021             call g:NERDTree.Close()
    3              0.000002         endif
    1              0.000001     else
    1   0.366428   0.000009         call self.createTabTree(a:dir)
    4              0.000002     endif

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:353
Called 1 time
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000002     let l:command_list = []
    1              0.000002     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    1              0.000004     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
                                    let l:is_dummy_sign_set = 1
    1              0.000001     endif
                            
                                " Place new items first.
    1              0.000003     for [l:line_str, l:info] in items(a:sign_map)
                                    if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
                                        endif
                                    endif
    1              0.000001     endfor
                            
                                " Remove signs without new IDs.
    1              0.000003     for l:info in values(a:sign_map)
                                    for l:current_id in l:info.current_id_list
                                        if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
                                        endif
                                    endfor
    1              0.000001     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    1              0.000002     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    1              0.000001     endif
                            
    1              0.000001     return l:command_list

FUNCTION  ale#events#QuitEvent()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/events.vim:14
Called 1 time
Total time:   0.000036
 Self time:   0.000025

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    1   0.000033   0.000022     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  142()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:180
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000012     return len(self.children)

FUNCTION  147()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:272
Called 6 times
Total time:   0.002751
 Self time:   0.001728

count  total (s)   self (s)
                            
                                " Construct a path specification such that globpath() will return
                                " relative pathnames, if possible.
    6   0.000724   0.000061     if self.path.str() ==# getcwd()
    4              0.000007         let l:pathSpec = ','
    2              0.000001     else
    2   0.000381   0.000031         let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')
                            
                                    " On Windows, the drive letter may be removed by "fnamemodify()".
    2   0.000025   0.000014         if nerdtree#runningWindows() && l:pathSpec[0] == nerdtree#slash()
                                        let l:pathSpec = self.path.drive . l:pathSpec
    2              0.000001         endif
    6              0.000003     endif
                            
    6              0.000009     let l:globList = []
                            
                                " See ':h version7.txt' and ':h version8.txt' for details on the
                                " development of the glob() and globpath() functions.
    6              0.000015     if v:version > 704 || (v:version ==# 704 && has('patch654'))
    6              0.001142         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
                                elseif v:version ==# 704 && has('patch279')
                                    let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
                                elseif v:version > 702 || (v:version ==# 702 && has('patch051'))
                                    let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
                                    let l:globList = split(l:globString, "\n")
                                else
                                    let l:globString = globpath(l:pathSpec, a:pattern)
                                    let l:globList = split(l:globString, "\n")
    6              0.000003     endif
                            
                                " If a:all is false, filter '.' and '..' from the output.
    6              0.000006     if !a:all
    3              0.000005         let l:toRemove = []
                            
    6              0.000011         for l:file in l:globList
    6              0.000019             let l:tail = fnamemodify(l:file, ':t')
                            
                                        " If l:file has a trailing slash, then its :tail will be ''. Use
                                        " :h to drop the slash and the empty string after it; then use :t
                                        " to get the directory name.
    6              0.000008             if l:tail ==# ''
                                            let l:tail = fnamemodify(l:file, ':h:t')
    6              0.000003             endif
                            
    6              0.000011             if l:tail ==# '.' || l:tail ==# '..'
    6              0.000017                 call add(l:toRemove, l:file)
    6              0.000011                 if len(l:toRemove) ==# 2
    3              0.000002                     break
    3              0.000001                 endif
    3              0.000002             endif
    6              0.000006         endfor
                            
    9              0.000010         for l:file in l:toRemove
    6              0.000020             call remove(l:globList, index(l:globList, l:file))
    9              0.000006         endfor
    6              0.000003     endif
                            
    6              0.000008     return l:globList

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:67
Called 1 time
Total time:   0.000113
 Self time:   0.000102

count  total (s)   self (s)
    1              0.000004     let l:info = get(s:buffer_data, a:buffer, {})
                            
    1              0.000003     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    1   0.000017   0.000006         if ale#util#InSandbox()
                                        return
    1              0.000001         endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    1              0.000003         for l:filename in l:info.file_list
                                        call delete(l:filename)
    1              0.000001         endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
    2              0.000003         for l:directory in l:info.directory_list
    1              0.000064             call delete(l:directory, 'rf')
    2              0.000002         endfor
                            
    1              0.000004         call remove(s:buffer_data, a:buffer)
    1              0.000001     endif

FUNCTION  NERDTreeWebDevIconsRefreshListener()
    Defined: ~/.nvim/autoload/plugged/vim-webdevicons/plugin/webdevicons.vim:604
Called 105 times
Total time:   0.047281
 Self time:   0.012054

count  total (s)   self (s)
  105              0.000219   let path = a:event.subject
  105              0.000254   let postPadding = g:WebDevIconsNerdTreeAfterGlyphPadding
  105              0.000233   let prePadding = g:WebDevIconsNerdTreeBeforeGlyphPadding
  105   0.001655   0.000724   let hasGitFlags = (len(path.flagSet._flagsForScope('git')) > 0)
  105              0.000456   let hasGitNerdTreePlugin = (exists('g:loaded_nerdtree_git_status') == 1)
  105   0.001750   0.000883   let artifactFix = s:DevIconsGetArtifactFix()
                            
                              " align vertically at the same level: non git-flag nodes with git-flag nodes
  105              0.000288   if g:WebDevIconsNerdTreeGitPluginForceVAlign && !hasGitFlags && hasGitNerdTreePlugin
                                let prePadding .= ' '
  105              0.000051   endif
                            
  105              0.000110   if !path.isDirectory
                                " Hey we got a regular file, lets get it's proper icon
   44   0.013899   0.000634     let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str()) . postPadding
                            
   61              0.000132   elseif path.isDirectory && g:WebDevIconsUnicodeDecorateFolderNodes == 1
                                " Ok we got a directory, some more tests and checks
   61              0.000097     let directoryOpened = 0
                            
   61              0.000208     if g:DevIconsEnableFoldersOpenClose && len(path.flagSet._flagsForScope('webdevicons')) > 0
                                  " did the user set different icons for open and close?
                            
                                  " isOpen is not available on the path listener directly
                                  " but we added one via overriding particular keymappings for NERDTree
                                  if has_key(path, 'isOpen') && path.isOpen == 1
                                    let directoryOpened = 1
                                  endif
   61              0.000033     endif
                            
   61              0.000120     if g:WebDevIconsUnicodeDecorateFolderNodesExactMatches == 1
                                  " Did the user enable exact matching of folder type/names
                                  " think node_modules
   61              0.000093       if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
   61              0.000049       else
                                    " the folder is not open
   61              0.000060         if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
   61              0.000034         else
                                      " We have a regular folder
   61   0.018646   0.000917           let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str(), path.isDirectory) . postPadding
   61              0.000037         endif
   61              0.000029       endif
                            
                                else
                                  " the user did not enable exact matching
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
                                  else
                                    " the folder is not open
                                    if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
                                    else
                                      " We have a regular folder
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol . artifactFix . postPadding
                                    endif
                                  endif
                            
   61              0.000033     endif
                            
                              else
                                let flag = prePadding . ' ' . artifactFix . postPadding
  105              0.000053   endif
                            
  105   0.001054   0.000689   call path.flagSet.clearFlags('webdevicons')
                            
  105              0.000134   if flag !=? ''
  105   0.002672   0.000602     call path.flagSet.addFlag('webdevicons', flag)
  105              0.000053   endif
                            

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:82
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000006     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
    1              0.000011         let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
    1              0.000002         return 1
                                endif
                            
                                return 0

FUNCTION  150()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:358
Called 115 times
Total time:   0.014931
 Self time:   0.003903

count  total (s)   self (s)
  115              0.000186     let toReturn = []
  325              0.000396     for i in self.children
  210   0.012831   0.001802         if i.path.ignore(self.getNerdtree()) ==# 0
  210              0.000457             call add(toReturn, i)
  210              0.000111         endif
  325              0.000182     endfor
  115              0.000115     return toReturn

FUNCTION  152()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:382
Called 114 times
Total time:   0.031697
 Self time:   0.003377

count  total (s)   self (s)
  114              0.000176     if g:NERDTreeCascadeSingleChildDir ==# 0
                                    return 0
  114              0.000055     endif
                            
  114   0.025513   0.000482     if self.isRoot()
    3              0.000003         return 0
  111              0.000050     endif
                            
  111              0.000128     if self.path.isSymLink
                                    return 0
  111              0.000045     endif
                            
  111   0.001263   0.000617     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        return 0
                                    endif
  111              0.000080     endfor
                            
  111   0.003216   0.000572     let c = self.getVisibleChildren()
  111              0.000290     return len(c) ==# 1 && c[0].path.isDirectory

FUNCTION  153()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:413
Called 3 times
Total time:   0.195431
 Self time:   0.003678

count  total (s)   self (s)
                                "remove all the current child nodes
    3              0.000006     let self.children = []
                            
    3   0.002822   0.000071     let files = self._glob('*', 1) + self._glob('.*', 0)
                            
    3              0.000009     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo('Please wait, caching a large dir ...')
    3              0.000002     endif
                            
    3              0.000005     let invalidFilesFound = 0
  108              0.000148     for i in files
  105              0.000080         try
  105   0.034274   0.000792             let path = g:NERDTreePath.New(i)
  105   0.008046   0.000607             call self.createChild(path, 0)
  105   0.056008   0.001259             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
                                    catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                        let invalidFilesFound += 1
  105              0.000098         endtry
  108              0.000070     endfor
                            
    3              0.000011     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
    3   0.085003   0.000027     call self.sortChildren()
                            
    3   0.008376   0.000037     call nerdtree#echo('')
                            
    3              0.000007     if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . ' file(s) could not be loaded into the NERD tree')
    3              0.000003     endif
    3   0.000056   0.000042     return self.getChildCount()

FUNCTION  154()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:451
Called 63 times
Total time:   0.002949
 Self time:   0.002949

count  total (s)   self (s)
   63              0.000091     if a:path.isDirectory !=# 1
                                    throw 'NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object.'
   63              0.000034     endif
                            
   63              0.001942     let newTreeNode = copy(self)
   63              0.000129     let newTreeNode.path = a:path
                            
   63              0.000101     let newTreeNode.isOpen = 0
   63              0.000107     let newTreeNode.children = []
                            
   63              0.000103     let newTreeNode.parent = {}
   63              0.000128     let newTreeNode._nerdtree = a:nerdtree
                            
   63              0.000071     return newTreeNode

FUNCTION  155()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:472
Called 4 times
Total time:   0.195844
 Self time:   0.000196

count  total (s)   self (s)
    4              0.000011     let l:options = a:0 ? a:1 : {}
                            
                                " If special options were specified, process them and return.
    4              0.000014     if has_key(l:options, 'where') && !empty(l:options['where'])
                                    let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                    call l:opener.open(self)
                                    return 0
    4              0.000002     endif
                            
                                " Open any ancestors of this node that render within the same cascade.
    4              0.000007     let l:parent = self.parent
    4   0.000232   0.000016     while !empty(l:parent) && !l:parent.isRoot()
                                    if index(l:parent.getCascade(), self) >= 0
                                        let l:parent.isOpen = 1
                                        let l:parent = l:parent.parent
                                    else
                                        break
                                    endif
    4              0.000004     endwhile
                            
    4              0.000007     let self.isOpen = 1
                            
    4              0.000007     let l:numChildrenCached = 0
    4              0.000008     if empty(self.children)
    3   0.195471   0.000040         let l:numChildrenCached = self._initChildren(0)
    4              0.000003     endif
                            
    4              0.000005     return l:numChildrenCached

FUNCTION  <SNR>126__dot_to_sharp()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/vsnip.vim:269
Called 6 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    6              0.000039   return substitute(a:name, '\.', '#', 'g')

FUNCTION  ale#FileTooLarge()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale.vim:24
Called 7 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
    7              0.000048     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
    7              0.000031     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:43
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  <SNR>101_IndentLinesDisable()
    Defined: ~/.nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:209
Called 4 times
Total time:   0.000605
 Self time:   0.000548

count  total (s)   self (s)
    4              0.000008     if g:indentLine_newVersion
    4              0.000019         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
   84              0.000064             for id in w:indentLine_indentLineId
   80              0.000042                 try
   80              0.000147                     call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
   80              0.000045                 endtry
   84              0.000046             endfor
    4              0.000022             let w:indentLine_indentLineId = []
    4              0.000003         endif
                            
    4   0.000098   0.000041         call s:ResetConcealOption()
    4              0.000003         return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry

FUNCTION  71()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/key_map.vim:30
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007     return get(s:keyMaps, a:key . a:scope, {})

FUNCTION  72()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/key_map.vim:35
Called 3 times
Total time:   0.007734
 Self time:   0.001310

count  total (s)   self (s)
  168              0.000257     for i in values(s:keyMaps)
  165   0.007321   0.000897         call i.bind()
  168              0.000112     endfor

FUNCTION  73()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/key_map.vim:42
Called 165 times
Total time:   0.006424
 Self time:   0.006424

count  total (s)   self (s)
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
  165              0.000373     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
  165              0.000854     if self.key =~# specialNotationRegex
   36              0.000329         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
  129              0.000072     else
  129              0.000241         let keymapInvokeString = self.key
  165              0.000086     endif
  165              0.000452     let keymapInvokeString = escape(keymapInvokeString, '\"')
                            
  165              0.000336     let premap = self.key ==# '<LeftRelease>' ? ' <LeftRelease>' : ' '
                            
  165              0.002635     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  75()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/key_map.vim:68
Called 1 time
Total time:   0.087436
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000015     let l:Callback = type(self.callback) ==# type(function('tr')) ? self.callback : function(self.callback)
    1              0.000002     if a:0
    1   0.087411   0.000024         call l:Callback(a:1)
                                else
                                    call l:Callback()
    1              0.000002     endif

FUNCTION  76()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/key_map.vim:87
Called 1 time
Total time:   0.096439
 Self time:   0.000104

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
    1   0.000024   0.000014     if !g:NERDTree.ExistsForBuf()
                                    return {}
    1              0.000001     endif
                            
    1   0.008916   0.000036     let node = g:NERDTreeFileNode.GetSelected()
    1              0.000004     if !empty(node)
                            
                                    "try file node
    1              0.000003         if !node.path.isDirectory
    1   0.000024   0.000017             let km = s:KeyMap.FindFor(a:key, 'FileNode')
    1              0.000003             if !empty(km)
    1   0.087450   0.000014                 return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
                                    if node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, 'DirNode')
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, 'Node')
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, 'Bookmark')
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, 'all')
                                if !empty(km)
                                    return km.invoke()
                                endif

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:101
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000021     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    3              0.000027     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  164()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:615
Called 1 time
Total time:   0.038112
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000002     let opts = a:0 ? a:1 : {}
                            
    1   0.000056   0.000005     if !a:path.isUnder(self.path)
                                    throw 'NERDTree.InvalidArgumentsError: ' . a:path.str() . ' should be under ' . self.path.str()
    1              0.000000     endif
                            
    1   0.000041   0.000006     call self.open()
                            
    1   0.000553   0.000023     if self.path.equals(a:path.getParent())
    1   0.014476   0.000008         let n = self.findNode(a:path)
                                    " We may be looking for a newly-saved file that isn't in the tree yet.
    1              0.000001         if n ==# {}
                                        call self.refresh()
                                        let n = self.findNode(a:path)
    1              0.000001         endif
    1              0.000002         if has_key(opts, 'open')
    1   0.022966   0.000008             call n.open()
    1              0.000001         endif
    1              0.000002         return n
                                endif
                            
                                let p = a:path
                                while !p.getParent().equals(self.path)
                                    let p = p.getParent()
                                endwhile
                            
                                let n = self.findNode(p)
                                return n.reveal(a:path, opts)

FUNCTION  166()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:665
Called 3 times
Total time:   0.084976
 Self time:   0.002655

count  total (s)   self (s)
    3              0.000011     if count(g:NERDTreeSortOrder, '*') < 1
                                    call add(g:NERDTreeSortOrder, '*')
    3              0.000002     endif
    3              0.000012     let CompareFunc = function('nerdtree#compareNodes')
    3   0.084928   0.002607     call sort(self.children, CompareFunc)
    3              0.000013     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder

FUNCTION  ale#Var()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale.vim:180
Called 25 times
Total time:   0.000389
 Self time:   0.000389

count  total (s)   self (s)
   25              0.000086     let l:full_name = 'ale_' . a:variable_name
   25              0.000145     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
   25              0.000122     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>126_import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/vsnip.vim:38
Called 10 times
Total time:   0.005217
 Self time:   0.000319

count  total (s)   self (s)
   10              0.000017   let target = {}
   10              0.000014   let functions = []
   10              0.000016   for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
   10              0.000008   endfor
   10   0.003375   0.000659   let module = self._import(a:name)
   10              0.000016   if empty(functions)
   10              0.000050     call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
   10              0.000005   endif
   10              0.000010   return target

FUNCTION  <SNR>56_parent()
    Defined: ~/.nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:209
Called 30 times
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
   30              0.000137   return fnamemodify(a:dir, ':h')

FUNCTION  ale#command#FormatCommand()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:158
Called 1 time
Total time:   0.000569
 Self time:   0.000176

count  total (s)   self (s)
    1              0.000003     let l:temporary_file = ''
    1              0.000003     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    1              0.000013     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
    1              0.000008     if !empty(a:executable) && l:command =~# '%e'
    1   0.000051   0.000022         let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
    1              0.000001     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
    1              0.000005     if l:command =~# '%s'
                                    let l:filename = fnamemodify(bufname(a:buffer), ':p')
                                    let l:command = substitute(   l:command,   '\v\%s(%(:h|:t|:r|:e)*)',   '\=s:FormatFilename(l:filename, a:mappings, submatch(1))',   'g')
    1              0.000001     endif
                            
    1              0.000006     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(   l:command,   '\v\%t(%(:h|:t|:r|:e)*)',   '\=s:FormatFilename(l:temporary_file, a:mappings, submatch(1))',   'g')
    1              0.000001     endif
                            
                                " Finish formatting so %% becomes %.
    1              0.000010     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    1              0.000005     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
    1   0.000098   0.000016         let l:temporary_file = s:TemporaryFilename(a:buffer)
    1   0.000037   0.000015         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
    1              0.000001     endif
                            
    1   0.000292   0.000031     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
    1              0.000005     return [l:temporary_file, l:command, l:file_created]

FUNCTION  81()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/bookmark.vim:35
Called 218 times
Total time:   0.001235
 Self time:   0.001235

count  total (s)   self (s)
  218              0.000536     if !exists('g:NERDTreeBookmarks')
                                    let g:NERDTreeBookmarks = []
  218              0.000102     endif
  218              0.000251     return g:NERDTreeBookmarks

FUNCTION  82()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/bookmark.vim:45
Called 2 times
Total time:   0.000142
 Self time:   0.000069

count  total (s)   self (s)
    2              0.000003     try
    2   0.000089   0.000016         call s:Bookmark.BookmarkFor(a:name)
                                    return 1
    2              0.000038     catch /^NERDTree.BookmarkNotFoundError/
    2              0.000004         return 0
    2              0.000003     endtry

FUNCTION  83()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/bookmark.vim:57
Called 2 times
Total time:   0.000073
 Self time:   0.000053

count  total (s)   self (s)
    2              0.000005     let l:result = {}
    2   0.000039   0.000018     for l:bookmark in s:Bookmark.Bookmarks()
                                    if l:bookmark.name ==# a:name
                                        let l:result = l:bookmark
                                        break
                                    endif
    2              0.000002     endfor
    2              0.000005     if empty(l:result)
    1              0.018456         throw 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
                                endif
                                return l:result

FUNCTION  ale#command#Run()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:287
Called 1 time
Total time:   0.002805
 Self time:   0.000380

count  total (s)   self (s)
    1              0.000006     let l:options = get(a:000, 0, {})
                            
    1              0.000003     if len(a:000) > 1
                                    throw 'Too many arguments!'
    1              0.000001     endif
                            
    1              0.000005     let l:output_stream = get(l:options, 'output_stream', 'stdout')
    1              0.000003     let l:line_list = []
                            
    1   0.000601   0.000032     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),   get(l:options, 'filename_mappings', []),)
    1   0.000561   0.000138     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
    1              0.000015     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
    1              0.000002     if l:output_stream is# 'stdout'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    1              0.000002     elseif l:output_stream is# 'stderr'
    1              0.000008         let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
    1              0.000001     endif
                            
    1              0.000002     let l:status = 'failed'
                            
    1              0.000003     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
    1              0.000003     elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
    1              0.000001     else
    1   0.001407   0.000016         let l:job_id = ale#job#Start(l:command, l:job_options)
    1              0.000001     endif
                            
    1              0.000001     if l:job_id
    1              0.000003         let l:status = 'started'
    1              0.000005         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
    1   0.000031   0.000021         call ale#command#InitData(a:buffer)
    1              0.000006         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
    1              0.000001     endif
                            
    1              0.000002     if g:ale_history_enabled
    1   0.000047   0.000015         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
    1              0.000001     endif
                            
    1              0.000001     if !l:job_id
                                    return 0
    1              0.000000     endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The original command here is used in tests.
    1              0.000008     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'command': a:command,}
                            
    1              0.000003     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
    1              0.000001     endif
                            
    1              0.000002     return l:result

FUNCTION  ale#events#ClockMilliseconds()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/events.vim:10
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000010     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  170()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:42
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000005     if self._keepopen
    2              0.000003         return
                                endif
                            
                                if (a:newtab && self._where ==# 't') || !a:newtab
                                    call g:NERDTree.Close()
                                endif

FUNCTION  172()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:70
Called 1 time
Total time:   0.000461
 Self time:   0.000071

count  total (s)   self (s)
    1   0.000014   0.000010     if b:NERDTree.isWinTree()
                                    if self._where ==# 'v'
                                        call self._newVSplit()
                                    elseif self._where ==# 'h'
                                        call self._newSplit()
                                    elseif self._where ==# 't'
                                        tabnew
                                    endif
    1              0.000001     else
    1   0.000014   0.000009         call self._checkToCloseTree(1)
                            
    1              0.000002         if self._where ==# 'v'
                                        call self._newVSplit()
    1              0.000002         elseif self._where ==# 'h'
                                        call self._newSplit()
    1              0.000002         elseif self._where ==# 't'
                                        tabnew
    1              0.000002         elseif self._where ==# 'p'
    1   0.000385   0.000008             call self._previousWindow()
    1              0.000001         endif
                            
    1   0.000014   0.000010         call self._checkToCloseTree(0)
    1              0.000001     endif

FUNCTION  173()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:102
Called 2 times
Total time:   0.000276
 Self time:   0.000125

count  total (s)   self (s)
                                "gotta split if theres only one window (i.e. the NERD tree)
    2              0.000006     if winnr('$') ==# 1
                                    return 0
    2              0.000002     endif
                            
    2              0.000007     let oldwinnr = winnr()
    2   0.000112   0.000025     call nerdtree#exec(a:winnumber . 'wincmd p', 1)
    2              0.000022     let specialWindow = getbufvar('%', '&buftype') !=# '' || getwinvar('%', '&previewwindow')
    2              0.000008     let modified = &modified
    2   0.000090   0.000026     call nerdtree#exec(oldwinnr . 'wincmd p', 1)
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
    2              0.000004     if specialWindow
                                    return 0
    2              0.000002     endif
                            
    2              0.000003     if &hidden
    2              0.000002         return 1
                                endif
                            
                                return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  174()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:138
Called 1 time
Total time:   0.000099
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000018     let l:newOpener = copy(self)
                            
    1   0.000022   0.000014     let l:newOpener._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    1              0.000004     let l:newOpener._nerdtree = b:NERDTree
    1              0.000003     let l:newOpener._path = a:path
    1              0.000006     let l:newOpener._reuse = has_key(a:opts, 'reuse') ? a:opts['reuse'] : ''
    1   0.000018   0.000012     let l:newOpener._stay = nerdtree#has_opt(a:opts, 'stay')
    1              0.000006     let l:newOpener._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
                            
    1   0.000016   0.000008     call l:newOpener._saveCursorPos()
                            
    1              0.000002     return l:newOpener

FUNCTION  177()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:209
Called 1 time
Total time:   0.087107
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000002     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                    return
    1              0.000001     endif
                            
    1   0.087098   0.000011     call self._openFile()

FUNCTION  178()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:219
Called 1 time
Total time:   0.087087
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000006     if !self._stay && self._keepopen && get(b:, 'NERDTreeZoomed', 0)
                                    call b:NERDTree.ui.toggleZoom()
    1              0.000001     endif
                            
    1   0.000658   0.000008     if self._reuseWindow()
                                    return
    1              0.000001     endif
                            
    1   0.000472   0.000012     call self._gotoTargetWin()
                            
    1              0.000002     if self._stay
                                    silent call self._path.edit()
                                    call self._restoreCursorPos()
                                    return
    1              0.000001     endif
                            
    1   0.085930   0.000014     call self._path.edit()

FUNCTION  nerdtree#echo()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:219
Called 3 times
Total time:   0.008339
 Self time:   0.008339

count  total (s)   self (s)
    3              0.008302     redraw
    3              0.000033     echomsg empty(a:msg) ? '' : ('NERDTree: ' . a:msg)

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:413
Called 7 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    7              0.000046     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  <SNR>147_BuildSignMap()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:284
Called 1 time
Total time:   0.000080
 Self time:   0.000067

count  total (s)   self (s)
    1   0.000021   0.000007     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    1              0.000001     if l:max_signs is 0
                                    let l:selected_grouped_items = []
    1              0.000003     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
    1              0.000001     else
    1              0.000002         let l:selected_grouped_items = a:grouped_items
    1              0.000001     endif
                            
    1              0.000001     let l:sign_map = {}
    1              0.000002     let l:sign_offset = g:ale_sign_offset
                            
    1              0.000002     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
                                    call add(l:sign_info.current_id_list, l:sign_id)
                                    call add(l:sign_info.current_name_list, l:name)
                            
                                    let l:sign_map[l:line] = l:sign_info
    1              0.000001     endfor
                            
    1              0.000002     for l:group in l:selected_grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
                                    if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
    1              0.000001     endfor
                            
    1              0.000001     return l:sign_map

FUNCTION  180()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:261
Called 1 time
Total time:   0.000376
 Self time:   0.000065

count  total (s)   self (s)
    1   0.000165   0.000013     if !self._isWindowUsable(winnr('#')) && self._firstUsableWindow() ==# -1
                                    call self._newSplit()
    1              0.000001     else
    1              0.000001         try
    1   0.000136   0.000012             if !self._isWindowUsable(winnr('#'))
                                            call nerdtree#exec(self._firstUsableWindow() . 'wincmd w', 1)
    1              0.000001             else
    1   0.000047   0.000012                 call nerdtree#exec('wincmd p', 1)
    1              0.000001             endif
                                    catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw 'NERDTree.FileAlreadyOpenAndModifiedError: '. self._path.str() .' is already open and modified.'
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
    1              0.000001         endtry
    1              0.000001     endif

FUNCTION  182()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:290
Called 1 time
Total time:   0.000650
 Self time:   0.000204

count  total (s)   self (s)
    1              0.000003     if empty(self._reuse)
                                    return 0
    1              0.000001     endif
                            
                                "check the current tab for the window
    1   0.000318   0.000142     let winnr = bufwinnr('^' . self._path.str() . '$')
    1              0.000003     if winnr !=# -1
                                    call nerdtree#exec(winnr . 'wincmd w', 0)
                                    call self._checkToCloseTree(0)
                                    return 1
    1              0.000001     endif
                            
    1              0.000003     if self._reuse ==# 'currenttab'
                                    return 0
    1              0.000001     endif
                            
                                "check other tabs
    1   0.000285   0.000014     let tabnr = self._path.tabnr()
    1              0.000002     if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec(tabnr . 'tabnext', 1)
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . 'wincmd w', 0)
                                    return 1
    1              0.000001     endif
                            
    1              0.000001     return 0

FUNCTION  183()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:321
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000004     let self._bufnr = bufnr('')
    1              0.000003     let self._tabnr = tabpagenr()

FUNCTION  184()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:15
Called 3 times
Total time:   0.007936
 Self time:   0.000202

count  total (s)   self (s)
    3   0.007754   0.000020     call g:NERDTreeKeyMap.BindAll()
                            
    3              0.000026     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
    3              0.000027     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
    3              0.000023     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
    3              0.000019     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
    3              0.000021     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
    3              0.000017     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
    3              0.000018     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
    3              0.000010     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
    3              0.000010     command! -buffer -nargs=0 EditBookmarks call g:NERDTreeBookmark.Edit()

FUNCTION  186()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:37
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000003     return 'NERD_tree_'

FUNCTION  187()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:42
Called 1 time
Total time:   0.211415
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000020   0.000005     let creator = s:Creator.New()
    1   0.211394   0.000005     call creator.createTabTree(a:name)

FUNCTION  188()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:49
Called 2 times
Total time:   0.577808
 Self time:   0.000080

count  total (s)   self (s)
    2   0.001069   0.000015     let l:path = self._pathForString(a:name)
                            
                                " Abort if an exception was thrown (i.e., if the bookmark or directory
                                " does not exist).
    2              0.000003     if empty(l:path)
                                    return
    2              0.000001     endif
                            
                                " Obey the user's preferences for changing the working directory.
    2              0.000003     if g:NERDTreeChDirMode != 0
                                    call l:path.changeToDir()
    2              0.000001     endif
                            
    2   0.000029   0.000011     if g:NERDTree.ExistsForTab()
                                    call g:NERDTree.Close()
                                    call self._removeTreeBufForTab()
    2              0.000001     endif
                            
    2   0.051728   0.017821     call self._createTreeWin()
    2   0.173209   0.000022     call self._createNERDTree(l:path, 'tab')
    2   0.042766   0.000019     call b:NERDTree.render()
    2   0.000655   0.000027     call b:NERDTree.root.putCursorHere(0, 0)
                            
    2   0.000029   0.000012     call self._broadcastInitEvent()

FUNCTION  <SNR>143_RunJob()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:401
Called 1 time
Total time:   0.003104
 Self time:   0.000178

count  total (s)   self (s)
    1   0.000032   0.000023     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
    1              0.000001     endif
                            
    1              0.000003     let l:command = a:command
                            
    1              0.000003     if empty(l:command)
                                    return 0
    1              0.000001     endif
                            
    1              0.000003     let l:executable = a:options.executable
    1              0.000003     let l:buffer = a:options.buffer
    1              0.000003     let l:linter = a:options.linter
    1              0.000003     let l:output_stream = a:options.output_stream
    1              0.000004     let l:read_buffer = a:options.read_buffer && !a:options.lint_file
    1              0.000004     let l:info = g:ale_buffer_info[l:buffer]
                            
    1              0.000015     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,}])
    1   0.002913   0.000045     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': 1,   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:linter.name),})
                            
                                " Only proceed if the job is being run.
    1              0.000009     if empty(l:result)
                                    return 0
    1              0.000001     endif
                            
    1   0.000037   0.000018     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
    1   0.000046   0.000017     silent doautocmd <nomodeline> User ALEJobStarted
                            
    1              0.000003     return 1

FUNCTION  FugitiveDetect()
    Defined: ~/.nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:272
Called 2 times
Total time:   0.002073
 Self time:   0.000076

count  total (s)   self (s)
    2              0.000010   if exists('b:git_dir') && b:git_dir =~# '^$\|/$\|^fugitive:'
                                unlet b:git_dir
    2              0.000002   endif
    2              0.000005   if !exists('b:git_dir')
    2   0.002026   0.000029     let dir = FugitiveExtractGitDir(a:path)
    2              0.000003     if dir !=# ''
                                  let b:git_dir = dir
    2              0.000001     endif
    2              0.000001   endif
    2              0.000008   if !exists('b:git_dir') || !exists('#User#Fugitive')
    2              0.000002     return ''
                              endif
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                doautocmd <nomodeline> User Fugitive
                              elseif &modelines > 0
                                let modelines = &modelines
                                try
                                  set modelines=0
                                  doautocmd User Fugitive
                                finally
                                  let &modelines = modelines
                                endtry
                              else
                                doautocmd User Fugitive
                              endif
                              return ''

FUNCTION  <SNR>140_GetLinterNames()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:316
Called 1 time
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000007     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    1              0.000003     if l:buffer_ale_linters is# 'all'
                                    return 'all'
    1              0.000001     endif
                            
                                " b:ale_linters can be set to a List.
    1              0.000004     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
    1              0.000001     endif
                            
                                " Try to get a buffer-local setting for the filetype
    1              0.000004     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
    1              0.000001     endif
                            
                                " Try to get a global setting for the filetype
    1              0.000004     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
    1              0.000001     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    1              0.000002     if g:ale_linters_explicit
                                    return []
    1              0.000001     endif
                            
                                " Try to get a default setting for the filetype
    1              0.000004     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
    1              0.000001     endif
                            
    1              0.000002     return 'all'

FUNCTION  <SNR>143_GetLintFileSlots()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:575
Called 1 time
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000004     let l:linter_slots = []
                            
    3              0.000007     for l:linter in a:linters
    2              0.000007         let l:LintFile = l:linter.lint_file
                            
    2              0.000008         if type(l:LintFile) is v:t_func
                                        let l:LintFile = l:LintFile(a:buffer)
    2              0.000002         endif
                            
    2              0.000011         call add(l:linter_slots, [l:LintFile, l:linter])
    3              0.000004     endfor
                            
    1              0.000002     return l:linter_slots

FUNCTION  191()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:110
Called 2 times
Total time:   0.173187
 Self time:   0.000045

count  total (s)   self (s)
    2   0.000311   0.000019     let b:NERDTree = g:NERDTree.New(a:path, a:type)
                            
                                " TODO: This assignment is kept for compatibility reasons.  Many other
                                " plugins use b:NERDTreeRoot instead of b:NERDTree.root.  Remove this
                                " assignment in the future.
    2              0.000005     let b:NERDTreeRoot = b:NERDTree.root
                            
    2   0.172865   0.000015     call b:NERDTree.root.open()

FUNCTION  194()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:184
Called 3 times
Total time:   0.381433
 Self time:   0.008932

count  total (s)   self (s)
    3              0.000013     let l:splitLocation = g:NERDTreeWinPos ==# 'left' ? 'topleft ' : 'botright '
    3              0.000007     let l:splitSize = g:NERDTreeWinSize
                            
    3   0.000063   0.000016     if !g:NERDTree.ExistsForTab()
    2   0.000055   0.000011         let t:NERDTreeBufName = self._nextBufferName()
    2   0.007802   0.003353         silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' new'
    2   0.019026   0.013812         silent! execute 'edit ' . t:NERDTreeBufName
    2              0.000025         silent! execute 'vertical resize '. l:splitSize
    1              0.000001     else
    1   0.001379   0.000078         silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' split'
    1   0.001629   0.000054         silent! execute 'buffer ' . t:NERDTreeBufName
    3              0.000003     endif
                            
    3   0.000036   0.000029     setlocal winfixwidth
                            
    3   0.063130   0.000043     call self._setCommonBufOptions()
                            
    3              0.000016     if has('patch-7.4.1925')
    3              0.000013         clearjumps
    3              0.000002     endif
                            

FUNCTION  196()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:218
Called 5 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
    5              0.000135     let newCreator = copy(self)
    5              0.000013     return newCreator

FUNCTION  197()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:225
Called 2 times
Total time:   0.000044
 Self time:   0.000021

count  total (s)   self (s)
    2   0.000041   0.000018     let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
    2              0.000002     return name

FUNCTION  198()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:232
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000005     if !exists('s:Creator._NextBufNum')
    1              0.000003         let s:Creator._NextBufNum = 1
    1              0.000001     else
    1              0.000002         let s:Creator._NextBufNum += 1
    2              0.000001     endif
                            
    2              0.000002     return s:Creator._NextBufNum

FUNCTION  199()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:244
Called 2 times
Total time:   0.001054
 Self time:   0.000136

count  total (s)   self (s)
    2              0.000005     let path = {}
    2   0.000162   0.000020     if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                    let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
    2              0.000001     else
    2              0.000014         let dir = a:str ==# '' ? getcwd() : a:str
                            
                                    "hack to get an absolute path if a relative path is given
    2              0.000010         if dir =~# '^\.'
                                        let dir = getcwd() . nerdtree#slash() . dir
    2              0.000002         endif
                            
                                    "hack to prevent removing slash if dir is the root of the file system.
    2              0.000003         if dir !=# '/'
    2   0.000075   0.000019             let dir = g:NERDTreePath.Resolve(dir)
    2              0.000002         endif
                            
    2              0.000002         try
    2   0.000735   0.000015             let path = g:NERDTreePath.New(dir)
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo('No bookmark or directory found for: ' . a:str)
                                        return {}
    2              0.000002         endtry
    2              0.000001     endif
    2              0.000002     if !path.isDirectory
                                    let path = path.getParent()
    2              0.000001     endif
                            
    2              0.000002     return path

FUNCTION  vsnip#snippet#import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vsnip/snippet.vim:7
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003   return s:Snippet

FUNCTION  ale#sign#SetUpDefaultColumnWithoutErrorsHighlight()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:52
Called 1 time
Total time:   0.000122
 Self time:   0.000120

count  total (s)   self (s)
    1              0.000004     let l:verbose = &verbose
    1   0.000012   0.000010     set verbose=0
    1              0.000003     redir => l:output
    1              0.000026         0verbose silent highlight SignColumn
    1              0.000003     redir end
    1   0.000006   0.000005     let &verbose = l:verbose
                            
    1              0.000024     let l:highlight_syntax = join(split(l:output)[2:])
    1              0.000008     let l:match = matchlist(l:highlight_syntax, '\vlinks to (.+)$')
                            
    1              0.000002     if !empty(l:match)
                                    execute 'highlight link ALESignColumnWithoutErrors ' . l:match[1]
    1              0.000002     elseif l:highlight_syntax isnot# 'cleared'
    1              0.000026         execute 'highlight ALESignColumnWithoutErrors ' . l:highlight_syntax
    1              0.000001     endif

FUNCTION  <SNR>101_Disable()
    Defined: ~/.nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:309
Called 4 times
Total time:   0.000213
 Self time:   0.000064

count  total (s)   self (s)
    4   0.000186   0.000038     if s:Filter() == 0
                                    call s:IndentLinesDisable()
                                    call s:LeadingSpaceDisable()
    4              0.000002     endif

FUNCTION  vsnip#get_session()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vsnip.vim:105
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003   return s:session

FUNCTION  <SNR>89_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:39
Called 28 times
Total time:   0.002703
 Self time:   0.002703

count  total (s)   self (s)
                              " Remove any previous match.
   28              0.000119   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
   28              0.000020   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   28              0.000125   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   28              0.000016   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   28              0.000099   let c_lnum = line('.')
   28              0.000070   let c_col = col('.')
   28              0.000041   let before = 0
                            
   28              0.000083   let text = getline(c_lnum)
   28              0.000459   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   28              0.000072   if empty(matches)
                                let [c_before, c] = ['', '']
   28              0.000023   else
   28              0.000147     let [c_before, c] = matches[1:2]
   28              0.000021   endif
   28              0.000436   let plist = split(&matchpairs, '.\zs[:,]')
   28              0.000111   let i = index(plist, c)
   28              0.000040   if i < 0
                                " not found, in Insert mode try character before the cursor
   28              0.000100     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   28              0.000020     endif
   28              0.000032     if i < 0
                                  " not found, nothing to do
   28              0.000033       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  ale#Queue()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale.vim:123
Called 5 times
Total time:   0.013937
 Self time:   0.000182

count  total (s)   self (s)
    5              0.000008     if a:0 > 2
                                    throw 'too many arguments!'
    5              0.000004     endif
                            
    5              0.000018     let l:buffer = get(a:000, 1, v:null)
                            
    5              0.000007     if l:buffer is v:null
                                    let l:buffer = bufnr('')
    5              0.000003     endif
                            
    5              0.000012     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
    5              0.000002     endif
                            
    5   0.001203   0.000038     if ale#ShouldDoNothing(l:buffer)
    4              0.000003         return
    1              0.000001     endif
                            
                                " Default linting_flag to ''
    1              0.000007     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
    1              0.000003     if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
    1              0.000001     endif
                            
    1              0.000002     if a:delay > 0
                                    let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    1              0.000001     else
    1   0.012611   0.000020         call s:Lint(l:buffer, l:should_lint_file, 0)
    1              0.000001     endif

FUNCTION  ale#job#PrepareCommand()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/job.vim:175
Called 1 time
Total time:   0.000076
 Self time:   0.000059

count  total (s)   self (s)
    1   0.000029   0.000011     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
    1              0.000006     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
    1              0.000003     if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
    1              0.000001     endif
                            
    1              0.000005     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
    1              0.000001     endif
                            
    1              0.000016     if &shell =~? 'fish$\|pwsh$'
    1              0.000003         return ['/bin/sh', '-c', l:command]
                                endif
                            
                                return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  <SNR>56_root()
    Defined: ~/.nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:113
Called 6 times
Total time:   0.013594
 Self time:   0.006242

count  total (s)   self (s)
    6   0.000226   0.000064   let dir = s:current()
                            
                              " breadth-first search
   30              0.000037   while 1
  210              0.000404     for pattern in g:rooter_patterns
  180              0.000408       if pattern[0] == '!'
                                    let [p, exclude] = [pattern[1:], 1]
  180              0.000136       else
  180              0.000641         let [p, exclude] = [pattern, 0]
  180              0.000128       endif
  180   0.008749   0.001717       if s:match(dir, p)
                                    if exclude
                                      break
                                    else
                                      return dir
                                    endif
  180              0.000120       endif
  210              0.000179     endfor
                            
   30   0.000534   0.000376     let [current, dir] = [dir, s:parent(dir)]
   54              0.000107     if current == dir | break | endif
   30              0.000040   endwhile
                            
    6              0.000009   return ''

FUNCTION  <SNR>148_FixList()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/list.vim:60
Called 1 time
Total time:   0.000036
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000018   0.000006     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    1              0.000002     let l:new_list = []
                            
    1              0.000002     for l:item in a:list
                                    let l:fixed_item = copy(l:item)
                            
                                    let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
    1              0.000001     endfor
                            
    1              0.000001     return l:new_list

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:53
Called 2 times
Total time:   0.000763
 Self time:   0.000559

count  total (s)   self (s)
    2              0.000005     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
    2              0.000001     endif
                            
                                " Check for a cached executable() check.
    2              0.000012     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
    2              0.000005     if l:result isnot v:null
                                    return l:result
    2              0.000001     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
    2              0.000341     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
    2              0.000009     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
    1              0.000006         let s:executable_cache_map[a:executable] = l:result
    2              0.000002     endif
                            
    2              0.000004     if g:ale_history_enabled
    2   0.000349   0.000145         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    2              0.000002     endif
                            
    2              0.000003     return l:result

FUNCTION  vital#vsnip#import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/vsnip.vim:13
Called 6 times
Total time:   0.003817
 Self time:   0.000106

count  total (s)   self (s)
    6              0.000014   if !exists('s:V')
    1   0.000023   0.000011     let s:V = s:new(s:plugin_name)
    6              0.000003   endif
    6   0.003761   0.000062   return call(s:V.import, a:000, s:V)

FUNCTION  vital#_vsnip#function()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip.vim:7
Called 15 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
   15              0.000052   silent! return function(a:funcname)

FUNCTION  ale#Escape()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale.vim:219
Called 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000016     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
    2              0.000002     endif
                            
    2              0.000009     return shellescape (a:str)

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:202
Called 1516 times
Total time:   0.009955
 Self time:   0.009955

count  total (s)   self (s)
 1516              0.009286     return has('win16') || has('win32') || has('win64')

FUNCTION  ale#events#FileTypeEvent()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/events.vim:69
Called 4 times
Total time:   0.000169
 Self time:   0.000114

count  total (s)   self (s)
                                " The old filetype will be set to an empty string by the BuFEnter event,
                                " and not linting when the old filetype hasn't been set yet prevents
                                " buffers being checked when you enter them when linting on enter is off.
    4              0.000028     let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                            
    4              0.000023     if l:old_filetype isnot v:null&& !empty(a:new_filetype)&& a:new_filetype isnot# l:old_filetype
                                    " Remember what the new filetype is.
    1              0.000004         call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                            
    1              0.000002         if g:ale_lint_on_filetype_changed
    1   0.000062   0.000007             call ale#Queue(300, 'lint_file', a:buffer)
    1              0.000001         endif
    4              0.000003     endif

FUNCTION  vital#_vsnip#VS#LSP#Diff#import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Diff.vim:7
Called 1 time
Total time:   0.000028
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000028   0.000019 return map({'try_enable_lua': '', 'compute': ''}, "vital#_vsnip#function('<SNR>133_' . v:key)")

FUNCTION  vital#_vsnip#VS#Vim#Option#import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/Vim/Option.vim:7
Called 1 time
Total time:   0.000016
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000016   0.000012 return map({'define': ''}, "vital#_vsnip#function('<SNR>132_' . v:key)")

FUNCTION  <SNR>148_ShouldOpen()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/list.vim:40
Called 2 times
Total time:   0.000043
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000030   0.000011     let l:val = ale#Var(a:buffer, 'open_list')
    2              0.000006     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    2              0.000005     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>45_initCustomOpenArgs()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:111
Called 1 time
Total time:   0.000060
 Self time:   0.000055

count  total (s)   self (s)
    1   0.000026   0.000021     let l:defaultOpenArgs = {'file': {'reuse': 'all', 'where': 'p', 'keepopen':!nerdtree#closeTreeOnOpen()}, 'dir': {}}
    1              0.000002     try
    1              0.000006         let g:NERDTreeCustomOpenArgs = get(g:, 'NERDTreeCustomOpenArgs', {})
    1              0.000012         call  extend(g:NERDTreeCustomOpenArgs, l:defaultOpenArgs, 'keep')
                                catch /^Vim(\a\+):E712:/
                                    call nerdtree#echoWarning('g:NERDTreeCustomOpenArgs is not set properly. Using default value.')
                                    let g:NERDTreeCustomOpenArgs = l:defaultOpenArgs
    1              0.000001     finally
    1              0.000003         return g:NERDTreeCustomOpenArgs
                                endtry

FUNCTION  112()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:102
Called 118 times
Total time:   0.023641
 Self time:   0.001141

count  total (s)   self (s)
  118   0.023600   0.001100     return self.path.str() ==# a:treenode.path.str()

FUNCTION  ale#highlight#nvim_buf_clear_namespace()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/highlight.vim:44
Called 7 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    7              0.000055     call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)

FUNCTION  <SNR>52_Tree()
    Defined: ~/.nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:164
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000005   let dir = a:path
    2              0.000010   if dir =~# '/\.git$'
                                return len(dir) ==# 5 ? '/' : dir[0:-6]
    2              0.000003   elseif dir ==# ''
    2              0.000003     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  SyncTree()
    Defined: ~/.config/nvim/plug-config/nerdtree.vim:28
Called 9 times
Total time:   0.289017
 Self time:   0.000251

count  total (s)   self (s)
    9   0.000571   0.000106   if &modifiable && IsNERDTreeOpen() && strlen(expand('%')) > 0 && !&diff
    1   0.288354   0.000053     NERDTreeFind
    1              0.000020     wincmd p
    9              0.000007   endif

FUNCTION  ale#linter#GetCommand()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:419
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000004     let l:Command = a:linter.command
                            
    1              0.000007     return type(l:Command) is v:t_func ? l:Command(a:buffer) : l:Command

FUNCTION  LanguageClient#HasCommand()
    Defined: ~/.nvim/autoload/plugged/LanguageClient-neovim/autoload/LanguageClient.vim:844
Called 13 times
Total time:   0.000522
 Self time:   0.000251

count  total (s)   self (s)
   13   0.000461   0.000190   let l:commands = s:GetVar('LanguageClient_serverCommands', {})
   13              0.000047   return has_key(l:commands, a:filetype)

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.nvim/autoload/plugged/vim-webdevicons/plugin/webdevicons.vim:493
Called 162 times
Total time:   0.035989
 Self time:   0.034357

count  total (s)   self (s)
  162              0.000509   if a:0 == 0
   57              0.000434     let fileNodeExtension = expand('%:e')
   57              0.000205     let fileNode = expand('%:t')
   57              0.000113     let isDirectory = 0
  105              0.000064   else
  105              0.000393     let fileNodeExtension = fnamemodify(a:1, ':e')
  105              0.000282     let fileNode = fnamemodify(a:1, ':t')
  105              0.000110     if a:0 > 1
   61              0.000098       let isDirectory = a:2
   44              0.000026     else
   44              0.000060       let isDirectory = 0
  105              0.000056     endif
  162              0.000097   endif
                            
  162              0.000390   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
  162              0.000454     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  162              0.000548     let fileNodeExtension = tolower(fileNodeExtension)
  162              0.000411     let fileNode = tolower(fileNode)
                            
 1620              0.004442     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
 1458              0.011054       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
 1458              0.000738       endif
 1620              0.001095     endfor
                            
  162              0.000474     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  162              0.000602       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
  162              0.001022       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
   64              0.000304         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
   98              0.000110       elseif isDirectory == 1
   61              0.000140         let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
  162              0.000101       endif
  162              0.000095     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
  162              0.000097   endif
                            
  162   0.003864   0.002231   let artifactFix = s:DevIconsGetArtifactFix()
                            
  162              0.000351   return symbol . artifactFix
                            

FUNCTION  <SNR>51_OnBufEnter()
    Defined: ~/.nvim/autoload/plugged/LanguageClient-neovim/plugin/LanguageClient.vim:160
Called 9 times
Total time:   0.000480
 Self time:   0.000128

count  total (s)   self (s)
    9   0.000463   0.000111   if !LanguageClient#HasCommand(&filetype)
    9              0.000008     return
                              endif
                            
                              call LanguageClient#handleBufEnter()
                              call s:ConfigureAutocmds()

FUNCTION  185()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:30
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000013     if exists('#User#NERDTreeInit')
                                    doautocmd User NERDTreeInit
    2              0.000001     endif

FUNCTION  <SNR>139_ApplyPartialTimer()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:436
Called 1 time
Total time:   0.000291
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000003     if has_key(s:partial_timers, a:timer_id)
    1              0.000006         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    1   0.000281   0.000012         call call(l:Callback, [a:timer_id] + l:args)
    1              0.000000     endif

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:231
Called 5 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    5              0.000010     let l:min = 0
    5              0.000016     let l:max = len(a:loclist) - 1
                            
    5              0.000007     while 1
    5              0.000009         if l:max < l:min
    5              0.000006             return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile

FUNCTION  <SNR>147_GroupCmd()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:164
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001     if s:supports_sign_groups
    1              0.000001         return ' group=ale '
                                else
                                    return ' '
                                endif

FUNCTION  <SNR>101_Filter()
    Defined: ~/.nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:286
Called 16 times
Total time:   0.000464
 Self time:   0.000464

count  total (s)   self (s)
   16              0.000081     if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
   16              0.000011     endif
                            
   16              0.000058     if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
   16              0.000008     endif
                            
   16              0.000061     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
   16              0.000007     endif
                            
   16              0.000041     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
   16              0.000016     endfor
                            
   16              0.000016     return 1

FUNCTION  <SNR>145_FindHistoryItem()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/history.vim:36
Called 2 times
Total time:   0.000049
 Self time:   0.000038

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
    4   0.000031   0.000020     for l:obj in reverse(ale#history#Get(a:buffer))
    4              0.000006         if l:obj.job_id == a:job_id
    2              0.000002             return l:obj
    2              0.000001         endif
    2              0.000001     endfor
                            
                                return {}

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:663
Called 1 time
Total time:   0.005713
 Self time:   0.000080

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    1   0.000041   0.000017     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
    1   0.005668   0.000059     call s:GetLintFileValues(   s:GetLintFileSlots(a:buffer, a:linters),   {       slots -> s:RunLinters(           a:buffer,           a:linters,           slots,           a:should_lint_file,           l:new_buffer,       )   })

FUNCTION  nerdtree#has_opt()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:170
Called 542 times
Total time:   0.002077
 Self time:   0.002077

count  total (s)   self (s)
  542              0.001855     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  ale#sign#ParsePattern()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:182
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000001     if s:supports_sign_groups
                                    " Matches output like :
                                    " line=4  id=1  group=ale  name=ALEErrorSign
                                    " строка=1  id=1000001  группа=ale  имя=ALEErrorSign
                                    " 行=1  識別子=1000001  グループ=ale  名前=ALEWarningSign
                                    " línea=12 id=1000001 grupo=ale  nombre=ALEWarningSign
                                    " riga=1 id=1000001  gruppo=ale   nome=ALEWarningSign
                                    " Zeile=235  id=1000001 Gruppe=ale  Name=ALEErrorSign
    1              0.000002         let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale>.*\=(ALE[a-zA-Z]+Sign)'
                                else
                                    " Matches output like :
                                    " line=4  id=1  name=ALEErrorSign
                                    " строка=1  id=1000001  имя=ALEErrorSign
                                    " 行=1  識別子=1000001  名前=ALEWarningSign
                                    " línea=12 id=1000001 nombre=ALEWarningSign
                                    " riga=1 id=1000001  nome=ALEWarningSign
                                    " Zeile=235  id=1000001  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    1              0.000001     endif
                            
    1              0.000001     return l:pattern

FUNCTION  <SNR>56_match()
    Defined: ~/.nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:141
Called 180 times
Total time:   0.007032
 Self time:   0.004832

count  total (s)   self (s)
  180              0.000496   if a:pattern[0] == '='
                                return s:is(a:dir, a:pattern[1:])
  180              0.000382   elseif a:pattern[0] == '^'
                                return s:sub(a:dir, a:pattern[1:])
  180              0.000356   elseif a:pattern[0] == '>'
                                return s:child(a:dir, a:pattern[1:])
  180              0.000128   else
  180   0.003834   0.001634     return s:has(a:dir, a:pattern)
                              endif

FUNCTION  <SNR>52_CeilingDirectories()
    Defined: ~/.nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:198
Called 10 times
Total time:   0.000322
 Self time:   0.000322

count  total (s)   self (s)
   10              0.000039   if !exists('s:ceiling_directories')
    1              0.000004     let s:ceiling_directories = []
    1              0.000002     let resolve = 1
    2              0.000015     for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
    1              0.000002       if empty(dir)
    1              0.000001         let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
    1              0.000000       endif
    2              0.000002     endfor
   10              0.000007   endif
   10              0.000049   return s:ceiling_directories + get(g:, 'ceiling_directories', [])

FUNCTION  IsNERDTreeOpen()
    Defined: ~/.config/nvim/plug-config/nerdtree.vim:23
Called 6 times
Total time:   0.000465
 Self time:   0.000465

count  total (s)   self (s)
    6              0.000459   return exists("t:NERDTreeBufName") && (bufwinnr(t:NERDTreeBufName) != -1)

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:474
Called 5 times
Total time:   0.000227
 Self time:   0.000169

count  total (s)   self (s)
    5              0.000030     let l:info = get(g:ale_buffer_info, a:buffer, {})
    5              0.000018     let l:loclist = get(l:info, 'loclist', [])
    5              0.000018     let l:pos = getpos('.')
    5   0.000122   0.000064     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    5              0.000017     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    5              0.000012     return [l:info, l:loc]

FUNCTION  226()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:166
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return self._type ==# 'window'

FUNCTION  <SNR>140_IsCallback()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:74
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000015     return type(a:value) is v:t_string || type(a:value) is v:t_func

FUNCTION  <SNR>144_ExitCallback()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:246
Called 1 time
Total time:   0.004137
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000003     if !has_key(s:buffer_data, a:buffer)
                                    return
    1              0.000001     endif
                            
    1              0.000003     let l:jobs = s:buffer_data[a:buffer].jobs
                            
    1              0.000002     if !has_key(l:jobs, a:data.job_id)
                                    return
    1              0.000000     endif
                            
    1              0.000004     let l:job_type = remove(l:jobs, a:data.job_id)
                            
    1              0.000002     if g:ale_history_enabled
    1   0.000052   0.000009         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
    1              0.000002         if g:ale_history_log_output && a:data.log_output is 1
    1   0.000041   0.000010             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    1              0.000001         endif
    1              0.000001     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
    1              0.000004     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    1   0.004003   0.000015     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
    1              0.000002     let l:result = a:data.result
    1              0.000002     let l:result.value = l:value
                            
    1              0.000004     if get(l:result, 'result_callback', v:null) isnot v:null
                                    call call(l:result.result_callback, [l:value])
    1              0.000001     endif

FUNCTION  <SNR>45_findAndRevealPath()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:296
Called 1 time
Total time:   0.288301
 Self time:   0.000224

count  total (s)   self (s)
    1              0.000039     let l:pathStr = !empty(a:pathStr) ? a:pathStr : expand('%:p')
    1              0.000003     let l:revealOpts = {}
                            
    1              0.000002     if empty(l:pathStr)
                                    call nerdtree#echoWarning('no file for the current buffer')
                                    return
    1              0.000001     endif
                            
    1              0.000009     if !filereadable(l:pathStr)
    1              0.000004         let l:pathStr = fnamemodify(l:pathStr, ':h')
    1              0.000003         let l:revealOpts['open'] = 1
    1              0.000001     endif
                            
    1              0.000001     try
    1   0.000037   0.000011         let l:pathStr = g:NERDTreePath.Resolve(l:pathStr)
    1   0.000330   0.000007         let l:pathObj = g:NERDTreePath.New(l:pathStr)
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echoWarning('invalid path')
                                    return
    1              0.000001     endtry
                            
    1   0.000022   0.000006     if !g:NERDTree.ExistsForTab()
    1              0.000001         try
    1   0.000302   0.000010             let l:cwd = g:NERDTreePath.New(getcwd())
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo('current directory does not exist.')
                                        let l:cwd = l:pathObj.getParent()
    1              0.000001         endtry
                            
    1   0.000040   0.000006         if l:pathObj.isUnder(l:cwd)
                                        call g:NERDTreeCreator.CreateTabTree(l:cwd.str())
    1              0.000001         else
    1   0.211888   0.000036             call g:NERDTreeCreator.CreateTabTree(l:pathObj.getParent().str())
    1              0.000001         endif
                                else
                                    NERDTreeFocus
                            
                                    if !l:pathObj.isUnder(b:NERDTree.root.path)
                                        call s:chRoot(g:NERDTreeDirNode.New(l:pathObj.getParent(), b:NERDTree))
                                    endif
    1              0.000000     endif
                            
    1   0.000099   0.000008     if l:pathObj.isHiddenUnder(b:NERDTree.root.path)
                                    call b:NERDTree.ui.setShowHidden(1)
    1              0.000001     endif
                            
    1   0.038124   0.000012     let l:node = b:NERDTree.root.reveal(l:pathObj, l:revealOpts)
    1   0.034178   0.000010     call b:NERDTree.render()
    1   0.003175   0.000012     call l:node.putCursorHere(1, 0)

FUNCTION  ale#history#Add()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/history.vim:12
Called 3 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
    3              0.000009     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
    3              0.000002     endif
                            
    3              0.000015     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
    3              0.000010     if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
    3              0.000002     endif
                            
    3              0.000023     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
    3              0.000013     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  nerdtree#closeTreeOnOpen()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:34
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return g:NERDTreeQuitOnOpen == 1 || g:NERDTreeQuitOnOpen == 3

FUNCTION  nerdtree#exec()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:157
Called 22 times
Total time:   0.009951
 Self time:   0.001405

count  total (s)   self (s)
   22              0.000087     let old_ei = &eventignore
   22              0.000039     if a:ignoreAll
   18              0.000126         set eventignore=all
   22              0.000019     endif
   22              0.000021     try
   22   0.001241   0.000580         exec a:cmd
   22              0.000032     finally
   22   0.000164   0.000128         let &eventignore = old_ei
   22              0.000036     endtry

FUNCTION  vital#_vsnip#VS#LSP#TextEdit#import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/TextEdit.vim:7
Called 1 time
Total time:   0.000039
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000039   0.000027 return map({'_vital_depends': '', 'apply': '', '_vital_loaded': ''}, "vital#_vsnip#function('<SNR>129_' . v:key)")

FUNCTION  <SNR>56_rootless()
    Defined: ~/.nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:225
Called 6 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    6              0.000015   let dir = ''
    6              0.000027   if g:rooter_change_directory_for_non_project_files ==? 'current'
                                let dir = s:current()
    6              0.000018   elseif g:rooter_change_directory_for_non_project_files ==? 'home'
                                let dir = $HOME
    6              0.000005   endif
    6              0.000035   if !empty(dir) | call s:cd(dir) | endif

FUNCTION  ale#util#StartPartialTimer()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:449
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000008     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    1              0.000005     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    1              0.000001     return l:timer_id

FUNCTION  <SNR>147_PriorityCmd()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:156
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000001     if s:supports_sign_groups
    1              0.000003         return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif

FUNCTION  ale#command#InitData()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:19
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000010     if !has_key(s:buffer_data, a:buffer)
    1              0.000010         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
    2              0.000002     endif

FUNCTION  <SNR>56_current()
    Defined: ~/.nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:200
Called 6 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
    6              0.000077   let fn = expand('%:p', 1)
    6              0.000038   if empty(fn) | return getcwd() | endif  " opening vim without a file
    4              0.000021   if g:rooter_resolve_links | let fn = resolve(fn) | endif
    4              0.000019   return fnamemodify(fn, ':h')

FUNCTION  <SNR>140_GetAliasedFiletype()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:280
Called 1 time
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000008     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
    1              0.000008     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
    1              0.000001     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
    4              0.000014     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
    3              0.000013         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
    3              0.000003         endif
    4              0.000005     endfor
                            
    1              0.000002     return a:original_filetype

FUNCTION  ale#history#SetExitCode()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/history.vim:49
Called 1 time
Total time:   0.000042
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000037   0.000009     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    1              0.000003     let l:obj.exit_code = a:exit_code
    1              0.000001     let l:obj.status = 'finished'

FUNCTION  <SNR>126__get_module()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/vsnip.vim:218
Called 6 times
Total time:   0.002935
 Self time:   0.001622

count  total (s)   self (s)
    6   0.000212   0.000099   let funcname = s:_import_func_name(self.plugin_name(), a:name)
    6              0.000005   try
    6   0.002682   0.001483     return call(funcname, [])
                              catch /^Vim\%((\a\+)\)\?:E117:/
                                return s:_get_builtin_module(a:name)
    6              0.000006   endtry

FUNCTION  <SNR>129__vital_loaded()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/TextEdit.vim:13
Called 1 time
Total time:   0.001546
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000487   0.000006   let s:Text = a:V.import('VS.LSP.Text')
    1   0.000045   0.000007   let s:Position = a:V.import('VS.LSP.Position')
    1   0.000551   0.000007   let s:Buffer = a:V.import('VS.Vim.Buffer')
    1   0.000461   0.000007   let s:Option = a:V.import('VS.Vim.Option')

FUNCTION  <SNR>101_InitColor()
    Defined: ~/.nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:35
Called 9 times
Total time:   0.001874
 Self time:   0.001874

count  total (s)   self (s)
    9              0.000019     if !g:indentLine_setColors
                                    return
    9              0.000006     endif
                            
    9              0.000028     let default_term_bg = "NONE"
    9              0.000017     let default_gui_bg  = "NONE"
    9              0.000020     if &background ==# "light"
                                    let default_term_fg = 249
                                    let default_gui_fg = "Grey70"
    9              0.000007     else
    9              0.000016         let default_term_fg = 239
    9              0.000016         let default_gui_fg = "Grey30"
    9              0.000006     endif
                            
    9              0.000023     if g:indentLine_defaultGroup != ""
                                    let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
                                    let default_term_fg = synIDattr(default_id, "fg", "cterm") == "" ? default_term_fg :  synIDattr(default_id, "fg", "cterm")
                                    let default_term_bg = synIDattr(default_id, "bg", "cterm") == "" ? default_term_bg :  synIDattr(default_id, "bg", "cterm")
                                    let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
                                    let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
    9              0.000006     endif
                            
    9              0.000032     if !exists("g:indentLine_color_term")
                                    let term_color = default_term_fg
    9              0.000005     else
    9              0.000021         let term_color = g:indentLine_color_term
    9              0.000005     endif
                            
    9              0.000025     if !exists("g:indentLine_bgcolor_term")
    9              0.000019         let term_bgcolor = default_term_bg
                                else
                                    let term_bgcolor = g:indentLine_bgcolor_term
    9              0.000005     endif
                            
    9              0.000039     if !exists("g:indentLine_color_gui")
                                    let gui_color = default_gui_fg
    9              0.000005     else
    9              0.000019         let gui_color = g:indentLine_color_gui
    9              0.000005     endif
                            
    9              0.000025     if !exists("g:indentLine_bgcolor_gui")
    9              0.000019         let gui_bgcolor = default_gui_bg
                                else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
    9              0.000005     endif
                            
    9              0.000627     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
    9              0.000383     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
    9              0.000020     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
    9              0.000005     endif

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:108
Called 1 time
Total time:   0.003836
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000004     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    1              0.000002     if empty(l:info)
                                    return
    1              0.000000     endif
                            
    1              0.000001     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    1              0.000003         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    1              0.000001     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    1   0.000239   0.000012     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    1              0.000003     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    1              0.000002     if !empty(l:linter_loclist)
                                    " Add the new items.
                                    call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
                                    call sort(l:info.loclist, 'ale#util#LocItemCompare')
    1              0.000001     endif
                            
    1   0.000115   0.000009     if ale#ShouldDoNothing(a:buffer)
                                    return
    1              0.000000     endif
                            
    1   0.003451   0.000014     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  ale#linter#GetAll()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:257
Called 1 time
Total time:   0.004639
 Self time:   0.003518

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    1   0.000027   0.000010     if ale#util#InSandbox()
                                    return []
    1              0.000001     endif
                            
    1              0.000003     let l:combined_linters = []
                            
    2              0.000006     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    1              0.000004         if !has_key(s:runtime_loaded_map, l:filetype)
    1   0.004537   0.003433             execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
    1              0.000015             let s:runtime_loaded_map[l:filetype] = 1
    1              0.000002         endif
                            
    1              0.000013         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    2              0.000003     endfor
                            
    1              0.000003     return l:combined_linters

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:306
Called 1 time
Total time:   0.000108
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000100   0.000021     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    1              0.000004     if type(l:filetype) isnot v:t_list
    1              0.000003         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>56_activate()
    Defined: ~/.nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:87
Called 10 times
Total time:   0.000512
 Self time:   0.000512

count  total (s)   self (s)
   10              0.000053   if !empty(&buftype) | return 0 | endif
                            
    7              0.000061   let patterns = split(g:rooter_targets, ',')
    7              0.000100   let fn = expand('%:p', 1)
                            
                              " directory
    7              0.000030   if empty(fn) || fn[-1:] == '/'
    2              0.000007     return index(patterns, '/') != -1
    5              0.000004   endif
                            
                              " file
    5              0.000068   if !filereadable(fn) | return 0 | endif
    4              0.000022   if !exists('*glob2regpat') | return 1 | endif
                            
    4              0.000052   for p in filter(copy(patterns), 'v:val != "/"')
    4              0.000056     if fn =~ glob2regpat(p)
    4              0.000007       return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  ale#util#Mode()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:5
Called 7 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    7              0.000036     return call('mode', a:000)

FUNCTION  <SNR>147_UpdateLineNumbers()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:259
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000004     let l:line_map = {}
    1              0.000003     let l:line_numbers_changed = 0
                            
    1              0.000004     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
    1              0.000001     endfor
                            
    1              0.000002     for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
    1              0.000001     endfor
                            
                                " When the line numbers change, sort the list again
    1              0.000001     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
    1              0.000001     endif

FUNCTION  201()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:293
Called 3 times
Total time:   0.063087
 Self time:   0.000279

count  total (s)   self (s)
                            
                                " Options for a non-file/control buffer.
    3   0.000027   0.000025     setlocal bufhidden=hide
    3   0.000011   0.000009     setlocal buftype=nofile
    3   0.000026   0.000012     setlocal noswapfile
                            
                                " Options for controlling buffer/window appearance.
    3   0.000013   0.000012     setlocal foldcolumn=0
    3   0.000011   0.000009     setlocal foldmethod=manual
    3   0.000052   0.000012     setlocal nobuflisted
    3   0.000009   0.000008     setlocal nofoldenable
    3   0.000010   0.000008     setlocal nolist
    3   0.000010   0.000008     setlocal nospell
    3   0.000008   0.000007     setlocal nowrap
                            
    3              0.000006     if g:NERDTreeShowLineNumbers
                                    setlocal number
    3              0.000002     else
    3   0.000018   0.000017         setlocal nonumber
    3              0.000007         if v:version >= 703
    3   0.000010   0.000008             setlocal norelativenumber
    3              0.000002         endif
    3              0.000002     endif
                            
    3              0.000005     iabc <buffer>
                            
    3              0.000004     if g:NERDTreeHighlightCursorline
    3   0.000010   0.000009         setlocal cursorline
    3              0.000002     endif
                            
    3   0.000060   0.000022     call self._setupStatusline()
    3   0.007956   0.000020     call self._bindMappings()
                            
    3   0.054801   0.000036     setlocal filetype=nerdtree

FUNCTION  202()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:331
Called 3 times
Total time:   0.000037
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000007     if g:NERDTreeStatusline != -1
    3   0.000025   0.000021         let &l:statusline = g:NERDTreeStatusline
    3              0.000002     endif

FUNCTION  204()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/creator.vim:359
Called 4 times
Total time:   0.398758
 Self time:   0.000121

count  total (s)   self (s)
    4   0.000214   0.000072     let creator = s:Creator.New()
    4   0.398536   0.000041     call creator.toggleTabTree(a:dir)

FUNCTION  207()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/flag_set.vim:7
Called 105 times
Total time:   0.002069
 Self time:   0.001315

count  total (s)   self (s)
  105   0.001394   0.000640     let flags = self._flagsForScope(a:scope)
  105              0.000258     if index(flags, a:flag) == -1
  105              0.000274         call add(flags, a:flag)
  105              0.000062     end

FUNCTION  208()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/flag_set.vim:15
Called 105 times
Total time:   0.000365
 Self time:   0.000365

count  total (s)   self (s)
  105              0.000320     let self._flags[a:scope] = []

FUNCTION  209()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/flag_set.vim:20
Called 210 times
Total time:   0.001685
 Self time:   0.001685

count  total (s)   self (s)
  210              0.000585     if !has_key(self._flags, a:scope)
  105              0.000279         let self._flags[a:scope] = []
  210              0.000123     endif
  210              0.000404     return self._flags[a:scope]

FUNCTION  vital#_vsnip#VS#LSP#Text#import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/_vsnip/VS/LSP/Text.vim:7
Called 1 time
Total time:   0.000027
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000027   0.000019 return map({'normalize_eol': '', 'split_by_eol': ''}, "vital#_vsnip#function('<SNR>130_' . v:key)")

FUNCTION  vital#vsnip#new()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/vsnip.vim:9
Called 1 time
Total time:   0.000017
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000016   0.000006   return s:new(s:plugin_name)

FUNCTION  ale#list#SetLists()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/list.vim:189
Called 1 time
Total time:   0.000043
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000006     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
    1              0.000001     else
    1   0.000030   0.000015         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    1              0.000001     endif

FUNCTION  <SNR>101_IndentLinesEnable()
    Defined: ~/.nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:148
Called 6 times
Total time:   0.004533
 Self time:   0.004365

count  total (s)   self (s)
    6              0.000008     if g:indentLine_newVersion
    6              0.000017         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                        return
    6              0.000003         endif
                            
    6              0.000014         if !exists("w:indentLine_indentLineId")
    2              0.000008             let w:indentLine_indentLineId = []
    6              0.000003         endif
                            
    6   0.000243   0.000075         call s:SetConcealOption()
                            
    6              0.000009         if g:indentLine_showFirstIndentLevel
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
    6              0.000003         endif
                            
    6              0.000019         let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
    6              0.000014         let n = len(g:indentLine_char_list)
    6              0.000007         let level = 0
  126              0.000149         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
  120              0.000109             if n > 0
                                            let char = g:indentLine_char_list[level % n]
                                            let level += 1
  120              0.000058             else
  120              0.000164                 let char = g:indentLine_char
  120              0.000056             endif
  120              0.003078             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': char}))
  126              0.000098         endfor
                            
    6              0.000007         return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                            
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:289
Called 10 times
Total time:   0.000176
 Self time:   0.000165

count  total (s)   self (s)
   10              0.000012     try
   10   0.000093   0.000082         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
   10              0.000012     endtry
                            
   10              0.000011     return 0

FUNCTION  210()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/flag_set.vim:28
Called 112 times
Total time:   0.000940
 Self time:   0.000940

count  total (s)   self (s)
  112              0.000528     let newObj = copy(self)
  112              0.000218     let newObj._flags = {}
  112              0.000124     return newObj

FUNCTION  212()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/flag_set.vim:45
Called 184 times
Total time:   0.003851
 Self time:   0.003851

count  total (s)   self (s)
  184              0.000285     let flagstring = ''
  552              0.000816     for i in values(self._flags)
  368              0.000938         let flagstring .= join(i)
  552              0.000329     endfor
                            
  184              0.000323     if len(flagstring) == 0
                                    return ''
  184              0.000082     endif
                            
  184              0.000320     return '[' . flagstring . ']'

FUNCTION  215()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:37
Called 2 times
Total time:   0.009979
 Self time:   0.000278

count  total (s)   self (s)
    2   0.000089   0.000014     if !s:NERDTree.IsOpen()
                                    return
    2              0.000002     endif
                            
    2              0.000007     if winnr('$') !=# 1
                                    " Use the window ID to identify the currently active window or fall
                                    " back on the buffer ID if win_getid/win_gotoid are not available, in
                                    " which case we'll focus an arbitrary window showing the buffer.
    2              0.000016         let l:useWinId = exists('*win_getid') && exists('*win_gotoid')
                            
    2   0.000086   0.000032         if winnr() ==# s:NERDTree.GetWinNum()
    1   0.000092   0.000014             call nerdtree#exec('wincmd p', 1)
    1              0.000007             let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr('')
    1   0.000048   0.000012             call nerdtree#exec('wincmd p', 1)
    1              0.000001         else
    1              0.000005             let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr('')
    2              0.000002         endif
                            
    2   0.000183   0.000045         call nerdtree#exec(s:NERDTree.GetWinNum() . ' wincmd w', 1)
    2   0.008607   0.000025         call nerdtree#exec('close', 0)
    2              0.000004         if l:useWinId
    2   0.000770   0.000032             call nerdtree#exec('call win_gotoid(' . l:activeBufOrWin . ')', 0)
                                    else
                                        call nerdtree#exec(bufwinnr(l:activeBufOrWin) . ' wincmd w', 0)
    2              0.000002         endif
                                else
                                    close
    2              0.000002     endif

FUNCTION  217()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:93
Called 4 times
Total time:   0.000534
 Self time:   0.000104

count  total (s)   self (s)
    4   0.000223   0.000026     call g:NERDTree.MustBeOpen()
    4   0.000308   0.000074     call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)

FUNCTION  218()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:100
Called 119 times
Total time:   0.000358
 Self time:   0.000358

count  total (s)   self (s)
  119              0.000299     return exists('b:NERDTree')

FUNCTION  219()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:106
Called 10 times
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
   10              0.000042     if !exists('t:NERDTreeBufName')
    3              0.000003         return
    7              0.000006     end
                            
                                "check b:NERDTree is still there and hasn't been e.g. :bdeleted
    7              0.000175     return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))

FUNCTION  <SNR>101_LeadingSpaceDisable()
    Defined: ~/.nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:364
Called 4 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    4              0.000006     if g:indentLine_newVersion
    4              0.000013         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
    4              0.000002         endif
                            
    4              0.000003         return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry

FUNCTION  ale#util#GetLineCount()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:83
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000036     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  <SNR>101_Setup()
    Defined: ~/.nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:317
Called 6 times
Total time:   0.005706
 Self time:   0.000336

count  total (s)   self (s)
    6              0.000018     if &filetype ==# ""
    3   0.000542   0.000021         call s:InitColor()
    6              0.000003     endif
                            
    6   0.000206   0.000050     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
    6   0.004633   0.000100         call s:IndentLinesEnable()
    6              0.000004     endif
                            
    6   0.000261   0.000101     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
    6              0.000003     endif

FUNCTION  ale#engine#FixLocList()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:259
Called 1 time
Total time:   0.000227
 Self time:   0.000145

count  total (s)   self (s)
    1   0.000044   0.000009     let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                            
    1              0.000002     if !empty(l:mappings)
                                    " We need to apply reverse filename mapping here.
                                    let l:mappings = ale#filename_mapping#Invert(l:mappings)
    1              0.000000     endif
                            
    1              0.000002     let l:bufnr_map = {}
    1              0.000001     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    1   0.000045   0.000008     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
    1              0.000002     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
                                    let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
                                    if a:from_other_source
                                        let l:item.from_other_source = 1
                                    endif
                            
                                    if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
                                    endif
                            
                                    let l:old_name = get(l:old_item, 'filename', '')
                            
                                    " Map parsed from output to local filesystem files.
                                    if !empty(l:old_name) && !empty(l:mappings)
                                        let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
                                    endif
                            
                                    if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_name
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
                                    if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
                                    if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
                                    if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
                                    if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
                                    if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
                                    call add(l:new_loclist, l:item)
    1              0.000003     endfor
                            
    1   0.000022   0.000010     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    1              0.000002     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
    1              0.000001     endif
                            
    1              0.000001     return l:new_loclist

FUNCTION  <SNR>101_ResetConcealOption()
    Defined: ~/.nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:110
Called 4 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    4              0.000014     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                    if exists("b:indentLine_original_concealcursor")
                                        let &l:concealcursor = b:indentLine_original_concealcursor
                                    endif
                                    if exists("b:indentLine_original_conceallevel")
                                        let &l:conceallevel = b:indentLine_original_conceallevel
                                    endif
                                    let b:indentLine_ConcealOptionSet = 0
    4              0.000002     endif

FUNCTION  223()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:140
Called 23 times
Total time:   0.000840
 Self time:   0.000840

count  total (s)   self (s)
   23              0.000105     if exists('t:NERDTreeBufName')
   23              0.000708         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
                                for w in range(1,winnr('$'))
                                    if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
                                    endif
                                endfor
                            
                                return -1

FUNCTION  224()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:156
Called 15 times
Total time:   0.000766
 Self time:   0.000144

count  total (s)   self (s)
   15   0.000756   0.000134     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  227()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:171
Called 4 times
Total time:   0.000197
 Self time:   0.000046

count  total (s)   self (s)
    4   0.000181   0.000031     if !s:NERDTree.IsOpen()
                                    throw 'NERDTree.TreeNotOpen'
    4              0.000004     endif

FUNCTION  228()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:178
Called 2 times
Total time:   0.000292
 Self time:   0.000080

count  total (s)   self (s)
    2              0.000029     let newObj = copy(self)
    2   0.000099   0.000019     let newObj.ui = g:NERDTreeUI.New(newObj)
    2   0.000155   0.000022     let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
    2              0.000004     let newObj._type = a:type
    2              0.000002     return newObj

FUNCTION  229()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:187
Called 210 times
Total time:   0.001248
 Self time:   0.001248

count  total (s)   self (s)
  210              0.000529     if !exists('s:NERDTree._PathFilters')
    1              0.000003         let s:NERDTree._PathFilters = []
  210              0.000100     endif
  210              0.000248     return s:NERDTree._PathFilters

FUNCTION  ale#highlight#BufferHidden()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/highlight.vim:193
Called 2 times
Total time:   0.000118
 Self time:   0.000028

count  total (s)   self (s)
                                " Remove highlights right away when buffers are hidden.
                                " They will be restored later when buffers are entered.
    2   0.000114   0.000024     call ale#highlight#RemoveHighlights()

FUNCTION  ale#highlight#SetHighlights()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/highlight.vim:205
Called 1 time
Total time:   0.000143
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000011     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    1              0.000005     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
    1   0.000022   0.000008     let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
                            
    1              0.000002     if !empty(l:exclude_list)
                                    call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
    1              0.000001     endif
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    1   0.000096   0.000008     call ale#highlight#UpdateHighlights()

FUNCTION  ale#engine#SetResults()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:184
Called 1 time
Total time:   0.003437
 Self time:   0.000442

count  total (s)   self (s)
    1   0.000047   0.000023     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    1              0.000002     if g:ale_set_signs
    1   0.001593   0.000108         call ale#sign#SetSigns(a:buffer, a:loclist)
    1              0.000001     endif
                            
    1              0.000002     if g:ale_set_quickfix || g:ale_set_loclist
    1   0.000336   0.000087         call ale#list#SetLists(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000003     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
    1              0.000001     endif
                            
    1              0.000001     if g:ale_set_highlights
    1   0.000820   0.000079         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000001     if l:linting_is_done
    1              0.000001         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    1   0.000460   0.000084             call ale#cursor#EchoCursorWarning()
    1              0.000001         endif
                            
    1              0.000001         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
    1              0.000000         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    1              0.000004         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    1              0.000005         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    1   0.000125   0.000012         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.000016   0.000009         silent doautocmd <nomodeline> User ALELintPost
    1              0.000001     endif

FUNCTION  232()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:205
Called 3 times
Total time:   0.076916
 Self time:   0.000021

count  total (s)   self (s)
    3   0.076914   0.000020     call self.ui.render()

FUNCTION  234()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:25
Called 3 times
Total time:   0.000553
 Self time:   0.000536

count  total (s)   self (s)
    3   0.000022   0.000015     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
    3   0.000041   0.000031     elseif !self.isMinimal()
                                    let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
                                    silent! put =help
    3              0.000002     endif

FUNCTION  236()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:159
Called 1 time
Total time:   0.001961
 Self time:   0.000647

count  total (s)   self (s)
    1              0.000007     let line = getline(a:ln)
                            
    1   0.000041   0.000010     let rootLine = self.getRootLineNum()
                            
    1              0.000003     if a:ln ==# rootLine
                                    return self.nerdtree.root.path
    1              0.000001     endif
                            
    1   0.000014   0.000011     if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
    1              0.000001     endif
                            
    1              0.000002     if a:ln < rootLine
                                    return {}
    1              0.000001     endif
                            
    1   0.000066   0.000011     let indent = self._indentLevelFor(line)
                            
                                " remove the tree parts and the leading space
    1   0.000038   0.000010     let curFile = self._stripMarkup(line)
                            
    1              0.000002     let dir = ''
    1              0.000002     let lnum = a:ln
   10              0.000018     while lnum > 0
   10              0.000024         let lnum = lnum - 1
   10              0.000037         let curLine = getline(lnum)
   10   0.000347   0.000108         let curLineStripped = self._stripMarkup(curLine)
                            
                                    " have we reached the top of the tree?
   10              0.000024         if lnum ==# rootLine
    1   0.000152   0.000017             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
    1              0.000001             break
    9              0.000007         endif
    9              0.000049         if curLineStripped =~# '/$'
    6   0.000334   0.000060             let lpindent = self._indentLevelFor(curLine)
    6              0.000015             if lpindent < indent
                                            let indent = indent - 1
                            
                                            let dir = substitute (curLineStripped,'^\\', '', '') . dir
                                            continue
    6              0.000005             endif
    9              0.000007         endif
   10              0.000012     endwhile
    1              0.000006     let curFile = self.nerdtree.root.path.drive . dir . curFile
    1   0.000560   0.000012     let toReturn = g:NERDTreePath.New(curFile)
    1              0.000002     return toReturn

FUNCTION  237()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:211
Called 3 times
Total time:   0.003677
 Self time:   0.001489

count  total (s)   self (s)
                            
    3   0.000716   0.000014     if a:node.isRoot()
    2   0.000072   0.000013         return self.getRootLineNum()
    1              0.000000     endif
                            
    1   0.000084   0.000021     let l:pathComponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/\s*$', '', '')]
    1              0.000002     let l:currentPathComponent = 1
                            
    1   0.000070   0.000008     let l:fullPath = a:node.path.str({'format': 'UI'})
                            
   35   0.000062   0.000047     for l:lineNumber in range(self.getRootLineNum() + 1, line('$'))
   35              0.000080         let l:currentLine = getline(l:lineNumber)
   35   0.001069   0.000203         let l:indentLevel = self._indentLevelFor(l:currentLine)
                            
   35              0.000056         if l:indentLevel !=# l:currentPathComponent
                                        continue
   35              0.000015         endif
                            
   35   0.000618   0.000197         let l:currentLine = self._stripMarkup(l:currentLine)
   35              0.000128         let l:currentPath =  join(l:pathComponents, '/') . '/' . l:currentLine
                            
                                    " Directories: If the current path 'starts with' the full path, then
                                    " either the paths are equal or the line is a cascade containing the
                                    " full path.
   35              0.000122         if l:fullPath[-1:] ==# '/' && stridx(l:currentPath, l:fullPath) ==# 0
    1              0.000001             return l:lineNumber
   34              0.000016         endif
                            
                                    " Files: The paths must exactly match.
   34              0.000047         if l:fullPath ==# l:currentPath
                                        return l:lineNumber
   34              0.000015         endif
                            
                                    " Otherwise: If the full path starts with the current path and the
                                    " current path is a directory, we add a new path component.
   34              0.000089         if stridx(l:fullPath, l:currentPath) ==# 0 && l:currentPath[-1:] ==# '/'
                                        let l:currentLine = substitute(l:currentLine, '/\s*$', '', '')
                                        call add(l:pathComponents, l:currentLine)
                                        let l:currentPathComponent += 1
   34              0.000014         endif
   34              0.000021     endfor
                            
                                return -1

FUNCTION  238()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:259
Called 4 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    4              0.000009     let rootLine = 1
    4              0.000072     while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
                                    let rootLine = rootLine + 1
    4              0.000005     endwhile
    4              0.000006     return rootLine

FUNCTION  239()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:268
Called 3 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    3              0.000005     return self._showBookmarks

FUNCTION  <SNR>140_IsBoolean()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:78
Called 4 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    4              0.000024     return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)

FUNCTION  ale#util#GetMatches()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:324
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000001     let l:matches = []
    1              0.000003     let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
    1              0.000004     let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
    1              0.000002     for l:line in l:lines
                                    for l:pattern in l:patterns
                                        let l:match = matchlist(l:line, l:pattern)
                            
                                        if !empty(l:match)
                                            call add(l:matches, l:match)
                                            break
                                        endif
                                    endfor
    1              0.000001     endfor
                            
    1              0.000001     return l:matches

FUNCTION  ale#command#StopJobs()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:222
Called 2 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    2              0.000013     let l:info = get(s:buffer_data, a:buffer, {})
                            
    2              0.000006     if !empty(l:info)
                                    let l:new_map = {}
                            
                                    for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
                                    endfor
                            
                                    let l:info.jobs = l:new_map
    2              0.000002     endif

FUNCTION  240()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:273
Called 210 times
Total time:   0.000327
 Self time:   0.000327

count  total (s)   self (s)
  210              0.000253     return self._showFiles

FUNCTION  241()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:278
Called 3 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    3              0.000005     return self._showHelp

FUNCTION  242()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:283
Called 210 times
Total time:   0.000330
 Self time:   0.000330

count  total (s)   self (s)
  210              0.000251     return self._showHidden

FUNCTION  243()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:288
Called 42 times
Total time:   0.001194
 Self time:   0.001129

count  total (s)   self (s)
                                " Replace multi-character DirArrows with a single space so the
                                " indentation calculation doesn't get messed up.
   42              0.000073     if g:NERDTreeDirArrowExpandable ==# ''
                                    let l:line = '  '.a:line
   42              0.000025     else
   42              0.000410         let l:line = substitute(substitute(a:line, '\V'.g:NERDTreeDirArrowExpandable, ' ', ''), '\V'.g:NERDTreeDirArrowCollapsible, ' ', '')
   42              0.000029     endif
   42              0.000214     let leadChars = match(l:line, '\M\[^ ]')
   42   0.000304   0.000240     return leadChars / s:UI.IndentWid()

FUNCTION  244()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:301
Called 42 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
   42              0.000045     return 2

FUNCTION  245()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:306
Called 210 times
Total time:   0.000347
 Self time:   0.000347

count  total (s)   self (s)
  210              0.000274     return self._ignoreEnabled ==# 1

FUNCTION  246()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:311
Called 9 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    9              0.000019     return g:NERDTreeMinimalUI

FUNCTION  249()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:347
Called 1 time
Total time:   0.000098
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000003     if !has_key(self, '_screenState')
                                    return
    1              0.000000     endif
    1   0.000039   0.000010     call nerdtree#exec('silent vertical resize ' . self._screenState['oldWindowSize'], 1)
                            
    1              0.000002     let old_scrolloff=&scrolloff
    1   0.000019   0.000004     let &scrolloff=0
    1              0.000005     call cursor(self._screenState['oldTopLine'], 0)
    1              0.000018     normal! zt
    1              0.000004     call setpos('.', self._screenState['oldPos'])
    1   0.000006   0.000004     let &scrolloff=old_scrolloff

FUNCTION  <SNR>11_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:13
Called 4 times
Total time:   0.009138
 Self time:   0.009002

count  total (s)   self (s)
    4              0.000024     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    4              0.000003     endif
    4              0.000026     let s = expand("<amatch>")
    4              0.000009     if s != ""
    4              0.000010       if exists("b:did_indent")
                            	unlet b:did_indent
    4              0.000003       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    8              0.000045       for name in split(s, '\.')
    4   0.008936   0.008799 	exe 'runtime! indent/' . name . '.vim'
    8              0.000020       endfor
    4              0.000005     endif

FUNCTION  <SNR>126_plugin_name()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/vsnip.vim:112
Called 6 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    6              0.000010   return self._plugin_name

FUNCTION  ale#command#CreateTempFile()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:94
Called 1 time
Total time:   0.000261
 Self time:   0.000126

count  total (s)   self (s)
    1              0.000003     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
    1              0.000001     endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
    1              0.000045     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
    1              0.000007     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    1              0.000019     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    1   0.000064   0.000023     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    1   0.000109   0.000015     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    1              0.000002     return 1

FUNCTION  <SNR>13_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:33
Called 4 times
Total time:   0.027976
 Self time:   0.018898

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    4              0.000040   syn clear
    4              0.000017   if exists("b:current_syntax")
                                unlet b:current_syntax
    4              0.000003   endif
                            
    4              0.000021   let s = expand("<amatch>")
    4              0.000009   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    4              0.000007   elseif s == "OFF"
                                let s = ""
    4              0.000003   endif
                            
    4              0.000005   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    8              0.000048     for name in split(s, '\.')
    4   0.027709   0.018631       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    8              0.000023     endfor
    4              0.000005   endif

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/cursor.vim:63
Called 7 times
Total time:   0.001630
 Self time:   0.000530

count  total (s)   self (s)
    7              0.000094     let l:buffer = bufnr('')
                            
    7              0.000025     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    7              0.000008     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    7              0.000032     if mode(1) isnot# 'n'
                                    return
    7              0.000004     endif
                            
    7   0.000953   0.000080     if ale#ShouldDoNothing(l:buffer)
    2              0.000002         return
    5              0.000002     endif
                            
    5   0.000289   0.000062     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    5              0.000008     if g:ale_echo_cursor
    5              0.000010         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
    5              0.000014         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
    5              0.000003         endif
    5              0.000003     endif
                            
    5              0.000008     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
    5              0.000003     endif

FUNCTION  250()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:364
Called 4 times
Total time:   0.000842
 Self time:   0.000214

count  total (s)   self (s)
    4              0.000016     let win = winnr()
    4              0.000024     let self._screenState = {}
    4              0.000004     try
    4   0.000568   0.000034         call g:NERDTree.CursorToTreeWin()
    4              0.000028         let self._screenState['oldPos'] = getpos('.')
    4              0.000023         let self._screenState['oldTopLine'] = line('w0')
    4              0.000029         let self._screenState['oldWindowSize'] = winnr('$')==1 ? g:NERDTreeWinSize : winwidth('')
    4   0.000130   0.000036         call nerdtree#exec(win . 'wincmd w', 1)
                                catch
    4              0.000004     endtry

FUNCTION  252()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:387
Called 46 times
Total time:   0.000688
 Self time:   0.000688

count  total (s)   self (s)
   46              0.000418     let l:line = substitute(a:line, '^.\{-}' . g:NERDTreeNodeDelimiter, '', '')
   46              0.000238     return substitute(l:line, g:NERDTreeNodeDelimiter.'.*$', '', '')

FUNCTION  253()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:393
Called 3 times
Total time:   0.076894
 Self time:   0.006062

count  total (s)   self (s)
    3   0.000026   0.000024     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
    3              0.000009     let curLine = line('.')
    3              0.000006     let curCol = col('.')
    3              0.000006     let topLine = line('w0')
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
    3              0.000061     silent 1,$delete _
                            
    3   0.000571   0.000018     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
    3   0.000027   0.000020     if !self.isMinimal()
                                    call setline(line('.')+1, '')
                                    call cursor(line('.')+1, col('.'))
    3              0.000002     endif
                            
    3   0.000025   0.000018     if self.getShowBookmarks()
                                    call self._renderBookmarks()
    3              0.000002     endif
                            
                                " add the 'up a dir' line
    3   0.000022   0.000016     if !self.isMinimal()
                                    call setline(line('.')+1, s:UI.UpDirLine())
                                    call cursor(line('.')+1, col('.'))
    3              0.000002     endif
                            
                                " draw the header line
    3   0.000393   0.000045     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    3              0.000168     call setline(line('.')+1, header)
    3              0.000022     call cursor(line('.')+1, col('.'))
                            
                                " draw the tree
    3   0.075261   0.005363     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
    3              0.000051     silent 1,1delete _
                            
                                " restore the view
    3              0.000019     let old_scrolloff=&scrolloff
    3   0.000030   0.000023     let &scrolloff=0
    3              0.000015     call cursor(topLine, 1)
    3              0.000054     normal! zt
    3              0.000007     call cursor(curLine, curCol)
    3   0.000013   0.000011     let &scrolloff = old_scrolloff
                            
    3   0.000019   0.000017     setlocal readonly nomodifiable

FUNCTION  ale#Set()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale.vim:190
Called 3 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    3              0.000016     let l:full_name = 'ale_' . a:variable_name
                            
    3              0.000015     if !has_key(g:, l:full_name)
    3              0.000016         let g:[l:full_name] = a:default
    3              0.000003     endif

FUNCTION  ale#history#Get()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/history.vim:8
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000010     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  261()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:528
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002     return '.. (up a dir)'

FUNCTION  262()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/event.vim:6
Called 105 times
Total time:   0.001245
 Self time:   0.001245

count  total (s)   self (s)
  105              0.000327     let newObj = copy(self)
  105              0.000194     let newObj.nerdtree = a:nerdtree
  105              0.000179     let newObj.subject = a:subject
  105              0.000162     let newObj.action = a:action
  105              0.000163     let newObj.params = a:params
  105              0.000108     return newObj

FUNCTION  264()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/notifier.vim:14
Called 105 times
Total time:   0.054575
 Self time:   0.004433

count  total (s)   self (s)
  105   0.002040   0.000794     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
  210   0.002438   0.000823     for Listener in s:Notifier.GetListenersForEvent(a:event)
  105              0.000888         let l:Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
  105   0.048272   0.000991         call l:Callback(event)
  210              0.000161     endfor

FUNCTION  265()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/notifier.vim:23
Called 105 times
Total time:   0.000707
 Self time:   0.000707

count  total (s)   self (s)
  105              0.000313     if !exists('s:refreshListenersMap')
                                    let s:refreshListenersMap = {}
  105              0.000057     endif
  105              0.000145     return s:refreshListenersMap

FUNCTION  266()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/notifier.vim:30
Called 105 times
Total time:   0.001615
 Self time:   0.000908

count  total (s)   self (s)
  105   0.001258   0.000551     let listenersMap = s:Notifier.GetListenersMap()
  105              0.000305     return get(listenersMap, a:name, [])

FUNCTION  <lambda>122()
    Defined: ~/.nvim/autoload/plugged/ale/ale_linters/lua/luac.vim:24
Called 1 time
Total time:   0.000035
 Self time:   0.000010

count  total (s)   self (s)
                            return ale#Var(b, 'lua_luac_executable')

FUNCTION  <lambda>123()
    Defined: ~/.nvim/autoload/plugged/ale/ale_linters/lua/luacheck.vim:38
Called 1 time
Total time:   0.000026
 Self time:   0.000009

count  total (s)   self (s)
                            return ale#Var(b, 'lua_luacheck_executable')

FUNCTION  <lambda>125()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:305
Called 1 time
Total time:   0.004161
 Self time:   0.000024

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>78_on_text_changed()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/plugin/vsnip.vim:206
Called 2 times
Total time:   0.006052
 Self time:   0.000280

count  total (s)   self (s)
    2   0.006040   0.000269   let l:session = vsnip#get_session()
    2              0.000004   if !empty(l:session)
                                call l:session.on_text_changed()
    2              0.000001   endif

FUNCTION  <SNR>126__import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vital/vsnip.vim:143
Called 10 times
Total time:   0.004862
 Self time:   0.000521

count  total (s)   self (s)
   10              0.000024   if has_key(s:loaded, a:name)
    4              0.000015     return copy(s:loaded[a:name])
    6              0.000003   endif
    6   0.002984   0.000049   let module = self._get_module(a:name)
    6              0.000014   if has_key(module, '_vital_created')
                                call module._vital_created(module)
    6              0.000003   endif
    6              0.000091   let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module._vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
    6              0.000018   let s:loaded[a:name] = export_module
    6              0.000011   if has_key(module, '_vital_loaded')
    1              0.000001     try
    1   0.000052   0.000035       call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception . " from:\n" . s:_format_throwpoint(v:throwpoint)
    1              0.000001     endtry
    6              0.000003   endif
    6              0.000021   return copy(s:loaded[a:name])

FUNCTION  ale#linter#PreProcess()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:82
Called 2 times
Total time:   0.000697
 Self time:   0.000652

count  total (s)   self (s)
    2              0.000009     if type(a:linter) isnot v:t_dict
                                    throw 'The linter object must be a Dictionary'
    2              0.000002     endif
                            
    2              0.000020     let l:obj = {   'name': get(a:linter, 'name'),   'lsp': get(a:linter, 'lsp', ''),}
                            
    2              0.000008     if type(l:obj.name) isnot v:t_string
                                    throw '`name` must be defined to name the linter'
    2              0.000002     endif
                            
    2              0.000009     let l:needs_address = l:obj.lsp is# 'socket'
    2              0.000008     let l:needs_executable = l:obj.lsp isnot# 'socket'
    2              0.000007     let l:needs_command = l:obj.lsp isnot# 'socket'
    2              0.000010     let l:needs_lsp_details = !empty(l:obj.lsp)
                            
    2              0.000005     if empty(l:obj.lsp)
    2              0.000011         let l:obj.callback = get(a:linter, 'callback')
                            
    2   0.000045   0.000028         if !s:IsCallback(l:obj.callback)
                                        throw '`callback` must be defined with a callback to accept output'
    2              0.000002         endif
    2              0.000002     endif
                            
    2              0.000014     if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                    throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
    2              0.000002     endif
                            
    2              0.000004     if !l:needs_executable
                                    if has_key(a:linter, 'executable')
                                        throw '`executable` cannot be used when lsp == ''socket'''
                                    endif
    2              0.000007     elseif has_key(a:linter, 'executable')
    2              0.000007         let l:obj.executable = a:linter.executable
                            
    2              0.000012         if type(l:obj.executable) isnot v:t_string&& type(l:obj.executable) isnot v:t_func
                                        throw '`executable` must be a String or Function if defined'
    2              0.000002         endif
                                else
                                    throw '`executable` must be defined'
    2              0.000002     endif
                            
    2              0.000004     if !l:needs_command
                                    if has_key(a:linter, 'command')
                                        throw '`command` cannot be used when lsp == ''socket'''
                                    endif
    2              0.000007     elseif has_key(a:linter, 'command')
    2              0.000007         let l:obj.command = a:linter.command
                            
    2              0.000012         if type(l:obj.command) isnot v:t_string&& type(l:obj.command) isnot v:t_func
                                        throw '`command` must be a String or Function if defined'
    2              0.000002         endif
                                else
                                    throw '`command` must be defined'
    2              0.000002     endif
                            
    2              0.000004     if !l:needs_address
    2              0.000006         if has_key(a:linter, 'address')
                                        throw '`address` cannot be used when lsp != ''socket'''
    2              0.000002         endif
                                elseif has_key(a:linter, 'address')
                                    if type(a:linter.address) isnot v:t_string&& type(a:linter.address) isnot v:t_func
                                        throw '`address` must be a String or Function if defined'
                                    endif
                            
                                    let l:obj.address = a:linter.address
                                else
                                    throw '`address` must be defined for getting the LSP address'
    2              0.000002     endif
                            
    2              0.000004     if l:needs_lsp_details
                                    " Default to using the filetype as the language.
                                    let l:obj.language = get(a:linter, 'language', a:filetype)
                            
                                    if type(l:obj.language) isnot v:t_string&& type(l:obj.language) isnot v:t_func
                                        throw '`language` must be a String or Funcref if defined'
                                    endif
                            
                                    if has_key(a:linter, 'project_root')
                                        let l:obj.project_root = a:linter.project_root
                            
                                        if type(l:obj.project_root) isnot v:t_string&& type(l:obj.project_root) isnot v:t_func
                                            throw '`project_root` must be a String or Function'
                                        endif
                                    else
                                        throw '`project_root` must be defined for LSP linters'
                                    endif
                            
                                    if has_key(a:linter, 'completion_filter')
                                        let l:obj.completion_filter = a:linter.completion_filter
                            
                                        if !s:IsCallback(l:obj.completion_filter)
                                            throw '`completion_filter` must be a callback'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'initialization_options')
                                        let l:obj.initialization_options = a:linter.initialization_options
                            
                                        if type(l:obj.initialization_options) isnot v:t_dict&& type(l:obj.initialization_options) isnot v:t_func
                                            throw '`initialization_options` must be a Dictionary or Function if defined'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'lsp_config')
                                        if type(a:linter.lsp_config) isnot v:t_dict&& type(a:linter.lsp_config) isnot v:t_func
                                            throw '`lsp_config` must be a Dictionary or Function if defined'
                                        endif
                            
                                        let l:obj.lsp_config = a:linter.lsp_config
                                    endif
    2              0.000002     endif
                            
    2              0.000012     let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                            
    2              0.000018     if type(l:obj.output_stream) isnot v:t_string|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                    throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
    2              0.000002     endif
                            
                                " An option indicating that this linter should only be run against the
                                " file on disk.
    2              0.000010     let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                            
    2   0.000043   0.000029     if !s:IsBoolean(l:obj.lint_file) && type(l:obj.lint_file) isnot v:t_func
                                    throw '`lint_file` must be `0`, `1`, or a Function'
    2              0.000002     endif
                            
                                " An option indicating that the buffer should be read.
    2              0.000010     let l:obj.read_buffer = get(a:linter, 'read_buffer', 1)
                            
    2   0.000035   0.000021     if !s:IsBoolean(l:obj.read_buffer)
                                    throw '`read_buffer` must be `0` or `1`'
    2              0.000002     endif
                            
    2              0.000010     let l:obj.aliases = get(a:linter, 'aliases', [])
                            
    2              0.000021     if type(l:obj.aliases) isnot v:t_list|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                    throw '`aliases` must be a List of String values'
    2              0.000001     endif
                            
    2              0.000003     return l:obj

FUNCTION  <SNR>52_Slash()
    Defined: ~/.nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:318
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000005     return a:path

FUNCTION  ale#util#JoinNeovimOutput()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:59
Called 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000003     if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
    1              0.000001     endif
                            
    1              0.000005     let l:lines = a:data[:-2]
                            
    1              0.000003     if len(a:data) > 1
                                    let l:lines[0] = a:last_line . l:lines[0]
                                    let l:new_last_line = a:data[-1]
    1              0.000001     else
    1              0.000006         let l:new_last_line = a:last_line . get(a:data, 0, '')
    1              0.000001     endif
                            
    1              0.000004     for l:line in l:lines
                                    call a:callback(a:job, l:line)
    1              0.000002     endfor
                            
    1              0.000002     return l:new_last_line

FUNCTION  <SNR>143_AddProblemsFromOtherBuffers()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:491
Called 1 time
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    1              0.000016     let l:filename = expand('#' . a:buffer . ':p')
    1              0.000002     let l:loclist = []
    1              0.000002     let l:name_map = {}
                            
                                " Build a map of the active linters.
    3              0.000005     for l:linter in a:linters
    2              0.000006         let l:name_map[l:linter.name] = 1
    3              0.000002     endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
    2              0.000006     for l:info in values(g:ale_buffer_info)
    1              0.000002         for l:item in l:info.loclist
                                        if has_key(l:item, 'filename')&& l:item.filename is# l:filename&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
                                        endif
    1              0.000001         endfor
    2              0.000001     endfor
                            
    1              0.000002     if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
    1              0.000001     endif

FUNCTION  <SNR>144_TemporaryFilename()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/command.vim:116
Called 1 time
Total time:   0.000082
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000007     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    1              0.000003     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
    1              0.000001     endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    1   0.000060   0.000024     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/linter.vim:410
Called 2 times
Total time:   0.000100
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000010     let l:Executable = a:linter.executable
                            
    2   0.000087   0.000026     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  <SNR>143_RunLinters()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:622
Called 1 time
Total time:   0.004730
 Self time:   0.000199

count  total (s)   self (s)
    1   0.000171   0.000029     call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
    1   0.000062   0.000020     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    1   0.000035   0.000016     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    1   0.000028   0.000014     silent doautocmd <nomodeline> User ALELintPre
                            
    3              0.000010     for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
    2              0.000005         if !l:lint_file || a:should_lint_file
    2   0.004270   0.000039             if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
    1              0.000002                 let l:can_clear_results = 0
    2              0.000002             endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
    2              0.000001         endif
    3              0.000005     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    1              0.000001     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
    1              0.000001     elseif a:new_buffer
    1   0.000108   0.000024         call s:AddProblemsFromOtherBuffers(   a:buffer,   map(copy(a:slots), 'v:val[1]'))
    1              0.000001     endif

FUNCTION  ale#util#GetFunction()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:87
Called 3 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000011     if type(a:string_or_ref) is v:t_string
    1              0.000003         return function(a:string_or_ref)
    2              0.000002     endif
                            
    2              0.000004     return a:string_or_ref

FUNCTION  ale#util#Tempname()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/util.vim:300
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000003     let l:clear_tempdir = 0
                            
    1              0.000009     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
    1              0.000001     endif
                            
    1              0.000001     try
    1              0.000005         let l:name = tempname() " no-custom-checks
    1              0.000002     finally
    1              0.000002         if l:clear_tempdir
                                        let $TMPDIR = ''
    1              0.000001         endif
    1              0.000002     endtry
                            
    1              0.000002     return l:name

FUNCTION  nerdtree#compareNodePaths()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:107
Called 430 times
Total time:   0.078678
 Self time:   0.017723

count  total (s)   self (s)
  430   0.035694   0.002276     let sortKey1 = a:p1.getSortKey()
  430   0.030029   0.002493     let sortKey2 = a:p2.getSortKey()
  430              0.000479     let i = 0
  746              0.002675     while i < min([len(sortKey1), len(sortKey2)])
                                    " Compare chunks upto common length.
                                    " If chunks have different type, the one which has
                                    " integer type is the lesser.
  746              0.002198         if type(sortKey1[i]) ==# type(sortKey2[i])
  746              0.001412             if sortKey1[i] <# sortKey2[i]
  258              0.000233                 return - 1
  488              0.000897             elseif sortKey1[i] ># sortKey2[i]
  172              0.000145                 return 1
  316              0.000161             endif
                                    elseif type(sortKey1[i]) ==# v:t_number
                                        return -1
                                    elseif type(sortKey2[i]) ==# v:t_number
                                        return 1
  316              0.000150         endif
  316              0.000403         let i = i + 1
  316              0.000248     endwhile
                            
                                " Keys are identical upto common length.
                                " The key which has smaller chunks is the lesser one.
                                if len(sortKey1) < len(sortKey2)
                                    return -1
                                elseif len(sortKey1) > len(sortKey2)
                                    return 1
                                else
                                    return 0
                                endif

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
    Defined: ~/.nvim/autoload/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:408
Called 1 time
Total time:   0.096466
 Self time:   0.000027

count  total (s)   self (s)
    1   0.096465   0.000026     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  <SNR>53_DevIconsGetArtifactFix()
    Defined: ~/.nvim/autoload/plugged/vim-webdevicons/plugin/webdevicons.vim:544
Called 267 times
Total time:   0.002499
 Self time:   0.002499

count  total (s)   self (s)
  267              0.000507   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
  267              0.000170   else
  267              0.000454     let artifactFix = ''
  267              0.000161   endif
                            
  267              0.000424   return artifactFix

FUNCTION  <SNR>148_CloseWindowIfNeeded()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/list.vim:207
Called 1 time
Total time:   0.000044
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000042   0.000011     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    1              0.000001         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  235()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:142
Called 2 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    2              0.000044     let newObj = copy(self)
    2              0.000006     let newObj.nerdtree = a:nerdtree
    2              0.000004     let newObj._showHelp = 0
    2              0.000004     let newObj._ignoreEnabled = 1
    2              0.000005     let newObj._showFiles = g:NERDTreeShowFiles
    2              0.000005     let newObj._showHidden = g:NERDTreeShowHidden
    2              0.000005     let newObj._showBookmarks = g:NERDTreeShowBookmarks
                            
    2              0.000003     return newObj

FUNCTION  <SNR>147_EscapeSignText()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:75
Called 5 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    5              0.000044     return substitute(substitute(a:sign_text, ' *$', '', ''), '\\\| ', '\\\0', 'g')

FUNCTION  <SNR>101_SetConcealOption()
    Defined: ~/.nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:96
Called 6 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
    6              0.000009     if !g:indentLine_setConceal
                                    return
    6              0.000003     endif
    6              0.000019     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
    4              0.000009         let b:indentLine_ConcealOptionSet = 1
    4              0.000014         let b:indentLine_original_concealcursor = &l:concealcursor
    4              0.000010         let b:indentLine_original_conceallevel = &l:conceallevel
    4              0.000041         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
    4              0.000028         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
    6              0.000003     endif

FUNCTION  140()
    Defined: ~/.nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:141
Called 110 times
Total time:   0.030600
 Self time:   0.000697

count  total (s)   self (s)
  110   0.030381   0.000478     if !self.isCascadable()
  110              0.000152         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  <SNR>143_RunIfExecutable()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/engine.vim:525
Called 2 times
Total time:   0.004046
 Self time:   0.000152

count  total (s)   self (s)
    2   0.000036   0.000022     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(       a:buffer,       a:linter,       a:lint_file,       executable   )}
                            
                                    return 1
    2              0.000002     endif
                            
    2   0.000787   0.000023     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
    1              0.000005         let l:job_type = a:lint_file ? 'file_linter' : 'linter'
    1              0.000006         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
    1   0.000033   0.000020         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
    1              0.000016         let l:options = {   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'read_buffer': a:linter.read_buffer,   'lint_file': a:lint_file,}
                            
    1   0.003123   0.000019         return s:RunJob(l:command, l:options)
    1              0.000001     endif
                            
    1              0.000001     return 0

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:419
Called 1 time
Total time:   0.000450
 Self time:   0.000094

count  total (s)   self (s)
    1              0.000005     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
    1              0.000001     endif
                            
                                " Find the current markers
    1   0.000178   0.000013     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    1   0.000059   0.000021     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    1   0.000031   0.000011     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    1   0.000092   0.000012     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    1   0.000064   0.000010     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    1              0.000002     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
    1              0.000000     endif
                            
    1              0.000002     for l:command in l:command_list
                                    silent! execute l:command
    1              0.000001     endfor
                            
                                " Reset the sign column color when there are no more errors.
    1              0.000002     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
    1              0.000000     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/cursor.vim:104
Called 8 times
Total time:   0.000632
 Self time:   0.000460

count  total (s)   self (s)
    8              0.000033     let l:buffer = bufnr('')
                            
    8              0.000018     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    8              0.000007     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    8              0.000023     if mode(1) isnot# 'n'
                                    return
    8              0.000004     endif
                            
    8   0.000144   0.000075     call s:StopCursorTimer()
                            
    8              0.000040     let l:pos = getpos('.')[0:2]
                            
    8              0.000018     if !exists('w:last_pos')
    3              0.000007         let w:last_pos = [0, 0, 0]
    8              0.000004     endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    8              0.000016     if l:pos != w:last_pos
    7   0.000158   0.000054         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    7              0.000014         let w:last_pos = l:pos
    7              0.000048         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    8              0.000005     endif

FUNCTION  vsnip#session#import()
    Defined: ~/.nvim/autoload/plugged/vim-vsnip/autoload/vsnip/session.vim:9
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return s:Session

FUNCTION  ale#sign#ReadSigns()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:173
Called 1 time
Total time:   0.000041
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000003     redir => l:output
    1   0.000030   0.000022         silent execute 'sign place ' . s:GroupCmd() . s:PriorityCmd() . ' buffer=' . a:buffer
    1              0.000002     redir end
                            
    1              0.000005     return split(l:output, "\n")

FUNCTION  <SNR>118_Lint()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale.vim:99
Called 1 time
Total time:   0.012590
 Self time:   0.000391

count  total (s)   self (s)
                                " Use the filetype from the buffer
    1              0.000006     let l:filetype = getbufvar(a:buffer, '&filetype')
    1   0.005722   0.000126     let l:linters = ale#linter#Get(l:filetype)
    1   0.000099   0.000022     let l:linters = ale#linter#RemoveIgnored(a:buffer, l:filetype, l:linters)
                            
                                " Tell other sources that they can start checking the buffer now.
    1              0.000004     let g:ale_want_results_buffer = a:buffer
    1   0.000058   0.000042     silent doautocmd <nomodeline> User ALEWantResults
    1              0.000004     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    1              0.000009     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
    1              0.000001     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    1              0.000029     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    1   0.006642   0.000132     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  <SNR>147_GroupLoclistItems()
    Defined: ~/.nvim/autoload/plugged/ale/autoload/ale/sign.vim:238
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002     let l:grouped_items = []
    1              0.000001     let l:last_lnum = -1
                            
    1              0.000001     for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
    1              0.000001     endfor
                            
    1              0.000001     return l:grouped_items

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.577808   0.000080  188()
    4   0.398758   0.000121  204()
    4   0.398495   0.000220  205()
    3   0.381433   0.008932  194()
    9   0.289017   0.000251  SyncTree()
    1   0.288301   0.000224  <SNR>45_findAndRevealPath()
    1   0.211415   0.000011  187()
    4   0.195844   0.000196  155()
    3   0.195431   0.003678  153()
    2   0.173187   0.000045  191()
  187   0.129040   0.082502  131()
    1   0.096466   0.000027  nerdtree#ui_glue#invokeKeyMap()
    1   0.096439   0.000104  76()
    1   0.087436   0.000049  75()
    1   0.087388   0.000029  <SNR>45_customOpenFile()
    1   0.087299   0.000057  105()
    1   0.087241   0.000035  121()
    1   0.087107   0.000020  177()
    1   0.087087   0.000060  178()
    1   0.085916   0.007822  13()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  187   0.129040   0.082502  131()
  860   0.060955   0.050565  22()
    4   0.037314   0.035343  <SNR>10_LoadFTPlugin()
  162   0.035989   0.034357  WebDevIconsGetFileTypeSymbol()
  540   0.055074   0.027088  38()
    4   0.027976   0.018898  <SNR>13_SynSet()
   43   0.039453   0.018839  139()
  430   0.078678   0.017723  nerdtree#compareNodePaths()
  112   0.023483   0.012133  34()
  105   0.047281   0.012054  NERDTreeWebDevIconsRefreshListener()
  531   0.025253   0.011736  43()
 1516              0.009955  nerdtree#runningWindows()
    4   0.009138   0.009002  <SNR>11_LoadIndent()
    3   0.381433   0.008932  194()
  210   0.010666   0.008415  26()
    3              0.008339  nerdtree#echo()
    1   0.085916   0.007822  13()
  587   0.011608   0.007512  nerdtree#slash()
  603              0.006719  19()
  165              0.006424  73()

